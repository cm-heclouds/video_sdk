/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurations(struct soap *soap, const struct _trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurations, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurations(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurations *p;
	struct _trt__GetMetadataConfigurations *a = (struct _trt__GetMetadataConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurations(struct soap *soap, const struct _trt__GetMetadataConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurations(soap, tag ? tag : "trt:GetMetadataConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
			soap_serialize_tt__VideoAnalyticsConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoAnalyticsConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoAnalyticsConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoAnalyticsConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoAnalyticsConfigurationsResponse *p;
	struct _trt__GetVideoAnalyticsConfigurationsResponse *a = (struct _trt__GetVideoAnalyticsConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoAnalyticsConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag ? tag : "trt:GetVideoAnalyticsConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_new__trt__GetVideoAnalyticsConfigurations(struct soap *soap, int n)
{
	struct _trt__GetVideoAnalyticsConfigurations *p;
	struct _trt__GetVideoAnalyticsConfigurations *a = (struct _trt__GetVideoAnalyticsConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoAnalyticsConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoAnalyticsConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoAnalyticsConfigurations(soap, tag ? tag : "trt:GetVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioSourceConfiguration);
			soap_serialize_tt__AudioSourceConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioSourceConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioSourceConfigurationsResponse *p;
	struct _trt__GetAudioSourceConfigurationsResponse *a = (struct _trt__GetAudioSourceConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourceConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourceConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourceConfigurationsResponse(soap, tag ? tag : "trt:GetAudioSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurations(struct soap *soap, const struct _trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurations, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_new__trt__GetAudioSourceConfigurations(struct soap *soap, int n)
{
	struct _trt__GetAudioSourceConfigurations *p;
	struct _trt__GetAudioSourceConfigurations *a = (struct _trt__GetAudioSourceConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourceConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourceConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurations(struct soap *soap, const struct _trt__GetAudioSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourceConfigurations(soap, tag ? tag : "trt:GetAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioEncoderConfiguration);
			soap_serialize_tt__AudioEncoderConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurationsResponse *p;
	struct _trt__GetAudioEncoderConfigurationsResponse *a = (struct _trt__GetAudioEncoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurationsResponse(soap, tag ? tag : "trt:GetAudioEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurations, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurations(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurations *p;
	struct _trt__GetAudioEncoderConfigurations *a = (struct _trt__GetAudioEncoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurations(soap, tag ? tag : "trt:GetAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoSourceConfiguration);
			soap_serialize_tt__VideoSourceConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoSourceConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceConfigurationsResponse *p;
	struct _trt__GetVideoSourceConfigurationsResponse *a = (struct _trt__GetVideoSourceConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceConfigurationsResponse(soap, tag ? tag : "trt:GetVideoSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurations(struct soap *soap, const struct _trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurations, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_new__trt__GetVideoSourceConfigurations(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceConfigurations *p;
	struct _trt__GetVideoSourceConfigurations *a = (struct _trt__GetVideoSourceConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurations(struct soap *soap, const struct _trt__GetVideoSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceConfigurations(soap, tag ? tag : "trt:GetVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoEncoderConfiguration);
			soap_serialize_tt__VideoEncoderConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_new__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoEncoderConfigurationsResponse *p;
	struct _trt__GetVideoEncoderConfigurationsResponse *a = (struct _trt__GetVideoEncoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoEncoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoEncoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoEncoderConfigurationsResponse(soap, tag ? tag : "trt:GetVideoEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurations, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_new__trt__GetVideoEncoderConfigurations(struct soap *soap, int n)
{
	struct _trt__GetVideoEncoderConfigurations *p;
	struct _trt__GetVideoEncoderConfigurations *a = (struct _trt__GetVideoEncoderConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoEncoderConfigurations));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoEncoderConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoEncoderConfigurations(soap, tag ? tag : "trt:GetVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_in__trt__DeleteProfileResponse(struct soap *soap, const char *tag, struct _trt__DeleteProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__DeleteProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfileResponse, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_new__trt__DeleteProfileResponse(struct soap *soap, int n)
{
	struct _trt__DeleteProfileResponse *p;
	struct _trt__DeleteProfileResponse *a = (struct _trt__DeleteProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteProfileResponse(soap, tag ? tag : "trt:DeleteProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_get__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfile(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfile), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_in__trt__DeleteProfile(struct soap *soap, const char *tag, struct _trt__DeleteProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__DeleteProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfile, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_new__trt__DeleteProfile(struct soap *soap, int n)
{
	struct _trt__DeleteProfile *p;
	struct _trt__DeleteProfile *a = (struct _trt__DeleteProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteProfile));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteProfile(soap, tag ? tag : "trt:DeleteProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_get__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioDecoderConfigurationResponse *p;
	struct _trt__RemoveAudioDecoderConfigurationResponse *a = (struct _trt__RemoveAudioDecoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioDecoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioDecoderConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioDecoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioDecoderConfiguration *p;
	struct _trt__RemoveAudioDecoderConfiguration *a = (struct _trt__RemoveAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioDecoderConfiguration(soap, tag ? tag : "trt:RemoveAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioDecoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioDecoderConfigurationResponse *p;
	struct _trt__AddAudioDecoderConfigurationResponse *a = (struct _trt__AddAudioDecoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioDecoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioDecoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioDecoderConfigurationResponse(soap, tag ? tag : "trt:AddAudioDecoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioDecoderConfiguration(struct soap *soap, const struct _trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfiguration, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioDecoderConfiguration *p;
	struct _trt__AddAudioDecoderConfiguration *a = (struct _trt__AddAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioDecoderConfiguration(struct soap *soap, const struct _trt__AddAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioDecoderConfiguration(soap, tag ? tag : "trt:AddAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioOutputConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioOutputConfigurationResponse *p;
	struct _trt__RemoveAudioOutputConfigurationResponse *a = (struct _trt__RemoveAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioOutputConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct _trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioOutputConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioOutputConfiguration *p;
	struct _trt__RemoveAudioOutputConfiguration *a = (struct _trt__RemoveAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct _trt__RemoveAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioOutputConfiguration(soap, tag ? tag : "trt:RemoveAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__AddAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioOutputConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioOutputConfigurationResponse *p;
	struct _trt__AddAudioOutputConfigurationResponse *a = (struct _trt__AddAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__AddAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioOutputConfigurationResponse(soap, tag ? tag : "trt:AddAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioOutputConfiguration(struct soap *soap, const struct _trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioOutputConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfiguration, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioOutputConfiguration *p;
	struct _trt__AddAudioOutputConfiguration *a = (struct _trt__AddAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioOutputConfiguration(struct soap *soap, const struct _trt__AddAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioOutputConfiguration(soap, tag ? tag : "trt:AddAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const struct _trt__RemoveMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveMetadataConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveMetadataConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveMetadataConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveMetadataConfigurationResponse *p;
	struct _trt__RemoveMetadataConfigurationResponse *a = (struct _trt__RemoveMetadataConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveMetadataConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveMetadataConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const struct _trt__RemoveMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveMetadataConfigurationResponse(soap, tag ? tag : "trt:RemoveMetadataConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveMetadataConfiguration(struct soap *soap, const struct _trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_in__trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveMetadataConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfiguration, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_new__trt__RemoveMetadataConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveMetadataConfiguration *p;
	struct _trt__RemoveMetadataConfiguration *a = (struct _trt__RemoveMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveMetadataConfiguration(struct soap *soap, const struct _trt__RemoveMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveMetadataConfiguration(soap, tag ? tag : "trt:RemoveMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_get__trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddMetadataConfigurationResponse(struct soap *soap, const struct _trt__AddMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddMetadataConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddMetadataConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfigurationResponse, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddMetadataConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddMetadataConfigurationResponse *p;
	struct _trt__AddMetadataConfigurationResponse *a = (struct _trt__AddMetadataConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddMetadataConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddMetadataConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddMetadataConfigurationResponse(struct soap *soap, const struct _trt__AddMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddMetadataConfigurationResponse(soap, tag ? tag : "trt:AddMetadataConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddMetadataConfiguration(struct soap *soap, const struct _trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddMetadataConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_in__trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__AddMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddMetadataConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfiguration, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_new__trt__AddMetadataConfiguration(struct soap *soap, int n)
{
	struct _trt__AddMetadataConfiguration *p;
	struct _trt__AddMetadataConfiguration *a = (struct _trt__AddMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddMetadataConfiguration(struct soap *soap, const struct _trt__AddMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddMetadataConfiguration(soap, tag ? tag : "trt:AddMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_get__trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveVideoAnalyticsConfigurationResponse *p;
	struct _trt__RemoveVideoAnalyticsConfigurationResponse *a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag ? tag : "trt:RemoveVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveVideoAnalyticsConfiguration *p;
	struct _trt__RemoveVideoAnalyticsConfiguration *a = (struct _trt__RemoveVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoAnalyticsConfiguration(soap, tag ? tag : "trt:RemoveVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__AddVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddVideoAnalyticsConfigurationResponse *p;
	struct _trt__AddVideoAnalyticsConfigurationResponse *a = (struct _trt__AddVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoAnalyticsConfigurationResponse(soap, tag ? tag : "trt:AddVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__trt__AddVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _trt__AddVideoAnalyticsConfiguration *p;
	struct _trt__AddVideoAnalyticsConfiguration *a = (struct _trt__AddVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__AddVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoAnalyticsConfiguration(soap, tag ? tag : "trt:AddVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemovePTZConfigurationResponse(struct soap *soap, const struct _trt__RemovePTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemovePTZConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemovePTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemovePTZConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfigurationResponse, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemovePTZConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemovePTZConfigurationResponse *p;
	struct _trt__RemovePTZConfigurationResponse *a = (struct _trt__RemovePTZConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemovePTZConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemovePTZConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemovePTZConfigurationResponse(struct soap *soap, const struct _trt__RemovePTZConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemovePTZConfigurationResponse(soap, tag ? tag : "trt:RemovePTZConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemovePTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemovePTZConfiguration(struct soap *soap, const struct _trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemovePTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemovePTZConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_in__trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct _trt__RemovePTZConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemovePTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemovePTZConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfiguration, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_new__trt__RemovePTZConfiguration(struct soap *soap, int n)
{
	struct _trt__RemovePTZConfiguration *p;
	struct _trt__RemovePTZConfiguration *a = (struct _trt__RemovePTZConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemovePTZConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemovePTZConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemovePTZConfiguration(struct soap *soap, const struct _trt__RemovePTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemovePTZConfiguration(soap, tag ? tag : "trt:RemovePTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_get__trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddPTZConfigurationResponse(struct soap *soap, const struct _trt__AddPTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddPTZConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddPTZConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfigurationResponse, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddPTZConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddPTZConfigurationResponse *p;
	struct _trt__AddPTZConfigurationResponse *a = (struct _trt__AddPTZConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddPTZConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddPTZConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddPTZConfigurationResponse(struct soap *soap, const struct _trt__AddPTZConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddPTZConfigurationResponse(soap, tag ? tag : "trt:AddPTZConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddPTZConfiguration(struct soap *soap, const struct _trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddPTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddPTZConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_in__trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct _trt__AddPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddPTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddPTZConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfiguration, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_new__trt__AddPTZConfiguration(struct soap *soap, int n)
{
	struct _trt__AddPTZConfiguration *p;
	struct _trt__AddPTZConfiguration *a = (struct _trt__AddPTZConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddPTZConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddPTZConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddPTZConfiguration(struct soap *soap, const struct _trt__AddPTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddPTZConfiguration(soap, tag ? tag : "trt:AddPTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_get__trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioSourceConfigurationResponse *p;
	struct _trt__RemoveAudioSourceConfigurationResponse *a = (struct _trt__RemoveAudioSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioSourceConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct _trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioSourceConfiguration *p;
	struct _trt__RemoveAudioSourceConfiguration *a = (struct _trt__RemoveAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct _trt__RemoveAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioSourceConfiguration(soap, tag ? tag : "trt:RemoveAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__AddAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioSourceConfigurationResponse *p;
	struct _trt__AddAudioSourceConfigurationResponse *a = (struct _trt__AddAudioSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__AddAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioSourceConfigurationResponse(soap, tag ? tag : "trt:AddAudioSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioSourceConfiguration(struct soap *soap, const struct _trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfiguration, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioSourceConfiguration *p;
	struct _trt__AddAudioSourceConfiguration *a = (struct _trt__AddAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioSourceConfiguration(struct soap *soap, const struct _trt__AddAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioSourceConfiguration(soap, tag ? tag : "trt:AddAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveAudioEncoderConfigurationResponse *p;
	struct _trt__RemoveAudioEncoderConfigurationResponse *a = (struct _trt__RemoveAudioEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioEncoderConfigurationResponse(soap, tag ? tag : "trt:RemoveAudioEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_new__trt__RemoveAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveAudioEncoderConfiguration *p;
	struct _trt__RemoveAudioEncoderConfiguration *a = (struct _trt__RemoveAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveAudioEncoderConfiguration(soap, tag ? tag : "trt:RemoveAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddAudioEncoderConfigurationResponse *p;
	struct _trt__AddAudioEncoderConfigurationResponse *a = (struct _trt__AddAudioEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioEncoderConfigurationResponse(soap, tag ? tag : "trt:AddAudioEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioEncoderConfiguration(struct soap *soap, const struct _trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfiguration, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_new__trt__AddAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__AddAudioEncoderConfiguration *p;
	struct _trt__AddAudioEncoderConfiguration *a = (struct _trt__AddAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioEncoderConfiguration(struct soap *soap, const struct _trt__AddAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddAudioEncoderConfiguration(soap, tag ? tag : "trt:AddAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveVideoSourceConfigurationResponse *p;
	struct _trt__RemoveVideoSourceConfigurationResponse *a = (struct _trt__RemoveVideoSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoSourceConfigurationResponse(soap, tag ? tag : "trt:RemoveVideoSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct _trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_new__trt__RemoveVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveVideoSourceConfiguration *p;
	struct _trt__RemoveVideoSourceConfiguration *a = (struct _trt__RemoveVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct _trt__RemoveVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoSourceConfiguration(soap, tag ? tag : "trt:RemoveVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__AddVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoSourceConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddVideoSourceConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddVideoSourceConfigurationResponse *p;
	struct _trt__AddVideoSourceConfigurationResponse *a = (struct _trt__AddVideoSourceConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoSourceConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoSourceConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__AddVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoSourceConfigurationResponse(soap, tag ? tag : "trt:AddVideoSourceConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoSourceConfiguration(struct soap *soap, const struct _trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfiguration, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_new__trt__AddVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _trt__AddVideoSourceConfiguration *p;
	struct _trt__AddVideoSourceConfiguration *a = (struct _trt__AddVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoSourceConfiguration(struct soap *soap, const struct _trt__AddVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoSourceConfiguration(soap, tag ? tag : "trt:AddVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__RemoveVideoEncoderConfigurationResponse *p;
	struct _trt__RemoveVideoEncoderConfigurationResponse *a = (struct _trt__RemoveVideoEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoEncoderConfigurationResponse(soap, tag ? tag : "trt:RemoveVideoEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct _trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_new__trt__RemoveVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__RemoveVideoEncoderConfiguration *p;
	struct _trt__RemoveVideoEncoderConfiguration *a = (struct _trt__RemoveVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__RemoveVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__RemoveVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct _trt__RemoveVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__RemoveVideoEncoderConfiguration(soap, tag ? tag : "trt:RemoveVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoEncoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__AddVideoEncoderConfigurationResponse *p;
	struct _trt__AddVideoEncoderConfigurationResponse *a = (struct _trt__AddVideoEncoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoEncoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoEncoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoEncoderConfigurationResponse(soap, tag ? tag : "trt:AddVideoEncoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoEncoderConfiguration(struct soap *soap, const struct _trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfiguration, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_new__trt__AddVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct _trt__AddVideoEncoderConfiguration *p;
	struct _trt__AddVideoEncoderConfiguration *a = (struct _trt__AddVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__AddVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__AddVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoEncoderConfiguration(struct soap *soap, const struct _trt__AddVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__AddVideoEncoderConfiguration(soap, tag ? tag : "trt:AddVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_tt__Profile);
			soap_serialize_tt__Profile(soap, a->Profiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
			if (soap_out_tt__Profile(soap, "trt:Profiles", -1, a->Profiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_in__trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Profiles", 1, NULL))
			{	if (a->Profiles == NULL)
				{	if (soap_blist_Profiles == NULL)
						soap_blist_Profiles = soap_alloc_block(soap);
					a->Profiles = (struct tt__Profile *)soap_push_block_max(soap, soap_blist_Profiles, sizeof(struct tt__Profile));
					if (a->Profiles == NULL)
						return NULL;
					soap_default_tt__Profile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Profile(soap, "trt:Profiles", a->Profiles, "tt:Profile"))
				{	a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Profiles)
			soap_pop_block(soap, soap_blist_Profiles);
		if (a->__sizeProfiles)
		{	a->Profiles = (struct tt__Profile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		}
		else
		{	a->Profiles = NULL;
			if (soap_blist_Profiles)
				soap_end_block(soap, soap_blist_Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfilesResponse, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_new__trt__GetProfilesResponse(struct soap *soap, int n)
{
	struct _trt__GetProfilesResponse *p;
	struct _trt__GetProfilesResponse *a = (struct _trt__GetProfilesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetProfilesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetProfilesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetProfilesResponse(soap, tag ? tag : "trt:GetProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_get__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
