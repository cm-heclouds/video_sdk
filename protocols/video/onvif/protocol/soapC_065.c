/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoder2Configuration))
		soap_serialize_tt__VideoEncoder2Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoder2Configuration(struct soap *soap, const char *tag, int id, struct tt__VideoEncoder2Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoder2Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoder2Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoder2Configuration(struct soap *soap, const char *tag, struct tt__VideoEncoder2Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoder2Configuration **)soap_malloc(soap, sizeof(struct tt__VideoEncoder2Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoder2Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoder2Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoder2Configuration(soap, tag ? tag : "tt:VideoEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StreamingCapabilities(struct soap *soap, struct ns6__StreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__StreamingCapabilities))
		soap_serialize_ns6__StreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__StreamingCapabilities(struct soap *soap, const char *tag, int id, struct ns6__StreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__StreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__StreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTons6__StreamingCapabilities(struct soap *soap, const char *tag, struct ns6__StreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__StreamingCapabilities **)soap_malloc(soap, sizeof(struct ns6__StreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__StreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StreamingCapabilities, sizeof(struct ns6__StreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StreamingCapabilities(struct soap *soap, struct ns6__StreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__StreamingCapabilities(soap, tag ? tag : "ns6:StreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__StreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTons6__StreamingCapabilities(struct soap *soap, struct ns6__StreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ProfileCapabilities(struct soap *soap, struct ns6__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ProfileCapabilities))
		soap_serialize_ns6__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct ns6__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTons6__ProfileCapabilities(struct soap *soap, const char *tag, struct ns6__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__ProfileCapabilities **)soap_malloc(soap, sizeof(struct ns6__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ProfileCapabilities, sizeof(struct ns6__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ProfileCapabilities(struct soap *soap, struct ns6__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ProfileCapabilities(soap, tag ? tag : "ns6:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTons6__ProfileCapabilities(struct soap *soap, struct ns6__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptions))
		soap_serialize_tt__OSDConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__OSDConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptions(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__OSDConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfiguration))
		soap_serialize_tt__OSDConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDConfiguration(struct soap *soap, const char *tag, struct tt__OSDConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__VideoSourceMode))
		soap_serialize_trt__VideoSourceMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, int id, struct trt__VideoSourceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__VideoSourceMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__VideoSourceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__VideoSourceMode ** SOAP_FMAC4 soap_in_PointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, struct trt__VideoSourceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__VideoSourceMode **)soap_malloc(soap, sizeof(struct trt__VideoSourceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__VideoSourceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__VideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceMode, sizeof(struct trt__VideoSourceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__VideoSourceMode(soap, tag ? tag : "trt:VideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__VideoSourceMode ** SOAP_FMAC4 soap_get_PointerTotrt__VideoSourceMode(struct soap *soap, struct trt__VideoSourceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__VideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
		soap_serialize_tt__MediaUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, struct tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaUri **)soap_malloc(soap, sizeof(struct tt__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfigurationOptions))
		soap_serialize_tt__AudioOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptions))
		soap_serialize_tt__MetadataConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, tag ? tag : "tt:MetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfigurationOptions))
		soap_serialize_tt__AudioSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions))
		soap_serialize_tt__VideoEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptions))
		soap_serialize_tt__VideoSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Profile))
		soap_serialize_tt__Profile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Profile(struct soap *soap, const char *tag, int id, struct tt__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Profile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_in_PointerTott__Profile(struct soap *soap, const char *tag, struct tt__Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Profile **)soap_malloc(soap, sizeof(struct tt__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Profile(soap, tag ? tag : "tt:Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_get_PointerTott__Profile(struct soap *soap, struct tt__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutput))
		soap_serialize_tt__AudioOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutput(struct soap *soap, const char *tag, int id, struct tt__AudioOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutput ** SOAP_FMAC4 soap_in_PointerTott__AudioOutput(struct soap *soap, const char *tag, struct tt__AudioOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutput **)soap_malloc(soap, sizeof(struct tt__AudioOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutput(soap, tag ? tag : "tt:AudioOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutput ** SOAP_FMAC4 soap_get_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSource))
		soap_serialize_tt__AudioSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSource(struct soap *soap, const char *tag, int id, struct tt__AudioSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSource ** SOAP_FMAC4 soap_in_PointerTott__AudioSource(struct soap *soap, const char *tag, struct tt__AudioSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSource **)soap_malloc(soap, sizeof(struct tt__AudioSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSource(soap, tag ? tag : "tt:AudioSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSource ** SOAP_FMAC4 soap_get_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSource))
		soap_serialize_tt__VideoSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSource(struct soap *soap, const char *tag, int id, struct tt__VideoSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSource, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSource ** SOAP_FMAC4 soap_in_PointerTott__VideoSource(struct soap *soap, const char *tag, struct tt__VideoSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSource **)soap_malloc(soap, sizeof(struct tt__VideoSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSource(soap, tag ? tag : "tt:VideoSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSource ** SOAP_FMAC4 soap_get_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__Capabilities))
		soap_serialize_trt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__Capabilities(struct soap *soap, const char *tag, int id, struct trt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__Capabilities **)soap_malloc(soap, sizeof(struct trt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__Capabilities(soap, tag ? tag : "trt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__VideoSourceModeExtension))
		soap_serialize_trt__VideoSourceModeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__VideoSourceModeExtension(struct soap *soap, const char *tag, int id, struct trt__VideoSourceModeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__VideoSourceModeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__VideoSourceModeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension ** SOAP_FMAC4 soap_in_PointerTotrt__VideoSourceModeExtension(struct soap *soap, const char *tag, struct trt__VideoSourceModeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__VideoSourceModeExtension **)soap_malloc(soap, sizeof(struct trt__VideoSourceModeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__VideoSourceModeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__VideoSourceModeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(struct trt__VideoSourceModeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__VideoSourceModeExtension(soap, tag ? tag : "trt:VideoSourceModeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__VideoSourceModeExtension ** SOAP_FMAC4 soap_get_PointerTotrt__VideoSourceModeExtension(struct soap *soap, struct trt__VideoSourceModeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__VideoSourceModeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__StreamingCapabilities))
		soap_serialize_trt__StreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, int id, struct trt__StreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__StreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__StreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__StreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, struct trt__StreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__StreamingCapabilities **)soap_malloc(soap, sizeof(struct trt__StreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__StreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__StreamingCapabilities(soap, tag ? tag : "trt:StreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__StreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__ProfileCapabilities))
		soap_serialize_trt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct trt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct trt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__ProfileCapabilities(soap, tag ? tag : "trt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__ImagingPreset(struct soap *soap, struct timg__ImagingPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__ImagingPreset))
		soap_serialize_timg__ImagingPreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, struct timg__ImagingPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__ImagingPreset, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_timg__ImagingPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct timg__ImagingPreset ** SOAP_FMAC4 soap_in_PointerTotimg__ImagingPreset(struct soap *soap, const char *tag, struct timg__ImagingPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct timg__ImagingPreset **)soap_malloc(soap, sizeof(struct timg__ImagingPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_timg__ImagingPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct timg__ImagingPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__ImagingPreset, sizeof(struct timg__ImagingPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__ImagingPreset(struct soap *soap, struct timg__ImagingPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotimg__ImagingPreset(soap, tag ? tag : "timg:ImagingPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__ImagingPreset ** SOAP_FMAC4 soap_get_PointerTotimg__ImagingPreset(struct soap *soap, struct timg__ImagingPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__ImagingPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20))
		soap_serialize_tt__ImagingStatus20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, int id, struct tt__ImagingStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingStatus20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingStatus20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, struct tt__ImagingStatus20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingStatus20 **)soap_malloc(soap, sizeof(struct tt__ImagingStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingStatus20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MoveOptions20))
		soap_serialize_tt__MoveOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveOptions20(struct soap *soap, const char *tag, int id, struct tt__MoveOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MoveOptions20 ** SOAP_FMAC4 soap_in_PointerTott__MoveOptions20(struct soap *soap, const char *tag, struct tt__MoveOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MoveOptions20 **)soap_malloc(soap, sizeof(struct tt__MoveOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions20 ** SOAP_FMAC4 soap_get_PointerTott__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusMove(struct soap *soap, struct tt__FocusMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusMove))
		soap_serialize_tt__FocusMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusMove(struct soap *soap, const char *tag, int id, struct tt__FocusMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusMove, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusMove ** SOAP_FMAC4 soap_in_PointerTott__FocusMove(struct soap *soap, const char *tag, struct tt__FocusMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusMove **)soap_malloc(soap, sizeof(struct tt__FocusMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusMove(struct soap *soap, struct tt__FocusMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusMove ** SOAP_FMAC4 soap_get_PointerTott__FocusMove(struct soap *soap, struct tt__FocusMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20))
		soap_serialize_tt__ImagingOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, struct tt__ImagingOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__Capabilities(struct soap *soap, struct timg__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__Capabilities))
		soap_serialize_timg__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__Capabilities(struct soap *soap, const char *tag, int id, struct timg__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_timg__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct timg__Capabilities ** SOAP_FMAC4 soap_in_PointerTotimg__Capabilities(struct soap *soap, const char *tag, struct timg__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct timg__Capabilities **)soap_malloc(soap, sizeof(struct timg__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_timg__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct timg__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__Capabilities(struct soap *soap, struct timg__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotimg__Capabilities(soap, tag ? tag : "timg:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__Capabilities ** SOAP_FMAC4 soap_get_PointerTotimg__Capabilities(struct soap *soap, struct timg__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy))
		soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tev__Capabilities))
		soap_serialize_tev__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotev__Capabilities(struct soap *soap, const char *tag, int id, struct tev__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tev__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tev__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tev__Capabilities ** SOAP_FMAC4 soap_in_PointerTotev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tev__Capabilities **)soap_malloc(soap, sizeof(struct tev__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tev__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities ** SOAP_FMAC4 soap_get_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__AccessDoorExtension(struct soap *soap, struct ns5__AccessDoorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__AccessDoorExtension))
		soap_serialize_ns5__AccessDoorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__AccessDoorExtension(struct soap *soap, const char *tag, int id, struct ns5__AccessDoorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__AccessDoorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__AccessDoorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__AccessDoorExtension ** SOAP_FMAC4 soap_in_PointerTons5__AccessDoorExtension(struct soap *soap, const char *tag, struct ns5__AccessDoorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__AccessDoorExtension **)soap_malloc(soap, sizeof(struct ns5__AccessDoorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__AccessDoorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__AccessDoorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__AccessDoorExtension, sizeof(struct ns5__AccessDoorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__AccessDoorExtension(struct soap *soap, struct ns5__AccessDoorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__AccessDoorExtension(soap, tag ? tag : "ns5:AccessDoorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__AccessDoorExtension ** SOAP_FMAC4 soap_get_PointerTons5__AccessDoorExtension(struct soap *soap, struct ns5__AccessDoorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__AccessDoorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DoorState(struct soap *soap, struct ns5__DoorState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DoorState))
		soap_serialize_ns5__DoorState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DoorState(struct soap *soap, const char *tag, int id, struct ns5__DoorState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DoorState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__DoorState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__DoorState ** SOAP_FMAC4 soap_in_PointerTons5__DoorState(struct soap *soap, const char *tag, struct ns5__DoorState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__DoorState **)soap_malloc(soap, sizeof(struct ns5__DoorState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__DoorState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__DoorState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DoorState, sizeof(struct ns5__DoorState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DoorState(struct soap *soap, struct ns5__DoorState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DoorState(soap, tag ? tag : "ns5:DoorState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorState ** SOAP_FMAC4 soap_get_PointerTons5__DoorState(struct soap *soap, struct ns5__DoorState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DoorState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DoorInfo(struct soap *soap, struct ns5__DoorInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DoorInfo))
		soap_serialize_ns5__DoorInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DoorInfo(struct soap *soap, const char *tag, int id, struct ns5__DoorInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DoorInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__DoorInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__DoorInfo ** SOAP_FMAC4 soap_in_PointerTons5__DoorInfo(struct soap *soap, const char *tag, struct ns5__DoorInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__DoorInfo **)soap_malloc(soap, sizeof(struct ns5__DoorInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__DoorInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__DoorInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DoorInfo, sizeof(struct ns5__DoorInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DoorInfo(struct soap *soap, struct ns5__DoorInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DoorInfo(soap, tag ? tag : "ns5:DoorInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorInfo ** SOAP_FMAC4 soap_get_PointerTons5__DoorInfo(struct soap *soap, struct ns5__DoorInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DoorInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ServiceCapabilities(struct soap *soap, struct ns5__ServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ServiceCapabilities))
		soap_serialize_ns5__ServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ServiceCapabilities(struct soap *soap, const char *tag, int id, struct ns5__ServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__ServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__ServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTons5__ServiceCapabilities(struct soap *soap, const char *tag, struct ns5__ServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__ServiceCapabilities **)soap_malloc(soap, sizeof(struct ns5__ServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__ServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__ServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ServiceCapabilities, sizeof(struct ns5__ServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ServiceCapabilities(struct soap *soap, struct ns5__ServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__ServiceCapabilities(soap, tag ? tag : "ns5:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTons5__ServiceCapabilities(struct soap *soap, struct ns5__ServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DoorFault(struct soap *soap, struct ns5__DoorFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DoorFault))
		soap_serialize_ns5__DoorFault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DoorFault(struct soap *soap, const char *tag, int id, struct ns5__DoorFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DoorFault, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__DoorFault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__DoorFault ** SOAP_FMAC4 soap_in_PointerTons5__DoorFault(struct soap *soap, const char *tag, struct ns5__DoorFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__DoorFault **)soap_malloc(soap, sizeof(struct ns5__DoorFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__DoorFault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__DoorFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DoorFault, sizeof(struct ns5__DoorFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DoorFault(struct soap *soap, struct ns5__DoorFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DoorFault(soap, tag ? tag : "ns5:DoorFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorFault ** SOAP_FMAC4 soap_get_PointerTons5__DoorFault(struct soap *soap, struct ns5__DoorFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DoorFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DoorTamper(struct soap *soap, struct ns5__DoorTamper *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DoorTamper))
		soap_serialize_ns5__DoorTamper(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DoorTamper(struct soap *soap, const char *tag, int id, struct ns5__DoorTamper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DoorTamper, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__DoorTamper(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns5__DoorTamper ** SOAP_FMAC4 soap_in_PointerTons5__DoorTamper(struct soap *soap, const char *tag, struct ns5__DoorTamper **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns5__DoorTamper **)soap_malloc(soap, sizeof(struct ns5__DoorTamper *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__DoorTamper(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns5__DoorTamper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DoorTamper, sizeof(struct ns5__DoorTamper), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DoorTamper(struct soap *soap, struct ns5__DoorTamper *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DoorTamper(soap, tag ? tag : "ns5:DoorTamper", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorTamper ** SOAP_FMAC4 soap_get_PointerTons5__DoorTamper(struct soap *soap, struct ns5__DoorTamper **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DoorTamper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DoorAlarmState(struct soap *soap, enum ns5__DoorAlarmState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns5__DoorAlarmState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DoorAlarmState(struct soap *soap, const char *tag, int id, enum ns5__DoorAlarmState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DoorAlarmState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__DoorAlarmState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns5__DoorAlarmState ** SOAP_FMAC4 soap_in_PointerTons5__DoorAlarmState(struct soap *soap, const char *tag, enum ns5__DoorAlarmState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns5__DoorAlarmState **)soap_malloc(soap, sizeof(enum ns5__DoorAlarmState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__DoorAlarmState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns5__DoorAlarmState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DoorAlarmState, sizeof(enum ns5__DoorAlarmState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DoorAlarmState(struct soap *soap, enum ns5__DoorAlarmState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DoorAlarmState(soap, tag ? tag : "ns5:DoorAlarmState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__DoorAlarmState ** SOAP_FMAC4 soap_get_PointerTons5__DoorAlarmState(struct soap *soap, enum ns5__DoorAlarmState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DoorAlarmState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__LockPhysicalState(struct soap *soap, enum ns5__LockPhysicalState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns5__LockPhysicalState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__LockPhysicalState(struct soap *soap, const char *tag, int id, enum ns5__LockPhysicalState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__LockPhysicalState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__LockPhysicalState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns5__LockPhysicalState ** SOAP_FMAC4 soap_in_PointerTons5__LockPhysicalState(struct soap *soap, const char *tag, enum ns5__LockPhysicalState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns5__LockPhysicalState **)soap_malloc(soap, sizeof(enum ns5__LockPhysicalState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__LockPhysicalState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns5__LockPhysicalState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__LockPhysicalState, sizeof(enum ns5__LockPhysicalState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__LockPhysicalState(struct soap *soap, enum ns5__LockPhysicalState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__LockPhysicalState(soap, tag ? tag : "ns5:LockPhysicalState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__LockPhysicalState ** SOAP_FMAC4 soap_get_PointerTons5__LockPhysicalState(struct soap *soap, enum ns5__LockPhysicalState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__LockPhysicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DoorPhysicalState(struct soap *soap, enum ns5__DoorPhysicalState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns5__DoorPhysicalState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DoorPhysicalState(struct soap *soap, const char *tag, int id, enum ns5__DoorPhysicalState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DoorPhysicalState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns5__DoorPhysicalState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns5__DoorPhysicalState ** SOAP_FMAC4 soap_in_PointerTons5__DoorPhysicalState(struct soap *soap, const char *tag, enum ns5__DoorPhysicalState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns5__DoorPhysicalState **)soap_malloc(soap, sizeof(enum ns5__DoorPhysicalState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns5__DoorPhysicalState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns5__DoorPhysicalState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DoorPhysicalState, sizeof(enum ns5__DoorPhysicalState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DoorPhysicalState(struct soap *soap, enum ns5__DoorPhysicalState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons5__DoorPhysicalState(soap, tag ? tag : "ns5:DoorPhysicalState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__DoorPhysicalState ** SOAP_FMAC4 soap_get_PointerTons5__DoorPhysicalState(struct soap *soap, enum ns5__DoorPhysicalState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DoorPhysicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneConfiguration))
		soap_serialize_tt__PaneConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneConfiguration(struct soap *soap, const char *tag, int id, struct tt__PaneConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PaneConfiguration(struct soap *soap, const char *tag, struct tt__PaneConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneConfiguration **)soap_malloc(soap, sizeof(struct tt__PaneConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PaneConfiguration(soap, tag ? tag : "tt:PaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CodingCapabilities))
		soap_serialize_tt__CodingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CodingCapabilities(struct soap *soap, const char *tag, int id, struct tt__CodingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CodingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CodingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CodingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__CodingCapabilities(struct soap *soap, const char *tag, struct tt__CodingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CodingCapabilities **)soap_malloc(soap, sizeof(struct tt__CodingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CodingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CodingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CodingCapabilities(soap, tag ? tag : "tt:CodingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CodingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CodingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutOptions))
		soap_serialize_tt__LayoutOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutOptions(struct soap *soap, const char *tag, int id, struct tt__LayoutOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutOptions ** SOAP_FMAC4 soap_in_PointerTott__LayoutOptions(struct soap *soap, const char *tag, struct tt__LayoutOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutOptions **)soap_malloc(soap, sizeof(struct tt__LayoutOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LayoutOptions(soap, tag ? tag : "tt:LayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptions ** SOAP_FMAC4 soap_get_PointerTott__LayoutOptions(struct soap *soap, struct tt__LayoutOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Layout(struct soap *soap, struct tt__Layout *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Layout))
		soap_serialize_tt__Layout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Layout(struct soap *soap, const char *tag, int id, struct tt__Layout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Layout, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Layout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Layout ** SOAP_FMAC4 soap_in_PointerTott__Layout(struct soap *soap, const char *tag, struct tt__Layout **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Layout **)soap_malloc(soap, sizeof(struct tt__Layout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Layout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Layout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Layout(struct soap *soap, struct tt__Layout *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Layout(soap, tag ? tag : "tt:Layout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Layout ** SOAP_FMAC4 soap_get_PointerTott__Layout(struct soap *soap, struct tt__Layout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotls__Capabilities(struct soap *soap, struct tls__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tls__Capabilities))
		soap_serialize_tls__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotls__Capabilities(struct soap *soap, const char *tag, int id, struct tls__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tls__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tls__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tls__Capabilities ** SOAP_FMAC4 soap_in_PointerTotls__Capabilities(struct soap *soap, const char *tag, struct tls__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tls__Capabilities **)soap_malloc(soap, sizeof(struct tls__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tls__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tls__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotls__Capabilities(struct soap *soap, struct tls__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotls__Capabilities(soap, tag ? tag : "tls:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tls__Capabilities ** SOAP_FMAC4 soap_get_PointerTotls__Capabilities(struct soap *soap, struct tls__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotls__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfigurationData))
		soap_serialize_tds__StorageConfigurationData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, int id, struct tds__StorageConfigurationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfigurationData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__StorageConfigurationData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__StorageConfigurationData ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, struct tds__StorageConfigurationData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__StorageConfigurationData **)soap_malloc(soap, sizeof(struct tds__StorageConfigurationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__StorageConfigurationData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfigurationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfigurationData ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfiguration))
		soap_serialize_tds__StorageConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, struct tds__StorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tds__StorageConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__StorageConfiguration ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, struct tds__StorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__StorageConfiguration **)soap_malloc(soap, sizeof(struct tds__StorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__StorageConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfiguration ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension))
		soap_serialize__tds__GetSystemUrisResponse_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUrisResponse_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(struct _tds__GetSystemUrisResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUriList))
		soap_serialize_tt__SystemLogUriList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, int id, struct tt__SystemLogUriList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUriList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLogUriList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLogUriList **)soap_malloc(soap, sizeof(struct tt__SystemLogUriList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLogUriList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworks))
		soap_serialize_tt__Dot11AvailableNetworks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, struct tt__Dot11AvailableNetworks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworks, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(struct tt__Dot11AvailableNetworks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AvailableNetworks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Status))
		soap_serialize_tt__Dot11Status(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Status(struct soap *soap, const char *tag, int id, struct tt__Dot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Status, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Status(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_in_PointerTott__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Status **)soap_malloc(soap, sizeof(struct tt__Dot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_get_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Capabilities))
		soap_serialize_tt__Dot11Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, int id, struct tt__Dot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Capabilities **)soap_malloc(soap, sizeof(struct tt__Dot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		soap_serialize_tt__RelayOutputSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, struct tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutputSettings **)soap_malloc(soap, sizeof(struct tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
