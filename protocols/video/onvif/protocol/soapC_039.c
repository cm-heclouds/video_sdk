/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const struct tt__VideoResolution *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoResolution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoResolution(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_new_tt__VideoResolution(struct soap *soap, int n)
{
	struct tt__VideoResolution *p;
	struct tt__VideoResolution *a = (struct tt__VideoResolution*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoResolution));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoResolution(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RotateOptionsExtension(struct soap *soap, const struct tt__RotateOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__RotateOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension * SOAP_FMAC4 soap_in_tt__RotateOptionsExtension(struct soap *soap, const char *tag, struct tt__RotateOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RotateOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RotateOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptionsExtension, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RotateOptionsExtension * SOAP_FMAC4 soap_new_tt__RotateOptionsExtension(struct soap *soap, int n)
{
	struct tt__RotateOptionsExtension *p;
	struct tt__RotateOptionsExtension *a = (struct tt__RotateOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RotateOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RotateOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateOptionsExtension(struct soap *soap, const struct tt__RotateOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateOptionsExtension(soap, tag ? tag : "tt:RotateOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension * SOAP_FMAC4 soap_get_tt__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const struct tt__VideoSourceConfigurationOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationOptionsExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_new_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, int n)
{
	struct tt__VideoSourceConfigurationOptionsExtension2 *p;
	struct tt__VideoSourceConfigurationOptionsExtension2 *a = (struct tt__VideoSourceConfigurationOptionsExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfigurationOptionsExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfigurationOptionsExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const struct tt__VideoSourceConfigurationOptionsExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RotateOptions(struct soap *soap, struct tt__RotateOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->DegreeList = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RotateOptions(struct soap *soap, const struct tt__RotateOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__RotateMode);
		}
	}
	soap_serialize_PointerTott__IntList(soap, &a->DegreeList);
	soap_serialize_PointerTott__RotateOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptions(struct soap *soap, const char *tag, int id, const struct tt__RotateOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IntList(soap, "tt:DegreeList", -1, &a->DegreeList, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RotateOptions * SOAP_FMAC4 soap_in_tt__RotateOptions(struct soap *soap, const char *tag, struct tt__RotateOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_DegreeList = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RotateOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RotateOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__RotateMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__RotateMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__RotateMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__RotateMode(soap, "tt:Mode", a->Mode, "tt:RotateMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_DegreeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:DegreeList", &a->DegreeList, "tt:IntList"))
				{	soap_flag_DegreeList--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RotateOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:RotateOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__RotateMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RotateOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptions, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RotateOptions * SOAP_FMAC4 soap_new_tt__RotateOptions(struct soap *soap, int n)
{
	struct tt__RotateOptions *p;
	struct tt__RotateOptions *a = (struct tt__RotateOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RotateOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__RotateOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateOptions(struct soap *soap, const struct tt__RotateOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateOptions(soap, tag ? tag : "tt:RotateOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptions * SOAP_FMAC4 soap_get_tt__RotateOptions(struct soap *soap, struct tt__RotateOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Rotate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoSourceConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RotateOptions(soap, &a->Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension), type))
		return soap->error;
	if (soap_out_PointerTott__RotateOptions(soap, "tt:Rotate", -1, &a->Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	size_t soap_flag_Rotate = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RotateOptions(soap, "tt:Rotate", &a->Rotate, "tt:RotateOptions"))
				{	soap_flag_Rotate--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationOptionsExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_new_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int n)
{
	struct tt__VideoSourceConfigurationOptionsExtension *p;
	struct tt__VideoSourceConfigurationOptionsExtension *a = (struct tt__VideoSourceConfigurationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfigurationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfigurationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoSourceConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundsRange = NULL;
	a->__sizeVideoSourceTokensAvailable = 0;
	a->VideoSourceTokensAvailable = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationOptions(struct soap *soap, const struct tt__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRectangleRange(soap, &a->BoundsRange);
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->VideoSourceTokensAvailable + i));
		}
	}
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), type))
		return soap->error;
	if (!a->BoundsRange)
	{	if (soap_element_nil(soap, "tt:BoundsRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->BoundsRange, ""))
		return soap->error;
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceTokensAvailable; i++)
			soap_out_string(soap, "tt:VideoSourceTokensAvailable", -1, (char*const*)(a->VideoSourceTokensAvailable + i), "");
	}
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_BoundsRange = 1;
	struct soap_blist *soap_blist_VideoSourceTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &a->BoundsRange, "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:VideoSourceTokensAvailable", 1, NULL))
			{	if (a->VideoSourceTokensAvailable == NULL)
				{	if (soap_blist_VideoSourceTokensAvailable == NULL)
						soap_blist_VideoSourceTokensAvailable = soap_alloc_block(soap);
					a->VideoSourceTokensAvailable = (char **)soap_push_block_max(soap, soap_blist_VideoSourceTokensAvailable, sizeof(char *));
					if (a->VideoSourceTokensAvailable == NULL)
						return NULL;
					*a->VideoSourceTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", (char**)a->VideoSourceTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeVideoSourceTokensAvailable++;
					a->VideoSourceTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceTokensAvailable)
			soap_pop_block(soap, soap_blist_VideoSourceTokensAvailable);
		if (a->__sizeVideoSourceTokensAvailable)
		{	a->VideoSourceTokensAvailable = (char **)soap_save_block(soap, soap_blist_VideoSourceTokensAvailable, NULL, 1);
		}
		else
		{	a->VideoSourceTokensAvailable = NULL;
			if (soap_blist_VideoSourceTokensAvailable)
				soap_end_block(soap, soap_blist_VideoSourceTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundsRange > 0 || a->__sizeVideoSourceTokensAvailable < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoSourceConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoSourceConfigurationOptions *p;
	struct tt__VideoSourceConfigurationOptions *a = (struct tt__VideoSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationOptions(struct soap *soap, const struct tt__VideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LensOffset(struct soap *soap, struct tt__LensOffset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->x = NULL;
	a->y = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LensOffset(struct soap *soap, const struct tt__LensOffset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensOffset(struct soap *soap, const char *tag, int id, const struct tt__LensOffset *a, const char *type)
{
	if (a->x)
		soap_set_attr(soap, "x", soap_float2s(soap, *a->x), 1);
	if (a->y)
		soap_set_attr(soap, "y", soap_float2s(soap, *a->y), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensOffset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LensOffset * SOAP_FMAC4 soap_in_tt__LensOffset(struct soap *soap, const char *tag, struct tt__LensOffset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LensOffset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LensOffset(soap, a);
	{	const char *t = soap_attr_value(soap, "x", 0);
		if (t)
		{
			if (!(a->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "y", 0);
		if (t)
		{
			if (!(a->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LensOffset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensOffset, SOAP_TYPE_tt__LensOffset, sizeof(struct tt__LensOffset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LensOffset * SOAP_FMAC4 soap_new_tt__LensOffset(struct soap *soap, int n)
{
	struct tt__LensOffset *p;
	struct tt__LensOffset *a = (struct tt__LensOffset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LensOffset));
	for (p = a; p && n--; p++)
		soap_default_tt__LensOffset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LensOffset(struct soap *soap, const struct tt__LensOffset *a, const char *tag, const char *type)
{
	if (soap_out_tt__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensOffset * SOAP_FMAC4 soap_get_tt__LensOffset(struct soap *soap, struct tt__LensOffset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LensProjection(struct soap *soap, struct tt__LensProjection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Angle);
	soap_default_float(soap, &a->Radius);
	a->Transmittance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LensProjection(struct soap *soap, const struct tt__LensProjection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Angle, SOAP_TYPE_float);
	soap_embedded(soap, &a->Radius, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Transmittance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensProjection(struct soap *soap, const char *tag, int id, const struct tt__LensProjection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensProjection), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Angle", -1, &a->Angle, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Radius", -1, &a->Radius, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Transmittance", -1, &a->Transmittance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LensProjection * SOAP_FMAC4 soap_in_tt__LensProjection(struct soap *soap, const char *tag, struct tt__LensProjection *a, const char *type)
{
	size_t soap_flag_Angle = 1;
	size_t soap_flag_Radius = 1;
	size_t soap_flag_Transmittance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LensProjection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LensProjection(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Angle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Angle", &a->Angle, "xsd:float"))
				{	soap_flag_Angle--;
					continue;
				}
			if (soap_flag_Radius && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Radius", &a->Radius, "xsd:float"))
				{	soap_flag_Radius--;
					continue;
				}
			if (soap_flag_Transmittance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Transmittance", &a->Transmittance, "xsd:float"))
				{	soap_flag_Transmittance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Angle > 0 || soap_flag_Radius > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__LensProjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_tt__LensProjection, sizeof(struct tt__LensProjection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LensProjection * SOAP_FMAC4 soap_new_tt__LensProjection(struct soap *soap, int n)
{
	struct tt__LensProjection *p;
	struct tt__LensProjection *a = (struct tt__LensProjection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LensProjection));
	for (p = a; p && n--; p++)
		soap_default_tt__LensProjection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LensProjection(struct soap *soap, const struct tt__LensProjection *a, const char *tag, const char *type)
{
	if (soap_out_tt__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensProjection * SOAP_FMAC4 soap_get_tt__LensProjection(struct soap *soap, struct tt__LensProjection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RotateExtension(struct soap *soap, struct tt__RotateExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RotateExtension(struct soap *soap, const struct tt__RotateExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateExtension(struct soap *soap, const char *tag, int id, const struct tt__RotateExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RotateExtension * SOAP_FMAC4 soap_in_tt__RotateExtension(struct soap *soap, const char *tag, struct tt__RotateExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RotateExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RotateExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RotateExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateExtension, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RotateExtension * SOAP_FMAC4 soap_new_tt__RotateExtension(struct soap *soap, int n)
{
	struct tt__RotateExtension *p;
	struct tt__RotateExtension *a = (struct tt__RotateExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RotateExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RotateExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateExtension(struct soap *soap, const struct tt__RotateExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateExtension * SOAP_FMAC4 soap_get_tt__RotateExtension(struct soap *soap, struct tt__RotateExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LensDescription(struct soap *soap, struct tt__LensDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Offset = NULL;
	a->__sizeProjection = 0;
	a->Projection = NULL;
	soap_default_float(soap, &a->XFactor);
	a->FocalLength = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LensDescription(struct soap *soap, const struct tt__LensDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__LensOffset(soap, &a->Offset);
	if (a->Projection)
	{	int i;
		for (i = 0; i < (int)a->__sizeProjection; i++)
		{
			soap_embedded(soap, a->Projection + i, SOAP_TYPE_tt__LensProjection);
			soap_serialize_tt__LensProjection(soap, a->Projection + i);
		}
	}
	soap_embedded(soap, &a->XFactor, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensDescription(struct soap *soap, const char *tag, int id, const struct tt__LensDescription *a, const char *type)
{
	if (a->FocalLength)
		soap_set_attr(soap, "FocalLength", soap_float2s(soap, *a->FocalLength), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensDescription), type))
		return soap->error;
	if (!a->Offset)
	{	if (soap_element_nil(soap, "tt:Offset"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__LensOffset(soap, "tt:Offset", -1, &a->Offset, ""))
		return soap->error;
	if (a->Projection)
	{	int i;
		for (i = 0; i < (int)a->__sizeProjection; i++)
			if (soap_out_tt__LensProjection(soap, "tt:Projection", -1, a->Projection + i, ""))
				return soap->error;
	}
	if (soap_out_float(soap, "tt:XFactor", -1, &a->XFactor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LensDescription * SOAP_FMAC4 soap_in_tt__LensDescription(struct soap *soap, const char *tag, struct tt__LensDescription *a, const char *type)
{
	size_t soap_flag_Offset = 1;
	struct soap_blist *soap_blist_Projection = NULL;
	size_t soap_flag_XFactor = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LensDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LensDescription(soap, a);
	{	const char *t = soap_attr_value(soap, "FocalLength", 0);
		if (t)
		{
			if (!(a->FocalLength = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->FocalLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LensOffset(soap, "tt:Offset", &a->Offset, "tt:LensOffset"))
				{	soap_flag_Offset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Projection", 1, NULL))
			{	if (a->Projection == NULL)
				{	if (soap_blist_Projection == NULL)
						soap_blist_Projection = soap_alloc_block(soap);
					a->Projection = (struct tt__LensProjection *)soap_push_block_max(soap, soap_blist_Projection, sizeof(struct tt__LensProjection));
					if (a->Projection == NULL)
						return NULL;
					soap_default_tt__LensProjection(soap, a->Projection);
				}
				soap_revert(soap);
				if (soap_in_tt__LensProjection(soap, "tt:Projection", a->Projection, "tt:LensProjection"))
				{	a->__sizeProjection++;
					a->Projection = NULL;
					continue;
				}
			}
			if (soap_flag_XFactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:XFactor", &a->XFactor, "xsd:float"))
				{	soap_flag_XFactor--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Projection)
			soap_pop_block(soap, soap_blist_Projection);
		if (a->__sizeProjection)
		{	a->Projection = (struct tt__LensProjection *)soap_save_block(soap, soap_blist_Projection, NULL, 1);
		}
		else
		{	a->Projection = NULL;
			if (soap_blist_Projection)
				soap_end_block(soap, soap_blist_Projection);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Offset > 0 || a->__sizeProjection < 1 || soap_flag_XFactor > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__LensDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_tt__LensDescription, sizeof(struct tt__LensDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LensDescription * SOAP_FMAC4 soap_new_tt__LensDescription(struct soap *soap, int n)
{
	struct tt__LensDescription *p;
	struct tt__LensDescription *a = (struct tt__LensDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LensDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__LensDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LensDescription(struct soap *soap, const struct tt__LensDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LensDescription * SOAP_FMAC4 soap_get_tt__LensDescription(struct soap *soap, struct tt__LensDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeLensDescription = 0;
	a->LensDescription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationExtension2(struct soap *soap, const struct tt__VideoSourceConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->LensDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeLensDescription; i++)
		{
			soap_embedded(soap, a->LensDescription + i, SOAP_TYPE_tt__LensDescription);
			soap_serialize_tt__LensDescription(soap, a->LensDescription + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2), type))
		return soap->error;
	if (a->LensDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeLensDescription; i++)
			if (soap_out_tt__LensDescription(soap, "tt:LensDescription", -1, a->LensDescription + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist_LensDescription = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:LensDescription", 1, NULL))
			{	if (a->LensDescription == NULL)
				{	if (soap_blist_LensDescription == NULL)
						soap_blist_LensDescription = soap_alloc_block(soap);
					a->LensDescription = (struct tt__LensDescription *)soap_push_block_max(soap, soap_blist_LensDescription, sizeof(struct tt__LensDescription));
					if (a->LensDescription == NULL)
						return NULL;
					soap_default_tt__LensDescription(soap, a->LensDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__LensDescription(soap, "tt:LensDescription", a->LensDescription, "tt:LensDescription"))
				{	a->__sizeLensDescription++;
					a->LensDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->LensDescription)
			soap_pop_block(soap, soap_blist_LensDescription);
		if (a->__sizeLensDescription)
		{	a->LensDescription = (struct tt__LensDescription *)soap_save_block(soap, soap_blist_LensDescription, NULL, 1);
		}
		else
		{	a->LensDescription = NULL;
			if (soap_blist_LensDescription)
				soap_end_block(soap, soap_blist_LensDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_new_tt__VideoSourceConfigurationExtension2(struct soap *soap, int n)
{
	struct tt__VideoSourceConfigurationExtension2 *p;
	struct tt__VideoSourceConfigurationExtension2 *a = (struct tt__VideoSourceConfigurationExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfigurationExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfigurationExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationExtension2(struct soap *soap, const struct tt__VideoSourceConfigurationExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rotate(struct soap *soap, struct tt__Rotate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RotateMode(soap, &a->Mode);
	a->Degree = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rotate(struct soap *soap, const struct tt__Rotate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__RotateMode);
	soap_serialize_PointerToint(soap, &a->Degree);
	soap_serialize_PointerTott__RotateExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rotate(struct soap *soap, const char *tag, int id, const struct tt__Rotate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rotate), type))
		return soap->error;
	if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Degree", -1, &a->Degree, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rotate * SOAP_FMAC4 soap_in_tt__Rotate(struct soap *soap, const char *tag, struct tt__Rotate *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Degree = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Rotate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Rotate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RotateMode(soap, "tt:Mode", &a->Mode, "tt:RotateMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Degree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:Degree", &a->Degree, "xsd:int"))
				{	soap_flag_Degree--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RotateExtension(soap, "tt:Extension", &a->Extension, "tt:RotateExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rotate, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Rotate * SOAP_FMAC4 soap_new_tt__Rotate(struct soap *soap, int n)
{
	struct tt__Rotate *p;
	struct tt__Rotate *a = (struct tt__Rotate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Rotate));
	for (p = a; p && n--; p++)
		soap_default_tt__Rotate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rotate(struct soap *soap, const struct tt__Rotate *a, const char *tag, const char *type)
{
	if (soap_out_tt__Rotate(soap, tag ? tag : "tt:Rotate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rotate * SOAP_FMAC4 soap_get_tt__Rotate(struct soap *soap, struct tt__Rotate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Rotate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationExtension(struct soap *soap, const struct tt__VideoSourceConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Rotate(soap, &a->Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension), type))
		return soap->error;
	if (soap_out_PointerTott__Rotate(soap, "tt:Rotate", -1, &a->Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension *a, const char *type)
{
	size_t soap_flag_Rotate = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rotate(soap, "tt:Rotate", &a->Rotate, "tt:Rotate"))
				{	soap_flag_Rotate--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_new_tt__VideoSourceConfigurationExtension(struct soap *soap, int n)
{
	struct tt__VideoSourceConfigurationExtension *p;
	struct tt__VideoSourceConfigurationExtension *a = (struct tt__VideoSourceConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationExtension(struct soap *soap, const struct tt__VideoSourceConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigurationEntity(struct soap *soap, const struct tt__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const struct tt__ConfigurationEntity *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, struct tt__ConfigurationEntity *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ConfigurationEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigurationEntity(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_new_tt__ConfigurationEntity(struct soap *soap, int n)
{
	struct tt__ConfigurationEntity *p;
	struct tt__ConfigurationEntity *a = (struct tt__ConfigurationEntity*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ConfigurationEntity));
	for (p = a; p && n--; p++)
		soap_default_tt__ConfigurationEntity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigurationEntity(struct soap *soap, const struct tt__ConfigurationEntity *a, const char *tag, const char *type)
{
	if (soap_out_tt__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileExtension2(struct soap *soap, const struct tt__ProfileExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension2(struct soap *soap, const char *tag, int id, const struct tt__ProfileExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_in_tt__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension2, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_new_tt__ProfileExtension2(struct soap *soap, int n)
{
	struct tt__ProfileExtension2 *p;
	struct tt__ProfileExtension2 *a = (struct tt__ProfileExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileExtension2(struct soap *soap, const struct tt__ProfileExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileExtension2(soap, tag ? tag : "tt:ProfileExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_get_tt__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfiguration(struct soap *soap, const struct tt__AudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDecoderConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_new_tt__AudioDecoderConfiguration(struct soap *soap, int n)
{
	struct tt__AudioDecoderConfiguration *p;
	struct tt__AudioDecoderConfiguration *a = (struct tt__AudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfiguration(struct soap *soap, const struct tt__AudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
	soap_default_xsd__anyURI(soap, &a->SendPrimacy);
	soap_default_int(soap, &a->OutputLevel);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OutputToken);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SendPrimacy);
	soap_embedded(soap, &a->OutputLevel, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->OutputToken)
	{	if (soap_element_nil(soap, "tt:OutputToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, (char*const*)&a->OutputToken, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:SendPrimacy", -1, (char*const*)&a->SendPrimacy, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->OutputLevel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	size_t soap_flag_SendPrimacy = 1;
	size_t soap_flag_OutputLevel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutputConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", (char**)&a->OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken--;
					continue;
				}
			if (soap_flag_SendPrimacy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:SendPrimacy", (char**)&a->SendPrimacy, "xsd:anyURI"))
				{	soap_flag_SendPrimacy--;
					continue;
				}
			if (soap_flag_OutputLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:OutputLevel", &a->OutputLevel, "xsd:int"))
				{	soap_flag_OutputLevel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_OutputToken > 0 || soap_flag_OutputLevel > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_new_tt__AudioOutputConfiguration(struct soap *soap, int n)
{
	struct tt__AudioOutputConfiguration *p;
	struct tt__AudioOutputConfiguration *a = (struct tt__AudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioOutputConfiguration = NULL;
	a->AudioDecoderConfiguration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileExtension(struct soap *soap, const struct tt__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->AudioOutputConfiguration);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->AudioDecoderConfiguration);
	soap_serialize_PointerTott__ProfileExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const struct tt__ProfileExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), type))
		return soap->error;
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", -1, &a->AudioOutputConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", -1, &a->AudioDecoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension *a, const char *type)
{
	size_t soap_flag_AudioOutputConfiguration = 1;
	size_t soap_flag_AudioDecoderConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", &a->AudioOutputConfiguration, "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutputConfiguration--;
					continue;
				}
			if (soap_flag_AudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", &a->AudioDecoderConfiguration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_AudioDecoderConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension2(soap, "tt:Extension", &a->Extension, "tt:ProfileExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_new_tt__ProfileExtension(struct soap *soap, int n)
{
	struct tt__ProfileExtension *p;
	struct tt__ProfileExtension *a = (struct tt__ProfileExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileExtension(struct soap *soap, const struct tt__ProfileExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileExtension(soap, tag ? tag : "tt:ProfileExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->PTZStatus = NULL;
	a->Events = NULL;
	a->Analytics = NULL;
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
	a->AnalyticsEngineConfiguration = NULL;
	a->Extension = NULL;
	soap_default_string(soap, &a->CompressionType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfiguration(struct soap *soap, const struct tt__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__PTZFilter(soap, &a->PTZStatus);
	soap_serialize_PointerTott__EventSubscription(soap, &a->Events);
	soap_serialize_PointerToxsd__boolean(soap, &a->Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__MetadataConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->CompressionType)
		soap_set_attr(soap, "CompressionType", soap_string2s(soap, a->CompressionType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (!a->Multicast)
	{	if (soap_element_nil(soap, "tt:Multicast"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "CompressionType", 0), &a->CompressionType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZFilter"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &a->Events, "tt:EventSubscription"))
				{	soap_flag_Events--;
					continue;
				}
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:Analytics", &a->Analytics, "xsd:boolean"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_new_tt__MetadataConfiguration(struct soap *soap, int n)
{
	struct tt__MetadataConfiguration *p;
	struct tt__MetadataConfiguration *a = (struct tt__MetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfiguration(struct soap *soap, const struct tt__MetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->NodeToken);
	soap_default_xsd__anyURI(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_default_xsd__anyURI(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_default_xsd__anyURI(soap, &a->DefaultContinuousZoomVelocitySpace);
	a->DefaultPTZSpeed = NULL;
	a->DefaultPTZTimeout = NULL;
	a->PanTiltLimits = NULL;
	a->ZoomLimits = NULL;
	a->Extension = NULL;
	a->MoveRamp = NULL;
	a->PresetRamp = NULL;
	a->PresetTourRamp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfiguration(struct soap *soap, const struct tt__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->NodeToken);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->DefaultAbsoluteZoomPositionSpace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->DefaultRelativePanTiltTranslationSpace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->DefaultRelativeZoomTranslationSpace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &a->DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &a->PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &a->ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PTZConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->MoveRamp)
		soap_set_attr(soap, "MoveRamp", soap_int2s(soap, *a->MoveRamp), 1);
	if (a->PresetRamp)
		soap_set_attr(soap, "PresetRamp", soap_int2s(soap, *a->PresetRamp), 1);
	if (a->PresetTourRamp)
		soap_set_attr(soap, "PresetTourRamp", soap_int2s(soap, *a->PresetTourRamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->NodeToken)
	{	if (soap_element_nil(soap, "tt:NodeToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, (char*const*)&a->NodeToken, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, (char*const*)&a->DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, (char*const*)&a->DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, (char*const*)&a->DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, (char*const*)&a->DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, (char*const*)&a->DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, (char*const*)&a->DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", -1, &a->DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_NodeToken = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace = 1;
	size_t soap_flag_DefaultPTZSpeed = 1;
	size_t soap_flag_DefaultPTZTimeout = 1;
	size_t soap_flag_PanTiltLimits = 1;
	size_t soap_flag_ZoomLimits = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "MoveRamp", 0);
		if (t)
		{
			if (!(a->MoveRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MoveRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "PresetRamp", 0);
		if (t)
		{
			if (!(a->PresetRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->PresetRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "PresetTourRamp", 0);
		if (t)
		{
			if (!(a->PresetTourRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->PresetTourRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", (char**)&a->NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken--;
					continue;
				}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", (char**)&a->DefaultAbsolutePantTiltPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace--;
					continue;
				}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", (char**)&a->DefaultAbsoluteZoomPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace--;
					continue;
				}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", (char**)&a->DefaultRelativePanTiltTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace--;
					continue;
				}
			if (soap_flag_DefaultRelativeZoomTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", (char**)&a->DefaultRelativeZoomTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace--;
					continue;
				}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", (char**)&a->DefaultContinuousPanTiltVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace--;
					continue;
				}
			if (soap_flag_DefaultContinuousZoomVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", (char**)&a->DefaultContinuousZoomVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace--;
					continue;
				}
			if (soap_flag_DefaultPTZSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->DefaultPTZSpeed, "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed--;
					continue;
				}
			if (soap_flag_DefaultPTZTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", &a->DefaultPTZTimeout, "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout--;
					continue;
				}
			if (soap_flag_PanTiltLimits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->PanTiltLimits, "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits--;
					continue;
				}
			if (soap_flag_ZoomLimits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->ZoomLimits, "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_NodeToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_new_tt__PTZConfiguration(struct soap *soap, int n)
{
	struct tt__PTZConfiguration *p;
	struct tt__PTZConfiguration *a = (struct tt__PTZConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfiguration(struct soap *soap, const struct tt__PTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
	a->RuleEngineConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsConfiguration(struct soap *soap, const struct tt__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__RuleEngineConfiguration(soap, &a->RuleEngineConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->AnalyticsEngineConfiguration)
	{	if (soap_element_nil(soap, "tt:AnalyticsEngineConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (!a->RuleEngineConfiguration)
	{	if (soap_element_nil(soap, "tt:RuleEngineConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->RuleEngineConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	size_t soap_flag_RuleEngineConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			if (soap_flag_RuleEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &a->RuleEngineConfiguration, "tt:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_AnalyticsEngineConfiguration > 0 || soap_flag_RuleEngineConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_new_tt__VideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct tt__VideoAnalyticsConfiguration *p;
	struct tt__VideoAnalyticsConfiguration *a = (struct tt__VideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsConfiguration(struct soap *soap, const struct tt__VideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfiguration(struct soap *soap, const struct tt__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->SampleRate, ""))
		return soap->error;
	if (!a->Multicast)
	{	if (soap_element_nil(soap, "tt:Multicast"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoderConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SampleRate", &a->SampleRate, "xsd:int"))
				{	soap_flag_SampleRate--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_new_tt__AudioEncoderConfiguration(struct soap *soap, int n)
{
	struct tt__AudioEncoderConfiguration *p;
	struct tt__AudioEncoderConfiguration *a = (struct tt__AudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfiguration(struct soap *soap, const struct tt__AudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__VideoEncoding(soap, &a->Encoding);
	a->Resolution = NULL;
	soap_default_float(soap, &a->Quality);
	a->RateControl = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Multicast = NULL;
	soap_default_xsd__duration(soap, &a->SessionTimeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &a->RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &a->H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (!a->Resolution)
	{	if (soap_element_nil(soap, "tt:Resolution"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (!a->Multicast)
	{	if (soap_element_nil(soap, "tt:Multicast"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Quality = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl"))
				{	soap_flag_RateControl--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->H264, "tt:H264Configuration"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Resolution > 0 || soap_flag_Quality > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_new_tt__VideoEncoderConfiguration(struct soap *soap, int n)
{
	struct tt__VideoEncoderConfiguration *p;
	struct tt__VideoEncoderConfiguration *a = (struct tt__VideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->SourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceToken)
	{	if (soap_element_nil(soap, "tt:SourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, (char*const*)&a->SourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", (char**)&a->SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_new_tt__AudioSourceConfiguration(struct soap *soap, int n)
{
	struct tt__AudioSourceConfiguration *p;
	struct tt__AudioSourceConfiguration *a = (struct tt__AudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->Bounds = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &a->Bounds);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceToken)
	{	if (soap_element_nil(soap, "tt:SourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, (char*const*)&a->SourceToken, ""))
		return soap->error;
	if (!a->Bounds)
	{	if (soap_element_nil(soap, "tt:Bounds"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->Bounds, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_Bounds = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", (char**)&a->SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_Bounds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->Bounds, "tt:IntRectangle"))
				{	soap_flag_Bounds--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0 || soap_flag_Bounds > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_new_tt__VideoSourceConfiguration(struct soap *soap, int n)
{
	struct tt__VideoSourceConfiguration *p;
	struct tt__VideoSourceConfiguration *a = (struct tt__VideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Profile(struct soap *soap, struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->VideoSourceConfiguration = NULL;
	a->AudioSourceConfiguration = NULL;
	a->VideoEncoderConfiguration = NULL;
	a->AudioEncoderConfiguration = NULL;
	a->VideoAnalyticsConfiguration = NULL;
	a->PTZConfiguration = NULL;
	a->MetadataConfiguration = NULL;
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->fixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Profile(struct soap *soap, const struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &a->MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const struct tt__Profile *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__boolean2s(soap, *a->fixed), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &a->VideoSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &a->AudioSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &a->VideoEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &a->MetadataConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, struct tt__Profile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_VideoSourceConfiguration = 1;
	size_t soap_flag_AudioSourceConfiguration = 1;
	size_t soap_flag_VideoEncoderConfiguration = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_MetadataConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Profile(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			if (!(a->fixed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &a->VideoSourceConfiguration, "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration--;
					continue;
				}
			if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &a->AudioSourceConfiguration, "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration--;
					continue;
				}
			if (soap_flag_VideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &a->VideoEncoderConfiguration, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration--;
					continue;
				}
			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration--;
					continue;
				}
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			if (soap_flag_MetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &a->MetadataConfiguration, "tt:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &a->Extension, "tt:ProfileExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_new_tt__Profile(struct soap *soap, int n)
{
	struct tt__Profile *p;
	struct tt__Profile *a = (struct tt__Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Profile(struct soap *soap, const struct tt__Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Profile(soap, tag ? tag : "tt:Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, struct tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceExtension2(struct soap *soap, const struct tt__VideoSourceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension2, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 * SOAP_FMAC4 soap_new_tt__VideoSourceExtension2(struct soap *soap, int n)
{
	struct tt__VideoSourceExtension2 *p;
	struct tt__VideoSourceExtension2 *a = (struct tt__VideoSourceExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceExtension2(struct soap *soap, const struct tt__VideoSourceExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceExtension2(soap, tag ? tag : "tt:VideoSourceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettings20(struct soap *soap, const struct tt__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &a->Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettings20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingSettings20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettings20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->Brightness, "xsd:float"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->Contrast, "xsd:float"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &a->Exposure, "tt:Exposure20"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &a->Focus, "tt:FocusConfiguration20"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter--;
					continue;
				}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->Sharpness, "xsd:float"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalance20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension20"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_new_tt__ImagingSettings20(struct soap *soap, int n)
{
	struct tt__ImagingSettings20 *p;
	struct tt__ImagingSettings20 *a = (struct tt__ImagingSettings20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingSettings20));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingSettings20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettings20(struct soap *soap, const struct tt__ImagingSettings20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Imaging = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceExtension(struct soap *soap, const struct tt__VideoSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->Imaging);
	soap_serialize_PointerTott__VideoSourceExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension), type))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings20(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceExtension * SOAP_FMAC4 soap_in_tt__VideoSourceExtension(struct soap *soap, const char *tag, struct tt__VideoSourceExtension *a, const char *type)
{
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "tt:Imaging", &a->Imaging, "tt:ImagingSettings20"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoSourceExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoSourceExtension * SOAP_FMAC4 soap_new_tt__VideoSourceExtension(struct soap *soap, int n)
{
	struct tt__VideoSourceExtension *p;
	struct tt__VideoSourceExtension *a = (struct tt__VideoSourceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoSourceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoSourceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceExtension(struct soap *soap, const struct tt__VideoSourceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension * SOAP_FMAC4 soap_get_tt__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnyHolder(struct soap *soap, struct tt__AnyHolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnyHolder(struct soap *soap, const struct tt__AnyHolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnyHolder(struct soap *soap, const char *tag, int id, const struct tt__AnyHolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnyHolder), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnyHolder * SOAP_FMAC4 soap_in_tt__AnyHolder(struct soap *soap, const char *tag, struct tt__AnyHolder *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnyHolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnyHolder, sizeof(struct tt__AnyHolder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnyHolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnyHolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnyHolder, SOAP_TYPE_tt__AnyHolder, sizeof(struct tt__AnyHolder), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnyHolder * SOAP_FMAC4 soap_new_tt__AnyHolder(struct soap *soap, int n)
{
	struct tt__AnyHolder *p;
	struct tt__AnyHolder *a = (struct tt__AnyHolder*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnyHolder));
	for (p = a; p && n--; p++)
		soap_default_tt__AnyHolder(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnyHolder(struct soap *soap, const struct tt__AnyHolder *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnyHolder(soap, tag ? tag : "tt:AnyHolder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnyHolder * SOAP_FMAC4 soap_get_tt__AnyHolder(struct soap *soap, struct tt__AnyHolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnyHolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatList(struct soap *soap, struct tt__FloatList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatList(struct soap *soap, const struct tt__FloatList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_float);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap *soap, const char *tag, int id, const struct tt__FloatList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_float(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatList * SOAP_FMAC4 soap_in_tt__FloatList(struct soap *soap, const char *tag, struct tt__FloatList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FloatList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FloatList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (float *)soap_push_block_max(soap, soap_blist_Items, sizeof(float));
					if (a->Items == NULL)
						return NULL;
					soap_default_float(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_float(soap, "tt:Items", a->Items, "xsd:float"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (float *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FloatList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatList, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FloatList * SOAP_FMAC4 soap_new_tt__FloatList(struct soap *soap, int n)
{
	struct tt__FloatList *p;
	struct tt__FloatList *a = (struct tt__FloatList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FloatList));
	for (p = a; p && n--; p++)
		soap_default_tt__FloatList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatList(struct soap *soap, const struct tt__FloatList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatList(soap, tag ? tag : "tt:FloatList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatList * SOAP_FMAC4 soap_get_tt__FloatList(struct soap *soap, struct tt__FloatList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntList(struct soap *soap, struct tt__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap *soap, const struct tt__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_int);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const struct tt__IntList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < (int)a->__sizeItems; i++)
			if (soap_out_int(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, struct tt__IntList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_alloc_block(soap);
					a->Items = (int *)soap_push_block_max(soap, soap_blist_Items, sizeof(int));
					if (a->Items == NULL)
						return NULL;
					soap_default_int(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Items", a->Items, "xsd:int"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
		{	a->Items = (int *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		}
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_new_tt__IntList(struct soap *soap, int n)
{
	struct tt__IntList *p;
	struct tt__IntList *a = (struct tt__IntList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntList));
	for (p = a; p && n--; p++)
		soap_default_tt__IntList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap *soap, const struct tt__IntList *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, struct tt__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DurationRange(struct soap *soap, struct tt__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Min);
	soap_default_xsd__duration(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DurationRange(struct soap *soap, const struct tt__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Min, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->Max, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const struct tt__DurationRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, struct tt__DurationRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DurationRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DurationRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Min", &a->Min, "xsd:duration"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Max", &a->Max, "xsd:duration"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_new_tt__DurationRange(struct soap *soap, int n)
{
	struct tt__DurationRange *p;
	struct tt__DurationRange *a = (struct tt__DurationRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DurationRange));
	for (p = a; p && n--; p++)
		soap_default_tt__DurationRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DurationRange(struct soap *soap, const struct tt__DurationRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, struct tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatRange(struct soap *soap, struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Min);
	soap_default_float(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Min, SOAP_TYPE_float);
	soap_embedded(soap, &a->Max, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const struct tt__FloatRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FloatRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FloatRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Min", &a->Min, "xsd:float"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Max", &a->Max, "xsd:float"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_new_tt__FloatRange(struct soap *soap, int n)
{
	struct tt__FloatRange *p;
	struct tt__FloatRange *a = (struct tt__FloatRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FloatRange));
	for (p = a; p && n--; p++)
		soap_default_tt__FloatRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, struct tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRange(struct soap *soap, struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Min);
	soap_default_int(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRange(struct soap *soap, const struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Min, SOAP_TYPE_int);
	soap_embedded(soap, &a->Max, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const struct tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, struct tt__IntRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Min", &a->Min, "xsd:int"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Max", &a->Max, "xsd:int"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_new_tt__IntRange(struct soap *soap, int n)
{
	struct tt__IntRange *p;
	struct tt__IntRange *a = (struct tt__IntRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntRange));
	for (p = a; p && n--; p++)
		soap_default_tt__IntRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRange(struct soap *soap, const struct tt__IntRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, struct tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->XRange = NULL;
	a->YRange = NULL;
	a->WidthRange = NULL;
	a->HeightRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangleRange(struct soap *soap, const struct tt__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &a->XRange);
	soap_serialize_PointerTott__IntRange(soap, &a->YRange);
	soap_serialize_PointerTott__IntRange(soap, &a->WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->HeightRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const struct tt__IntRectangleRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_nil(soap, "tt:XRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	if (!a->YRange)
	{	if (soap_element_nil(soap, "tt:YRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->YRange, ""))
		return soap->error;
	if (!a->WidthRange)
	{	if (soap_element_nil(soap, "tt:WidthRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->WidthRange, ""))
		return soap->error;
	if (!a->HeightRange)
	{	if (soap_element_nil(soap, "tt:HeightRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->HeightRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, struct tt__IntRectangleRange *a, const char *type)
{
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	size_t soap_flag_WidthRange = 1;
	size_t soap_flag_HeightRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRectangleRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRectangleRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &a->XRange, "tt:IntRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &a->YRange, "tt:IntRange"))
				{	soap_flag_YRange--;
					continue;
				}
			if (soap_flag_WidthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &a->WidthRange, "tt:IntRange"))
				{	soap_flag_WidthRange--;
					continue;
				}
			if (soap_flag_HeightRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &a->HeightRange, "tt:IntRange"))
				{	soap_flag_HeightRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XRange > 0 || soap_flag_YRange > 0 || soap_flag_WidthRange > 0 || soap_flag_HeightRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_new_tt__IntRectangleRange(struct soap *soap, int n)
{
	struct tt__IntRectangleRange *p;
	struct tt__IntRectangleRange *a = (struct tt__IntRectangleRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntRectangleRange));
	for (p = a; p && n--; p++)
		soap_default_tt__IntRectangleRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangleRange(struct soap *soap, const struct tt__IntRectangleRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->x);
	soap_default_int(soap, &a->y);
	soap_default_int(soap, &a->width);
	soap_default_int(soap, &a->height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const struct tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, a->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, a->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, a->height), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRectangle(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &a->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 1), &a->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 1), &a->height))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_new_tt__IntRectangle(struct soap *soap, int n)
{
	struct tt__IntRectangle *p;
	struct tt__IntRectangle *a = (struct tt__IntRectangle*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IntRectangle));
	for (p = a; p && n--; p++)
		soap_default_tt__IntRectangle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceEntity(struct soap *soap, struct tt__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceEntity(struct soap *soap, const struct tt__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const struct tt__DeviceEntity *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, struct tt__DeviceEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceEntity(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_new_tt__DeviceEntity(struct soap *soap, int n)
{
	struct tt__DeviceEntity *p;
	struct tt__DeviceEntity *a = (struct tt__DeviceEntity*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DeviceEntity));
	for (p = a; p && n--; p++)
		soap_default_tt__DeviceEntity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceEntity(struct soap *soap, const struct tt__DeviceEntity *a, const char *tag, const char *type)
{
	if (soap_out_tt__DeviceEntity(soap, tag ? tag : "tt:DeviceEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, struct tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__DeleteActionTriggersResponse(struct soap *soap, struct _ns4__DeleteActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__DeleteActionTriggersResponse(struct soap *soap, const struct _ns4__DeleteActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__DeleteActionTriggersResponse(struct soap *soap, const char *tag, int id, const struct _ns4__DeleteActionTriggersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__DeleteActionTriggersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__DeleteActionTriggersResponse * SOAP_FMAC4 soap_in__ns4__DeleteActionTriggersResponse(struct soap *soap, const char *tag, struct _ns4__DeleteActionTriggersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__DeleteActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DeleteActionTriggersResponse, sizeof(struct _ns4__DeleteActionTriggersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__DeleteActionTriggersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__DeleteActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DeleteActionTriggersResponse, SOAP_TYPE__ns4__DeleteActionTriggersResponse, sizeof(struct _ns4__DeleteActionTriggersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__DeleteActionTriggersResponse * SOAP_FMAC4 soap_new__ns4__DeleteActionTriggersResponse(struct soap *soap, int n)
{
	struct _ns4__DeleteActionTriggersResponse *p;
	struct _ns4__DeleteActionTriggersResponse *a = (struct _ns4__DeleteActionTriggersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__DeleteActionTriggersResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__DeleteActionTriggersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__DeleteActionTriggersResponse(struct soap *soap, const struct _ns4__DeleteActionTriggersResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__DeleteActionTriggersResponse(soap, tag ? tag : "ns4:DeleteActionTriggersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__DeleteActionTriggersResponse * SOAP_FMAC4 soap_get__ns4__DeleteActionTriggersResponse(struct soap *soap, struct _ns4__DeleteActionTriggersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__DeleteActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__DeleteActionTriggers(struct soap *soap, struct _ns4__DeleteActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__DeleteActionTriggers(struct soap *soap, const struct _ns4__DeleteActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__DeleteActionTriggers(struct soap *soap, const char *tag, int id, const struct _ns4__DeleteActionTriggers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__DeleteActionTriggers), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns4:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__DeleteActionTriggers * SOAP_FMAC4 soap_in__ns4__DeleteActionTriggers(struct soap *soap, const char *tag, struct _ns4__DeleteActionTriggers *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__DeleteActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DeleteActionTriggers, sizeof(struct _ns4__DeleteActionTriggers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__DeleteActionTriggers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "ns4:Token", (char**)a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__DeleteActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DeleteActionTriggers, SOAP_TYPE__ns4__DeleteActionTriggers, sizeof(struct _ns4__DeleteActionTriggers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__DeleteActionTriggers * SOAP_FMAC4 soap_new__ns4__DeleteActionTriggers(struct soap *soap, int n)
{
	struct _ns4__DeleteActionTriggers *p;
	struct _ns4__DeleteActionTriggers *a = (struct _ns4__DeleteActionTriggers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__DeleteActionTriggers));
	for (p = a; p && n--; p++)
		soap_default__ns4__DeleteActionTriggers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__DeleteActionTriggers(struct soap *soap, const struct _ns4__DeleteActionTriggers *a, const char *tag, const char *type)
{
	if (soap_out__ns4__DeleteActionTriggers(soap, tag ? tag : "ns4:DeleteActionTriggers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__DeleteActionTriggers * SOAP_FMAC4 soap_get__ns4__DeleteActionTriggers(struct soap *soap, struct _ns4__DeleteActionTriggers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__DeleteActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__ModifyActionTriggersResponse(struct soap *soap, struct _ns4__ModifyActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__ModifyActionTriggersResponse(struct soap *soap, const struct _ns4__ModifyActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ModifyActionTriggersResponse(struct soap *soap, const char *tag, int id, const struct _ns4__ModifyActionTriggersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ModifyActionTriggersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__ModifyActionTriggersResponse * SOAP_FMAC4 soap_in__ns4__ModifyActionTriggersResponse(struct soap *soap, const char *tag, struct _ns4__ModifyActionTriggersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__ModifyActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ModifyActionTriggersResponse, sizeof(struct _ns4__ModifyActionTriggersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__ModifyActionTriggersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__ModifyActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ModifyActionTriggersResponse, SOAP_TYPE__ns4__ModifyActionTriggersResponse, sizeof(struct _ns4__ModifyActionTriggersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__ModifyActionTriggersResponse * SOAP_FMAC4 soap_new__ns4__ModifyActionTriggersResponse(struct soap *soap, int n)
{
	struct _ns4__ModifyActionTriggersResponse *p;
	struct _ns4__ModifyActionTriggersResponse *a = (struct _ns4__ModifyActionTriggersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__ModifyActionTriggersResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__ModifyActionTriggersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__ModifyActionTriggersResponse(struct soap *soap, const struct _ns4__ModifyActionTriggersResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__ModifyActionTriggersResponse(soap, tag ? tag : "ns4:ModifyActionTriggersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__ModifyActionTriggersResponse * SOAP_FMAC4 soap_get__ns4__ModifyActionTriggersResponse(struct soap *soap, struct _ns4__ModifyActionTriggersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ModifyActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__ModifyActionTriggers(struct soap *soap, struct _ns4__ModifyActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionTrigger = 0;
	a->ActionTrigger = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__ModifyActionTriggers(struct soap *soap, const struct _ns4__ModifyActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
		{
			soap_embedded(soap, a->ActionTrigger + i, SOAP_TYPE_ns4__ActionTrigger);
			soap_serialize_ns4__ActionTrigger(soap, a->ActionTrigger + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ModifyActionTriggers(struct soap *soap, const char *tag, int id, const struct _ns4__ModifyActionTriggers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ModifyActionTriggers), type))
		return soap->error;
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
			if (soap_out_ns4__ActionTrigger(soap, "ns4:ActionTrigger", -1, a->ActionTrigger + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__ModifyActionTriggers * SOAP_FMAC4 soap_in__ns4__ModifyActionTriggers(struct soap *soap, const char *tag, struct _ns4__ModifyActionTriggers *a, const char *type)
{
	struct soap_blist *soap_blist_ActionTrigger = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__ModifyActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ModifyActionTriggers, sizeof(struct _ns4__ModifyActionTriggers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__ModifyActionTriggers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionTrigger", 1, NULL))
			{	if (a->ActionTrigger == NULL)
				{	if (soap_blist_ActionTrigger == NULL)
						soap_blist_ActionTrigger = soap_alloc_block(soap);
					a->ActionTrigger = (struct ns4__ActionTrigger *)soap_push_block_max(soap, soap_blist_ActionTrigger, sizeof(struct ns4__ActionTrigger));
					if (a->ActionTrigger == NULL)
						return NULL;
					soap_default_ns4__ActionTrigger(soap, a->ActionTrigger);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionTrigger(soap, "ns4:ActionTrigger", a->ActionTrigger, "ns4:ActionTrigger"))
				{	a->__sizeActionTrigger++;
					a->ActionTrigger = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionTrigger)
			soap_pop_block(soap, soap_blist_ActionTrigger);
		if (a->__sizeActionTrigger)
		{	a->ActionTrigger = (struct ns4__ActionTrigger *)soap_save_block(soap, soap_blist_ActionTrigger, NULL, 1);
		}
		else
		{	a->ActionTrigger = NULL;
			if (soap_blist_ActionTrigger)
				soap_end_block(soap, soap_blist_ActionTrigger);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeActionTrigger < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__ModifyActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ModifyActionTriggers, SOAP_TYPE__ns4__ModifyActionTriggers, sizeof(struct _ns4__ModifyActionTriggers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__ModifyActionTriggers * SOAP_FMAC4 soap_new__ns4__ModifyActionTriggers(struct soap *soap, int n)
{
	struct _ns4__ModifyActionTriggers *p;
	struct _ns4__ModifyActionTriggers *a = (struct _ns4__ModifyActionTriggers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__ModifyActionTriggers));
	for (p = a; p && n--; p++)
		soap_default__ns4__ModifyActionTriggers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__ModifyActionTriggers(struct soap *soap, const struct _ns4__ModifyActionTriggers *a, const char *tag, const char *type)
{
	if (soap_out__ns4__ModifyActionTriggers(soap, tag ? tag : "ns4:ModifyActionTriggers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__ModifyActionTriggers * SOAP_FMAC4 soap_get__ns4__ModifyActionTriggers(struct soap *soap, struct _ns4__ModifyActionTriggers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ModifyActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__CreateActionTriggersResponse(struct soap *soap, struct _ns4__CreateActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionTrigger = 0;
	a->ActionTrigger = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__CreateActionTriggersResponse(struct soap *soap, const struct _ns4__CreateActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
		{
			soap_embedded(soap, a->ActionTrigger + i, SOAP_TYPE_ns4__ActionTrigger);
			soap_serialize_ns4__ActionTrigger(soap, a->ActionTrigger + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__CreateActionTriggersResponse(struct soap *soap, const char *tag, int id, const struct _ns4__CreateActionTriggersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__CreateActionTriggersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeActionTrigger");
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
			if (soap_out_ns4__ActionTrigger(soap, "ns4:ActionTrigger", -1, a->ActionTrigger + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__CreateActionTriggersResponse * SOAP_FMAC4 soap_in__ns4__CreateActionTriggersResponse(struct soap *soap, const char *tag, struct _ns4__CreateActionTriggersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ActionTrigger = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__CreateActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__CreateActionTriggersResponse, sizeof(struct _ns4__CreateActionTriggersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__CreateActionTriggersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionTrigger", 1, NULL))
			{	if (a->ActionTrigger == NULL)
				{	if (soap_blist_ActionTrigger == NULL)
						soap_blist_ActionTrigger = soap_alloc_block(soap);
					a->ActionTrigger = (struct ns4__ActionTrigger *)soap_push_block_max(soap, soap_blist_ActionTrigger, sizeof(struct ns4__ActionTrigger));
					if (a->ActionTrigger == NULL)
						return NULL;
					soap_default_ns4__ActionTrigger(soap, a->ActionTrigger);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionTrigger(soap, "ns4:ActionTrigger", a->ActionTrigger, "ns4:ActionTrigger"))
				{	a->__sizeActionTrigger++;
					a->ActionTrigger = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeActionTrigger");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionTrigger)
			soap_pop_block(soap, soap_blist_ActionTrigger);
		if (a->__sizeActionTrigger)
		{	a->ActionTrigger = (struct ns4__ActionTrigger *)soap_save_block(soap, soap_blist_ActionTrigger, NULL, 1);
		}
		else
		{	a->ActionTrigger = NULL;
			if (soap_blist_ActionTrigger)
				soap_end_block(soap, soap_blist_ActionTrigger);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__CreateActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__CreateActionTriggersResponse, SOAP_TYPE__ns4__CreateActionTriggersResponse, sizeof(struct _ns4__CreateActionTriggersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__CreateActionTriggersResponse * SOAP_FMAC4 soap_new__ns4__CreateActionTriggersResponse(struct soap *soap, int n)
{
	struct _ns4__CreateActionTriggersResponse *p;
	struct _ns4__CreateActionTriggersResponse *a = (struct _ns4__CreateActionTriggersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__CreateActionTriggersResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__CreateActionTriggersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__CreateActionTriggersResponse(struct soap *soap, const struct _ns4__CreateActionTriggersResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__CreateActionTriggersResponse(soap, tag ? tag : "ns4:CreateActionTriggersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__CreateActionTriggersResponse * SOAP_FMAC4 soap_get__ns4__CreateActionTriggersResponse(struct soap *soap, struct _ns4__CreateActionTriggersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__CreateActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__CreateActionTriggers(struct soap *soap, struct _ns4__CreateActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionTrigger = 0;
	a->ActionTrigger = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__CreateActionTriggers(struct soap *soap, const struct _ns4__CreateActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
		{
			soap_embedded(soap, a->ActionTrigger + i, SOAP_TYPE_ns4__ActionTriggerConfiguration);
			soap_serialize_ns4__ActionTriggerConfiguration(soap, a->ActionTrigger + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__CreateActionTriggers(struct soap *soap, const char *tag, int id, const struct _ns4__CreateActionTriggers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__CreateActionTriggers), type))
		return soap->error;
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
			if (soap_out_ns4__ActionTriggerConfiguration(soap, "ns4:ActionTrigger", -1, a->ActionTrigger + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__CreateActionTriggers * SOAP_FMAC4 soap_in__ns4__CreateActionTriggers(struct soap *soap, const char *tag, struct _ns4__CreateActionTriggers *a, const char *type)
{
	struct soap_blist *soap_blist_ActionTrigger = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__CreateActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__CreateActionTriggers, sizeof(struct _ns4__CreateActionTriggers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__CreateActionTriggers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionTrigger", 1, NULL))
			{	if (a->ActionTrigger == NULL)
				{	if (soap_blist_ActionTrigger == NULL)
						soap_blist_ActionTrigger = soap_alloc_block(soap);
					a->ActionTrigger = (struct ns4__ActionTriggerConfiguration *)soap_push_block_max(soap, soap_blist_ActionTrigger, sizeof(struct ns4__ActionTriggerConfiguration));
					if (a->ActionTrigger == NULL)
						return NULL;
					soap_default_ns4__ActionTriggerConfiguration(soap, a->ActionTrigger);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionTriggerConfiguration(soap, "ns4:ActionTrigger", a->ActionTrigger, "ns4:ActionTriggerConfiguration"))
				{	a->__sizeActionTrigger++;
					a->ActionTrigger = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionTrigger)
			soap_pop_block(soap, soap_blist_ActionTrigger);
		if (a->__sizeActionTrigger)
		{	a->ActionTrigger = (struct ns4__ActionTriggerConfiguration *)soap_save_block(soap, soap_blist_ActionTrigger, NULL, 1);
		}
		else
		{	a->ActionTrigger = NULL;
			if (soap_blist_ActionTrigger)
				soap_end_block(soap, soap_blist_ActionTrigger);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeActionTrigger < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__CreateActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__CreateActionTriggers, SOAP_TYPE__ns4__CreateActionTriggers, sizeof(struct _ns4__CreateActionTriggers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__CreateActionTriggers * SOAP_FMAC4 soap_new__ns4__CreateActionTriggers(struct soap *soap, int n)
{
	struct _ns4__CreateActionTriggers *p;
	struct _ns4__CreateActionTriggers *a = (struct _ns4__CreateActionTriggers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__CreateActionTriggers));
	for (p = a; p && n--; p++)
		soap_default__ns4__CreateActionTriggers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__CreateActionTriggers(struct soap *soap, const struct _ns4__CreateActionTriggers *a, const char *tag, const char *type)
{
	if (soap_out__ns4__CreateActionTriggers(soap, tag ? tag : "ns4:CreateActionTriggers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__CreateActionTriggers * SOAP_FMAC4 soap_get__ns4__CreateActionTriggers(struct soap *soap, struct _ns4__CreateActionTriggers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__CreateActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetActionTriggersResponse(struct soap *soap, struct _ns4__GetActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionTrigger = 0;
	a->ActionTrigger = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetActionTriggersResponse(struct soap *soap, const struct _ns4__GetActionTriggersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
		{
			soap_embedded(soap, a->ActionTrigger + i, SOAP_TYPE_ns4__ActionTrigger);
			soap_serialize_ns4__ActionTrigger(soap, a->ActionTrigger + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetActionTriggersResponse(struct soap *soap, const char *tag, int id, const struct _ns4__GetActionTriggersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetActionTriggersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeActionTrigger");
	if (a->ActionTrigger)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionTrigger; i++)
			if (soap_out_ns4__ActionTrigger(soap, "ns4:ActionTrigger", -1, a->ActionTrigger + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetActionTriggersResponse * SOAP_FMAC4 soap_in__ns4__GetActionTriggersResponse(struct soap *soap, const char *tag, struct _ns4__GetActionTriggersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ActionTrigger = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetActionTriggersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetActionTriggersResponse, sizeof(struct _ns4__GetActionTriggersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetActionTriggersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionTrigger", 1, NULL))
			{	if (a->ActionTrigger == NULL)
				{	if (soap_blist_ActionTrigger == NULL)
						soap_blist_ActionTrigger = soap_alloc_block(soap);
					a->ActionTrigger = (struct ns4__ActionTrigger *)soap_push_block_max(soap, soap_blist_ActionTrigger, sizeof(struct ns4__ActionTrigger));
					if (a->ActionTrigger == NULL)
						return NULL;
					soap_default_ns4__ActionTrigger(soap, a->ActionTrigger);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionTrigger(soap, "ns4:ActionTrigger", a->ActionTrigger, "ns4:ActionTrigger"))
				{	a->__sizeActionTrigger++;
					a->ActionTrigger = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeActionTrigger");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionTrigger)
			soap_pop_block(soap, soap_blist_ActionTrigger);
		if (a->__sizeActionTrigger)
		{	a->ActionTrigger = (struct ns4__ActionTrigger *)soap_save_block(soap, soap_blist_ActionTrigger, NULL, 1);
		}
		else
		{	a->ActionTrigger = NULL;
			if (soap_blist_ActionTrigger)
				soap_end_block(soap, soap_blist_ActionTrigger);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetActionTriggersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetActionTriggersResponse, SOAP_TYPE__ns4__GetActionTriggersResponse, sizeof(struct _ns4__GetActionTriggersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetActionTriggersResponse * SOAP_FMAC4 soap_new__ns4__GetActionTriggersResponse(struct soap *soap, int n)
{
	struct _ns4__GetActionTriggersResponse *p;
	struct _ns4__GetActionTriggersResponse *a = (struct _ns4__GetActionTriggersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetActionTriggersResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetActionTriggersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetActionTriggersResponse(struct soap *soap, const struct _ns4__GetActionTriggersResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetActionTriggersResponse(soap, tag ? tag : "ns4:GetActionTriggersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetActionTriggersResponse * SOAP_FMAC4 soap_get__ns4__GetActionTriggersResponse(struct soap *soap, struct _ns4__GetActionTriggersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetActionTriggers(struct soap *soap, struct _ns4__GetActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetActionTriggers(struct soap *soap, const struct _ns4__GetActionTriggers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetActionTriggers(struct soap *soap, const char *tag, int id, const struct _ns4__GetActionTriggers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetActionTriggers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetActionTriggers * SOAP_FMAC4 soap_in__ns4__GetActionTriggers(struct soap *soap, const char *tag, struct _ns4__GetActionTriggers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetActionTriggers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetActionTriggers, sizeof(struct _ns4__GetActionTriggers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetActionTriggers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetActionTriggers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetActionTriggers, SOAP_TYPE__ns4__GetActionTriggers, sizeof(struct _ns4__GetActionTriggers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetActionTriggers * SOAP_FMAC4 soap_new__ns4__GetActionTriggers(struct soap *soap, int n)
{
	struct _ns4__GetActionTriggers *p;
	struct _ns4__GetActionTriggers *a = (struct _ns4__GetActionTriggers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetActionTriggers));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetActionTriggers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetActionTriggers(struct soap *soap, const struct _ns4__GetActionTriggers *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetActionTriggers(soap, tag ? tag : "ns4:GetActionTriggers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetActionTriggers * SOAP_FMAC4 soap_get__ns4__GetActionTriggers(struct soap *soap, struct _ns4__GetActionTriggers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns4__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns4__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__ActionEngineCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _ns4__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns4:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns4:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__ActionEngineCapabilities(soap, "ns4:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__ns4__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns4__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, sizeof(struct _ns4__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ActionEngineCapabilities(soap, "ns4:Capabilities", &a->Capabilities, "ns4:ActionEngineCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns4:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, SOAP_TYPE__ns4__GetServiceCapabilitiesResponse, sizeof(struct _ns4__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__ns4__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _ns4__GetServiceCapabilitiesResponse *p;
	struct _ns4__GetServiceCapabilitiesResponse *a = (struct _ns4__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns4__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns4:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__ns4__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns4__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetServiceCapabilities(struct soap *soap, struct _ns4__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetServiceCapabilities(struct soap *soap, const struct _ns4__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns4__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns4__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns4__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetServiceCapabilities, sizeof(struct _ns4__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetServiceCapabilities, SOAP_TYPE__ns4__GetServiceCapabilities, sizeof(struct _ns4__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns4__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns4__GetServiceCapabilities *p;
	struct _ns4__GetServiceCapabilities *a = (struct _ns4__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetServiceCapabilities(struct soap *soap, const struct _ns4__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetServiceCapabilities(soap, tag ? tag : "ns4:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns4__GetServiceCapabilities(struct soap *soap, struct _ns4__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__ModifyActionsResponse(struct soap *soap, struct _ns4__ModifyActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__ModifyActionsResponse(struct soap *soap, const struct _ns4__ModifyActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ModifyActionsResponse(struct soap *soap, const char *tag, int id, const struct _ns4__ModifyActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ModifyActionsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__ModifyActionsResponse * SOAP_FMAC4 soap_in__ns4__ModifyActionsResponse(struct soap *soap, const char *tag, struct _ns4__ModifyActionsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__ModifyActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ModifyActionsResponse, sizeof(struct _ns4__ModifyActionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__ModifyActionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__ModifyActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ModifyActionsResponse, SOAP_TYPE__ns4__ModifyActionsResponse, sizeof(struct _ns4__ModifyActionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__ModifyActionsResponse * SOAP_FMAC4 soap_new__ns4__ModifyActionsResponse(struct soap *soap, int n)
{
	struct _ns4__ModifyActionsResponse *p;
	struct _ns4__ModifyActionsResponse *a = (struct _ns4__ModifyActionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__ModifyActionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__ModifyActionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__ModifyActionsResponse(struct soap *soap, const struct _ns4__ModifyActionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__ModifyActionsResponse(soap, tag ? tag : "ns4:ModifyActionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__ModifyActionsResponse * SOAP_FMAC4 soap_get__ns4__ModifyActionsResponse(struct soap *soap, struct _ns4__ModifyActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ModifyActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__ModifyActions(struct soap *soap, struct _ns4__ModifyActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->Action = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__ModifyActions(struct soap *soap, const struct _ns4__ModifyActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->Action + i, SOAP_TYPE_ns4__Action);
			soap_serialize_ns4__Action(soap, a->Action + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ModifyActions(struct soap *soap, const char *tag, int id, const struct _ns4__ModifyActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ModifyActions), type))
		return soap->error;
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_ns4__Action(soap, "ns4:Action", -1, a->Action + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__ModifyActions * SOAP_FMAC4 soap_in__ns4__ModifyActions(struct soap *soap, const char *tag, struct _ns4__ModifyActions *a, const char *type)
{
	struct soap_blist *soap_blist_Action = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__ModifyActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ModifyActions, sizeof(struct _ns4__ModifyActions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__ModifyActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Action", 1, NULL))
			{	if (a->Action == NULL)
				{	if (soap_blist_Action == NULL)
						soap_blist_Action = soap_alloc_block(soap);
					a->Action = (struct ns4__Action *)soap_push_block_max(soap, soap_blist_Action, sizeof(struct ns4__Action));
					if (a->Action == NULL)
						return NULL;
					soap_default_ns4__Action(soap, a->Action);
				}
				soap_revert(soap);
				if (soap_in_ns4__Action(soap, "ns4:Action", a->Action, "ns4:Action"))
				{	a->__sizeAction++;
					a->Action = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Action)
			soap_pop_block(soap, soap_blist_Action);
		if (a->__sizeAction)
		{	a->Action = (struct ns4__Action *)soap_save_block(soap, soap_blist_Action, NULL, 1);
		}
		else
		{	a->Action = NULL;
			if (soap_blist_Action)
				soap_end_block(soap, soap_blist_Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__ModifyActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ModifyActions, SOAP_TYPE__ns4__ModifyActions, sizeof(struct _ns4__ModifyActions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__ModifyActions * SOAP_FMAC4 soap_new__ns4__ModifyActions(struct soap *soap, int n)
{
	struct _ns4__ModifyActions *p;
	struct _ns4__ModifyActions *a = (struct _ns4__ModifyActions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__ModifyActions));
	for (p = a; p && n--; p++)
		soap_default__ns4__ModifyActions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__ModifyActions(struct soap *soap, const struct _ns4__ModifyActions *a, const char *tag, const char *type)
{
	if (soap_out__ns4__ModifyActions(soap, tag ? tag : "ns4:ModifyActions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__ModifyActions * SOAP_FMAC4 soap_get__ns4__ModifyActions(struct soap *soap, struct _ns4__ModifyActions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ModifyActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
