/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__QueryExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, a->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, struct wsnt__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__QueryExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_new_wsnt__QueryExpressionType(struct soap *soap, int n)
{
	struct wsnt__QueryExpressionType *p;
	struct wsnt__QueryExpressionType *a = (struct wsnt__QueryExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__QueryExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__QueryExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__QueryExpressionType(soap, tag ? tag : "wsnt:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", soap_xsd__anyURI2s(soap, a->Dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionType(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionType *p;
	struct wsnt__TopicExpressionType *a = (struct wsnt__TopicExpressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionTriggerConfiguration(struct soap *soap, struct ns4__ActionTriggerConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TopicExpression = NULL;
	a->ContentExpression = NULL;
	a->__sizeActionToken = 0;
	a->ActionToken = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionTriggerConfiguration(struct soap *soap, const struct ns4__ActionTriggerConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->TopicExpression);
	soap_serialize_PointerTowsnt__QueryExpressionType(soap, &a->ContentExpression);
	if (a->ActionToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->ActionToken + i));
		}
	}
	soap_serialize_PointerTons4__ActionTriggerConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionTriggerConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__ActionTriggerConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionTriggerConfiguration), type))
		return soap->error;
	if (!a->TopicExpression)
	{	if (soap_element_nil(soap, "ns4:TopicExpression"))
			return soap->error;
	}
	else
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "ns4:TopicExpression", -1, &a->TopicExpression, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__QueryExpressionType(soap, "ns4:ContentExpression", -1, &a->ContentExpression, ""))
		return soap->error;
	if (a->ActionToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionToken; i++)
			soap_out_string(soap, "ns4:ActionToken", -1, (char*const*)(a->ActionToken + i), "");
	}
	if (soap_out_PointerTons4__ActionTriggerConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionTriggerConfiguration * SOAP_FMAC4 soap_in_ns4__ActionTriggerConfiguration(struct soap *soap, const char *tag, struct ns4__ActionTriggerConfiguration *a, const char *type)
{
	size_t soap_flag_TopicExpression = 1;
	size_t soap_flag_ContentExpression = 1;
	struct soap_blist *soap_blist_ActionToken = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionTriggerConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionTriggerConfiguration, sizeof(struct ns4__ActionTriggerConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionTriggerConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TopicExpression && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__TopicExpressionType(soap, "ns4:TopicExpression", &a->TopicExpression, "wsnt:TopicExpressionType"))
				{	soap_flag_TopicExpression--;
					continue;
				}
			if (soap_flag_ContentExpression && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__QueryExpressionType(soap, "ns4:ContentExpression", &a->ContentExpression, "wsnt:QueryExpressionType"))
				{	soap_flag_ContentExpression--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionToken", 1, NULL))
			{	if (a->ActionToken == NULL)
				{	if (soap_blist_ActionToken == NULL)
						soap_blist_ActionToken = soap_alloc_block(soap);
					a->ActionToken = (char **)soap_push_block_max(soap, soap_blist_ActionToken, sizeof(char *));
					if (a->ActionToken == NULL)
						return NULL;
					*a->ActionToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "ns4:ActionToken", (char**)a->ActionToken, "tt:ReferenceToken"))
				{	a->__sizeActionToken++;
					a->ActionToken = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ActionTriggerConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:ActionTriggerConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionToken)
			soap_pop_block(soap, soap_blist_ActionToken);
		if (a->__sizeActionToken)
		{	a->ActionToken = (char **)soap_save_block(soap, soap_blist_ActionToken, NULL, 1);
		}
		else
		{	a->ActionToken = NULL;
			if (soap_blist_ActionToken)
				soap_end_block(soap, soap_blist_ActionToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TopicExpression > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__ActionTriggerConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionTriggerConfiguration, SOAP_TYPE_ns4__ActionTriggerConfiguration, sizeof(struct ns4__ActionTriggerConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionTriggerConfiguration * SOAP_FMAC4 soap_new_ns4__ActionTriggerConfiguration(struct soap *soap, int n)
{
	struct ns4__ActionTriggerConfiguration *p;
	struct ns4__ActionTriggerConfiguration *a = (struct ns4__ActionTriggerConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionTriggerConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionTriggerConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionTriggerConfiguration(struct soap *soap, const struct ns4__ActionTriggerConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionTriggerConfiguration(soap, tag ? tag : "ns4:ActionTriggerConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionTriggerConfiguration * SOAP_FMAC4 soap_get_ns4__ActionTriggerConfiguration(struct soap *soap, struct ns4__ActionTriggerConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionTriggerConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__Action(struct soap *soap, struct ns4__Action *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__Action(struct soap *soap, const struct ns4__Action *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__ActionConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__Action(struct soap *soap, const char *tag, int id, const struct ns4__Action *a, const char *type)
{
	if (a->Token)
		soap_set_attr(soap, "Token", soap_tt__ReferenceToken2s(soap, a->Token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__Action), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns4:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__ActionConfiguration(soap, "ns4:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__Action * SOAP_FMAC4 soap_in_ns4__Action(struct soap *soap, const char *tag, struct ns4__Action *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__Action *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__Action, sizeof(struct ns4__Action), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__Action(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "Token", 1), &a->Token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ActionConfiguration(soap, "ns4:Configuration", &a->Configuration, "ns4:ActionConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__Action *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__Action, SOAP_TYPE_ns4__Action, sizeof(struct ns4__Action), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__Action * SOAP_FMAC4 soap_new_ns4__Action(struct soap *soap, int n)
{
	struct ns4__Action *p;
	struct ns4__Action *a = (struct ns4__Action*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__Action));
	for (p = a; p && n--; p++)
		soap_default_ns4__Action(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__Action(struct soap *soap, const struct ns4__Action *a, const char *tag, const char *type)
{
	if (soap_out_ns4__Action(soap, tag ? tag : "ns4:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__Action * SOAP_FMAC4 soap_get_ns4__Action(struct soap *soap, struct ns4__Action *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__Action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemList(struct soap *soap, struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItem = 0;
	a->SimpleItem = NULL;
	a->__sizeElementItem = 0;
	a->ElementItem = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemList(struct soap *soap, const struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItem; i++)
		{
			soap_embedded(soap, a->SimpleItem + i, SOAP_TYPE__tt__ItemList_SimpleItem);
			soap_serialize__tt__ItemList_SimpleItem(soap, a->SimpleItem + i);
		}
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItem; i++)
		{
			soap_embedded(soap, a->ElementItem + i, SOAP_TYPE__tt__ItemList_ElementItem);
			soap_serialize__tt__ItemList_ElementItem(soap, a->ElementItem + i);
		}
	}
	soap_serialize_PointerTott__ItemListExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const struct tt__ItemList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItem; i++)
			if (soap_out__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, a->SimpleItem + i, ""))
				return soap->error;
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItem; i++)
			if (soap_out__tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, a->ElementItem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, struct tt__ItemList *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItem = NULL;
	struct soap_blist *soap_blist_ElementItem = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
			{	if (a->SimpleItem == NULL)
				{	if (soap_blist_SimpleItem == NULL)
						soap_blist_SimpleItem = soap_alloc_block(soap);
					a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_push_block_max(soap, soap_blist_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem));
					if (a->SimpleItem == NULL)
						return NULL;
					soap_default__tt__ItemList_SimpleItem(soap, a->SimpleItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", a->SimpleItem, ""))
				{	a->__sizeSimpleItem++;
					a->SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
			{	if (a->ElementItem == NULL)
				{	if (soap_blist_ElementItem == NULL)
						soap_blist_ElementItem = soap_alloc_block(soap);
					a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_push_block_max(soap, soap_blist_ElementItem, sizeof(struct _tt__ItemList_ElementItem));
					if (a->ElementItem == NULL)
						return NULL;
					soap_default__tt__ItemList_ElementItem(soap, a->ElementItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_ElementItem(soap, "tt:ElementItem", a->ElementItem, ""))
				{	a->__sizeElementItem++;
					a->ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem);
		if (a->__sizeSimpleItem)
		{	a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem, NULL, 1);
		}
		else
		{	a->SimpleItem = NULL;
			if (soap_blist_SimpleItem)
				soap_end_block(soap, soap_blist_SimpleItem);
		}
		if (a->ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem);
		if (a->__sizeElementItem)
		{	a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem, NULL, 1);
		}
		else
		{	a->ElementItem = NULL;
			if (soap_blist_ElementItem)
				soap_end_block(soap, soap_blist_ElementItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_new_tt__ItemList(struct soap *soap, int n)
{
	struct tt__ItemList *p;
	struct tt__ItemList *a = (struct tt__ItemList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemList));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemList(struct soap *soap, const struct tt__ItemList *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, struct tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionConfiguration(struct soap *soap, struct ns4__ActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionConfiguration(struct soap *soap, const struct ns4__ActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &a->Parameters);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__ActionConfiguration *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap__QName2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionConfiguration), type))
		return soap->error;
	if (!a->Parameters)
	{	if (soap_element_nil(soap, "ns4:Parameters"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ItemList(soap, "ns4:Parameters", -1, &a->Parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionConfiguration * SOAP_FMAC4 soap_in_ns4__ActionConfiguration(struct soap *soap, const char *tag, struct ns4__ActionConfiguration *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionConfiguration, sizeof(struct ns4__ActionConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "ns4:Parameters", &a->Parameters, "tt:ItemList"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__ActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionConfiguration, SOAP_TYPE_ns4__ActionConfiguration, sizeof(struct ns4__ActionConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionConfiguration * SOAP_FMAC4 soap_new_ns4__ActionConfiguration(struct soap *soap, int n)
{
	struct ns4__ActionConfiguration *p;
	struct ns4__ActionConfiguration *a = (struct ns4__ActionConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionConfiguration(struct soap *soap, const struct ns4__ActionConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionConfiguration(soap, tag ? tag : "ns4:ActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionConfiguration * SOAP_FMAC4 soap_get_ns4__ActionConfiguration(struct soap *soap, struct ns4__ActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, struct ns4__ActionEngineCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, const struct ns4__ActionEngineCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct ns4__ActionEngineCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionEngineCapabilitiesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionEngineCapabilitiesExtension * SOAP_FMAC4 soap_in_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, const char *tag, struct ns4__ActionEngineCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionEngineCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionEngineCapabilitiesExtension, sizeof(struct ns4__ActionEngineCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionEngineCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ActionEngineCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionEngineCapabilitiesExtension, SOAP_TYPE_ns4__ActionEngineCapabilitiesExtension, sizeof(struct ns4__ActionEngineCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionEngineCapabilitiesExtension * SOAP_FMAC4 soap_new_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, int n)
{
	struct ns4__ActionEngineCapabilitiesExtension *p;
	struct ns4__ActionEngineCapabilitiesExtension *a = (struct ns4__ActionEngineCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionEngineCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionEngineCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, const struct ns4__ActionEngineCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionEngineCapabilitiesExtension(soap, tag ? tag : "ns4:ActionEngineCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionEngineCapabilitiesExtension * SOAP_FMAC4 soap_get_ns4__ActionEngineCapabilitiesExtension(struct soap *soap, struct ns4__ActionEngineCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionEngineCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionTypeLimits(struct soap *soap, struct ns4__ActionTypeLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->Type);
	soap_default_xsd__positiveInteger(soap, &a->Maximum);
	a->InUse = (char*)"0";
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionTypeLimits(struct soap *soap, const struct ns4__ActionTypeLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionTypeLimits(struct soap *soap, const char *tag, int id, const struct ns4__ActionTypeLimits *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap__QName2s(soap, a->Type), 1);
	if (a->Maximum)
		soap_set_attr(soap, "Maximum", soap_xsd__positiveInteger2s(soap, a->Maximum), 1);
	if (a->InUse)
		soap_set_attr(soap, "InUse", soap_xsd__nonNegativeInteger2s(soap, a->InUse), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionTypeLimits), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionTypeLimits * SOAP_FMAC4 soap_in_ns4__ActionTypeLimits(struct soap *soap, const char *tag, struct ns4__ActionTypeLimits *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionTypeLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionTypeLimits, sizeof(struct ns4__ActionTypeLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionTypeLimits(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap_s2xsd__positiveInteger(soap, soap_attr_value(soap, "Maximum", 1), &a->Maximum))
		return NULL;
	if (soap_s2xsd__nonNegativeInteger(soap, soap_attr_value(soap, "InUse", 0), &a->InUse))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ActionTypeLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionTypeLimits, SOAP_TYPE_ns4__ActionTypeLimits, sizeof(struct ns4__ActionTypeLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionTypeLimits * SOAP_FMAC4 soap_new_ns4__ActionTypeLimits(struct soap *soap, int n)
{
	struct ns4__ActionTypeLimits *p;
	struct ns4__ActionTypeLimits *a = (struct ns4__ActionTypeLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionTypeLimits));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionTypeLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionTypeLimits(struct soap *soap, const struct ns4__ActionTypeLimits *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionTypeLimits(soap, tag ? tag : "ns4:ActionTypeLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionTypeLimits * SOAP_FMAC4 soap_get_ns4__ActionTypeLimits(struct soap *soap, struct ns4__ActionTypeLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionTypeLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionEngineCapabilities(struct soap *soap, struct ns4__ActionEngineCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionCapabilities = 0;
	a->ActionCapabilities = NULL;
	a->Extension = NULL;
	soap_default_xsd__positiveInteger(soap, &a->MaximumTriggers);
	soap_default_xsd__positiveInteger(soap, &a->MaximumActions);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionEngineCapabilities(struct soap *soap, const struct ns4__ActionEngineCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionCapabilities)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionCapabilities; i++)
		{
			soap_embedded(soap, a->ActionCapabilities + i, SOAP_TYPE_ns4__ActionTypeLimits);
			soap_serialize_ns4__ActionTypeLimits(soap, a->ActionCapabilities + i);
		}
	}
	soap_serialize_PointerTons4__ActionEngineCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionEngineCapabilities(struct soap *soap, const char *tag, int id, const struct ns4__ActionEngineCapabilities *a, const char *type)
{
	if (a->MaximumTriggers)
		soap_set_attr(soap, "MaximumTriggers", soap_xsd__positiveInteger2s(soap, a->MaximumTriggers), 1);
	if (a->MaximumActions)
		soap_set_attr(soap, "MaximumActions", soap_xsd__positiveInteger2s(soap, a->MaximumActions), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionEngineCapabilities), type))
		return soap->error;
	if (a->ActionCapabilities)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionCapabilities; i++)
			if (soap_out_ns4__ActionTypeLimits(soap, "ns4:ActionCapabilities", -1, a->ActionCapabilities + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons4__ActionEngineCapabilitiesExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionEngineCapabilities * SOAP_FMAC4 soap_in_ns4__ActionEngineCapabilities(struct soap *soap, const char *tag, struct ns4__ActionEngineCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_ActionCapabilities = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionEngineCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionEngineCapabilities, sizeof(struct ns4__ActionEngineCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionEngineCapabilities(soap, a);
	if (soap_s2xsd__positiveInteger(soap, soap_attr_value(soap, "MaximumTriggers", 0), &a->MaximumTriggers))
		return NULL;
	if (soap_s2xsd__positiveInteger(soap, soap_attr_value(soap, "MaximumActions", 0), &a->MaximumActions))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionCapabilities", 1, NULL))
			{	if (a->ActionCapabilities == NULL)
				{	if (soap_blist_ActionCapabilities == NULL)
						soap_blist_ActionCapabilities = soap_alloc_block(soap);
					a->ActionCapabilities = (struct ns4__ActionTypeLimits *)soap_push_block_max(soap, soap_blist_ActionCapabilities, sizeof(struct ns4__ActionTypeLimits));
					if (a->ActionCapabilities == NULL)
						return NULL;
					soap_default_ns4__ActionTypeLimits(soap, a->ActionCapabilities);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionTypeLimits(soap, "ns4:ActionCapabilities", a->ActionCapabilities, "ns4:ActionTypeLimits"))
				{	a->__sizeActionCapabilities++;
					a->ActionCapabilities = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ActionEngineCapabilitiesExtension(soap, "ns4:Extension", &a->Extension, "ns4:ActionEngineCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionCapabilities)
			soap_pop_block(soap, soap_blist_ActionCapabilities);
		if (a->__sizeActionCapabilities)
		{	a->ActionCapabilities = (struct ns4__ActionTypeLimits *)soap_save_block(soap, soap_blist_ActionCapabilities, NULL, 1);
		}
		else
		{	a->ActionCapabilities = NULL;
			if (soap_blist_ActionCapabilities)
				soap_end_block(soap, soap_blist_ActionCapabilities);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ActionEngineCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionEngineCapabilities, SOAP_TYPE_ns4__ActionEngineCapabilities, sizeof(struct ns4__ActionEngineCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionEngineCapabilities * SOAP_FMAC4 soap_new_ns4__ActionEngineCapabilities(struct soap *soap, int n)
{
	struct ns4__ActionEngineCapabilities *p;
	struct ns4__ActionEngineCapabilities *a = (struct ns4__ActionEngineCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionEngineCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionEngineCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionEngineCapabilities(struct soap *soap, const struct ns4__ActionEngineCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionEngineCapabilities(soap, tag ? tag : "ns4:ActionEngineCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionEngineCapabilities * SOAP_FMAC4 soap_get_ns4__ActionEngineCapabilities(struct soap *soap, struct ns4__ActionEngineCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionEngineCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SupportedActionsExtension(struct soap *soap, struct ns4__SupportedActionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SupportedActionsExtension(struct soap *soap, const struct ns4__SupportedActionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SupportedActionsExtension(struct soap *soap, const char *tag, int id, const struct ns4__SupportedActionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SupportedActionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SupportedActionsExtension * SOAP_FMAC4 soap_in_ns4__SupportedActionsExtension(struct soap *soap, const char *tag, struct ns4__SupportedActionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SupportedActionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SupportedActionsExtension, sizeof(struct ns4__SupportedActionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SupportedActionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SupportedActionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SupportedActionsExtension, SOAP_TYPE_ns4__SupportedActionsExtension, sizeof(struct ns4__SupportedActionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__SupportedActionsExtension * SOAP_FMAC4 soap_new_ns4__SupportedActionsExtension(struct soap *soap, int n)
{
	struct ns4__SupportedActionsExtension *p;
	struct ns4__SupportedActionsExtension *a = (struct ns4__SupportedActionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__SupportedActionsExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__SupportedActionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SupportedActionsExtension(struct soap *soap, const struct ns4__SupportedActionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SupportedActionsExtension(soap, tag ? tag : "ns4:SupportedActionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SupportedActionsExtension * SOAP_FMAC4 soap_get_ns4__SupportedActionsExtension(struct soap *soap, struct ns4__SupportedActionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SupportedActionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SupportedActions(struct soap *soap, struct ns4__SupportedActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionContentSchemaLocation = 0;
	a->ActionContentSchemaLocation = NULL;
	a->__sizeActionDescription = 0;
	a->ActionDescription = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SupportedActions(struct soap *soap, const struct ns4__SupportedActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ActionContentSchemaLocation + i));
		}
	}
	if (a->ActionDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionDescription; i++)
		{
			soap_embedded(soap, a->ActionDescription + i, SOAP_TYPE_ns4__ActionConfigDescription);
			soap_serialize_ns4__ActionConfigDescription(soap, a->ActionDescription + i);
		}
	}
	soap_serialize_PointerTons4__SupportedActionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SupportedActions(struct soap *soap, const char *tag, int id, const struct ns4__SupportedActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SupportedActions), type))
		return soap->error;
	if (a->ActionContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionContentSchemaLocation; i++)
			soap_out_string(soap, "ns4:ActionContentSchemaLocation", -1, (char*const*)(a->ActionContentSchemaLocation + i), "");
	}
	if (a->ActionDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionDescription; i++)
			if (soap_out_ns4__ActionConfigDescription(soap, "ns4:ActionDescription", -1, a->ActionDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons4__SupportedActionsExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SupportedActions * SOAP_FMAC4 soap_in_ns4__SupportedActions(struct soap *soap, const char *tag, struct ns4__SupportedActions *a, const char *type)
{
	struct soap_blist *soap_blist_ActionContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_ActionDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SupportedActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SupportedActions, sizeof(struct ns4__SupportedActions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SupportedActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionContentSchemaLocation", 1, NULL))
			{	if (a->ActionContentSchemaLocation == NULL)
				{	if (soap_blist_ActionContentSchemaLocation == NULL)
						soap_blist_ActionContentSchemaLocation = soap_alloc_block(soap);
					a->ActionContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_ActionContentSchemaLocation, sizeof(char *));
					if (a->ActionContentSchemaLocation == NULL)
						return NULL;
					*a->ActionContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "ns4:ActionContentSchemaLocation", (char**)a->ActionContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeActionContentSchemaLocation++;
					a->ActionContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionDescription", 1, NULL))
			{	if (a->ActionDescription == NULL)
				{	if (soap_blist_ActionDescription == NULL)
						soap_blist_ActionDescription = soap_alloc_block(soap);
					a->ActionDescription = (struct ns4__ActionConfigDescription *)soap_push_block_max(soap, soap_blist_ActionDescription, sizeof(struct ns4__ActionConfigDescription));
					if (a->ActionDescription == NULL)
						return NULL;
					soap_default_ns4__ActionConfigDescription(soap, a->ActionDescription);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionConfigDescription(soap, "ns4:ActionDescription", a->ActionDescription, "ns4:ActionConfigDescription"))
				{	a->__sizeActionDescription++;
					a->ActionDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SupportedActionsExtension(soap, "ns4:Extension", &a->Extension, "ns4:SupportedActionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionContentSchemaLocation)
			soap_pop_block(soap, soap_blist_ActionContentSchemaLocation);
		if (a->__sizeActionContentSchemaLocation)
		{	a->ActionContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_ActionContentSchemaLocation, NULL, 1);
		}
		else
		{	a->ActionContentSchemaLocation = NULL;
			if (soap_blist_ActionContentSchemaLocation)
				soap_end_block(soap, soap_blist_ActionContentSchemaLocation);
		}
		if (a->ActionDescription)
			soap_pop_block(soap, soap_blist_ActionDescription);
		if (a->__sizeActionDescription)
		{	a->ActionDescription = (struct ns4__ActionConfigDescription *)soap_save_block(soap, soap_blist_ActionDescription, NULL, 1);
		}
		else
		{	a->ActionDescription = NULL;
			if (soap_blist_ActionDescription)
				soap_end_block(soap, soap_blist_ActionDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__SupportedActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SupportedActions, SOAP_TYPE_ns4__SupportedActions, sizeof(struct ns4__SupportedActions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__SupportedActions * SOAP_FMAC4 soap_new_ns4__SupportedActions(struct soap *soap, int n)
{
	struct ns4__SupportedActions *p;
	struct ns4__SupportedActions *a = (struct ns4__SupportedActions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__SupportedActions));
	for (p = a; p && n--; p++)
		soap_default_ns4__SupportedActions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SupportedActions(struct soap *soap, const struct ns4__SupportedActions *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SupportedActions(soap, tag ? tag : "ns4:SupportedActions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SupportedActions * SOAP_FMAC4 soap_get_ns4__SupportedActions(struct soap *soap, struct ns4__SupportedActions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SupportedActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItemDescription = 0;
	a->SimpleItemDescription = NULL;
	a->__sizeElementItemDescription = 0;
	a->ElementItemDescription = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItemDescription; i++)
		{
			soap_embedded(soap, a->SimpleItemDescription + i, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
			soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription + i);
		}
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItemDescription; i++)
		{
			soap_embedded(soap, a->ElementItemDescription + i, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
			soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription + i);
		}
	}
	soap_serialize_PointerTott__ItemListDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescription(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescription), type))
		return soap->error;
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeSimpleItemDescription; i++)
			if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", -1, a->SimpleItemDescription + i, ""))
				return soap->error;
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeElementItemDescription; i++)
			if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", -1, a->ElementItemDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_in_tt__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItemDescription = NULL;
	struct soap_blist *soap_blist_ElementItemDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItemDescription", 1, NULL))
			{	if (a->SimpleItemDescription == NULL)
				{	if (soap_blist_SimpleItemDescription == NULL)
						soap_blist_SimpleItemDescription = soap_alloc_block(soap);
					a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_push_block_max(soap, soap_blist_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
					if (a->SimpleItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", a->SimpleItemDescription, ""))
				{	a->__sizeSimpleItemDescription++;
					a->SimpleItemDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItemDescription", 1, NULL))
			{	if (a->ElementItemDescription == NULL)
				{	if (soap_blist_ElementItemDescription == NULL)
						soap_blist_ElementItemDescription = soap_alloc_block(soap);
					a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_push_block_max(soap, soap_blist_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription));
					if (a->ElementItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", a->ElementItemDescription, ""))
				{	a->__sizeElementItemDescription++;
					a->ElementItemDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItemDescription)
			soap_pop_block(soap, soap_blist_SimpleItemDescription);
		if (a->__sizeSimpleItemDescription)
		{	a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_save_block(soap, soap_blist_SimpleItemDescription, NULL, 1);
		}
		else
		{	a->SimpleItemDescription = NULL;
			if (soap_blist_SimpleItemDescription)
				soap_end_block(soap, soap_blist_SimpleItemDescription);
		}
		if (a->ElementItemDescription)
			soap_pop_block(soap, soap_blist_ElementItemDescription);
		if (a->__sizeElementItemDescription)
		{	a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_save_block(soap, soap_blist_ElementItemDescription, NULL, 1);
		}
		else
		{	a->ElementItemDescription = NULL;
			if (soap_blist_ElementItemDescription)
				soap_end_block(soap, soap_blist_ElementItemDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_new_tt__ItemListDescription(struct soap *soap, int n)
{
	struct tt__ItemListDescription *p;
	struct tt__ItemListDescription *a = (struct tt__ItemListDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListDescription(soap, tag ? tag : "tt:ItemListDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_get_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionConfigDescription(struct soap *soap, struct ns4__ActionConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterDescription = NULL;
	soap_default__QName(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionConfigDescription(struct soap *soap, const struct ns4__ActionConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->ParameterDescription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionConfigDescription(struct soap *soap, const char *tag, int id, const struct ns4__ActionConfigDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap__QName2s(soap, a->Name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionConfigDescription), type))
		return soap->error;
	if (!a->ParameterDescription)
	{	if (soap_element_nil(soap, "ns4:ParameterDescription"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ItemListDescription(soap, "ns4:ParameterDescription", -1, &a->ParameterDescription, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionConfigDescription * SOAP_FMAC4 soap_in_ns4__ActionConfigDescription(struct soap *soap, const char *tag, struct ns4__ActionConfigDescription *a, const char *type)
{
	size_t soap_flag_ParameterDescription = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionConfigDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionConfigDescription, sizeof(struct ns4__ActionConfigDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionConfigDescription(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterDescription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "ns4:ParameterDescription", &a->ParameterDescription, "tt:ItemListDescription"))
				{	soap_flag_ParameterDescription--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ParameterDescription > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__ActionConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionConfigDescription, SOAP_TYPE_ns4__ActionConfigDescription, sizeof(struct ns4__ActionConfigDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionConfigDescription * SOAP_FMAC4 soap_new_ns4__ActionConfigDescription(struct soap *soap, int n)
{
	struct ns4__ActionConfigDescription *p;
	struct ns4__ActionConfigDescription *a = (struct ns4__ActionConfigDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionConfigDescription));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionConfigDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionConfigDescription(struct soap *soap, const struct ns4__ActionConfigDescription *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionConfigDescription(soap, tag ? tag : "ns4:ActionConfigDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionConfigDescription * SOAP_FMAC4 soap_get_ns4__ActionConfigDescription(struct soap *soap, struct ns4__ActionConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__DeleteAccessProfileResponse(struct soap *soap, struct _ns3__DeleteAccessProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__DeleteAccessProfileResponse(struct soap *soap, const struct _ns3__DeleteAccessProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DeleteAccessProfileResponse(struct soap *soap, const char *tag, int id, const struct _ns3__DeleteAccessProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DeleteAccessProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__DeleteAccessProfileResponse * SOAP_FMAC4 soap_in__ns3__DeleteAccessProfileResponse(struct soap *soap, const char *tag, struct _ns3__DeleteAccessProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__DeleteAccessProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DeleteAccessProfileResponse, sizeof(struct _ns3__DeleteAccessProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__DeleteAccessProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__DeleteAccessProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DeleteAccessProfileResponse, SOAP_TYPE__ns3__DeleteAccessProfileResponse, sizeof(struct _ns3__DeleteAccessProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__DeleteAccessProfileResponse * SOAP_FMAC4 soap_new__ns3__DeleteAccessProfileResponse(struct soap *soap, int n)
{
	struct _ns3__DeleteAccessProfileResponse *p;
	struct _ns3__DeleteAccessProfileResponse *a = (struct _ns3__DeleteAccessProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__DeleteAccessProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__DeleteAccessProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__DeleteAccessProfileResponse(struct soap *soap, const struct _ns3__DeleteAccessProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__DeleteAccessProfileResponse(soap, tag ? tag : "ns3:DeleteAccessProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__DeleteAccessProfileResponse * SOAP_FMAC4 soap_get__ns3__DeleteAccessProfileResponse(struct soap *soap, struct _ns3__DeleteAccessProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DeleteAccessProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__DeleteAccessProfile(struct soap *soap, struct _ns3__DeleteAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__DeleteAccessProfile(struct soap *soap, const struct _ns3__DeleteAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__DeleteAccessProfile(struct soap *soap, const char *tag, int id, const struct _ns3__DeleteAccessProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__DeleteAccessProfile), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns3:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns3:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__DeleteAccessProfile * SOAP_FMAC4 soap_in__ns3__DeleteAccessProfile(struct soap *soap, const char *tag, struct _ns3__DeleteAccessProfile *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__DeleteAccessProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__DeleteAccessProfile, sizeof(struct _ns3__DeleteAccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__DeleteAccessProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns3:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__DeleteAccessProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__DeleteAccessProfile, SOAP_TYPE__ns3__DeleteAccessProfile, sizeof(struct _ns3__DeleteAccessProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__DeleteAccessProfile * SOAP_FMAC4 soap_new__ns3__DeleteAccessProfile(struct soap *soap, int n)
{
	struct _ns3__DeleteAccessProfile *p;
	struct _ns3__DeleteAccessProfile *a = (struct _ns3__DeleteAccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__DeleteAccessProfile));
	for (p = a; p && n--; p++)
		soap_default__ns3__DeleteAccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__DeleteAccessProfile(struct soap *soap, const struct _ns3__DeleteAccessProfile *a, const char *tag, const char *type)
{
	if (soap_out__ns3__DeleteAccessProfile(soap, tag ? tag : "ns3:DeleteAccessProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__DeleteAccessProfile * SOAP_FMAC4 soap_get__ns3__DeleteAccessProfile(struct soap *soap, struct _ns3__DeleteAccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__DeleteAccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__ModifyAccessProfileResponse(struct soap *soap, struct _ns3__ModifyAccessProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__ModifyAccessProfileResponse(struct soap *soap, const struct _ns3__ModifyAccessProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ModifyAccessProfileResponse(struct soap *soap, const char *tag, int id, const struct _ns3__ModifyAccessProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ModifyAccessProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__ModifyAccessProfileResponse * SOAP_FMAC4 soap_in__ns3__ModifyAccessProfileResponse(struct soap *soap, const char *tag, struct _ns3__ModifyAccessProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__ModifyAccessProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ModifyAccessProfileResponse, sizeof(struct _ns3__ModifyAccessProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__ModifyAccessProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__ModifyAccessProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ModifyAccessProfileResponse, SOAP_TYPE__ns3__ModifyAccessProfileResponse, sizeof(struct _ns3__ModifyAccessProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__ModifyAccessProfileResponse * SOAP_FMAC4 soap_new__ns3__ModifyAccessProfileResponse(struct soap *soap, int n)
{
	struct _ns3__ModifyAccessProfileResponse *p;
	struct _ns3__ModifyAccessProfileResponse *a = (struct _ns3__ModifyAccessProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__ModifyAccessProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__ModifyAccessProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__ModifyAccessProfileResponse(struct soap *soap, const struct _ns3__ModifyAccessProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__ModifyAccessProfileResponse(soap, tag ? tag : "ns3:ModifyAccessProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__ModifyAccessProfileResponse * SOAP_FMAC4 soap_get__ns3__ModifyAccessProfileResponse(struct soap *soap, struct _ns3__ModifyAccessProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ModifyAccessProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__ModifyAccessProfile(struct soap *soap, struct _ns3__ModifyAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__ModifyAccessProfile(struct soap *soap, const struct _ns3__ModifyAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__AccessProfile(soap, &a->AccessProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__ModifyAccessProfile(struct soap *soap, const char *tag, int id, const struct _ns3__ModifyAccessProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__ModifyAccessProfile), type))
		return soap->error;
	if (!a->AccessProfile)
	{	if (soap_element_nil(soap, "ns3:AccessProfile"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__AccessProfile(soap, "ns3:AccessProfile", -1, &a->AccessProfile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__ModifyAccessProfile * SOAP_FMAC4 soap_in__ns3__ModifyAccessProfile(struct soap *soap, const char *tag, struct _ns3__ModifyAccessProfile *a, const char *type)
{
	size_t soap_flag_AccessProfile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__ModifyAccessProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__ModifyAccessProfile, sizeof(struct _ns3__ModifyAccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__ModifyAccessProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccessProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AccessProfile(soap, "ns3:AccessProfile", &a->AccessProfile, "ns3:AccessProfile"))
				{	soap_flag_AccessProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccessProfile > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__ModifyAccessProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__ModifyAccessProfile, SOAP_TYPE__ns3__ModifyAccessProfile, sizeof(struct _ns3__ModifyAccessProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__ModifyAccessProfile * SOAP_FMAC4 soap_new__ns3__ModifyAccessProfile(struct soap *soap, int n)
{
	struct _ns3__ModifyAccessProfile *p;
	struct _ns3__ModifyAccessProfile *a = (struct _ns3__ModifyAccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__ModifyAccessProfile));
	for (p = a; p && n--; p++)
		soap_default__ns3__ModifyAccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__ModifyAccessProfile(struct soap *soap, const struct _ns3__ModifyAccessProfile *a, const char *tag, const char *type)
{
	if (soap_out__ns3__ModifyAccessProfile(soap, tag ? tag : "ns3:ModifyAccessProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__ModifyAccessProfile * SOAP_FMAC4 soap_get__ns3__ModifyAccessProfile(struct soap *soap, struct _ns3__ModifyAccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__ModifyAccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__CreateAccessProfileResponse(struct soap *soap, struct _ns3__CreateAccessProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__CreateAccessProfileResponse(struct soap *soap, const struct _ns3__CreateAccessProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreateAccessProfileResponse(struct soap *soap, const char *tag, int id, const struct _ns3__CreateAccessProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreateAccessProfileResponse), type))
		return soap->error;
	if (a->Token)
		soap_element_result(soap, "ns3:Token");
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns3:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns3:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__CreateAccessProfileResponse * SOAP_FMAC4 soap_in__ns3__CreateAccessProfileResponse(struct soap *soap, const char *tag, struct _ns3__CreateAccessProfileResponse *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__CreateAccessProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreateAccessProfileResponse, sizeof(struct _ns3__CreateAccessProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__CreateAccessProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns3:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			soap_check_result(soap, "ns3:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__CreateAccessProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreateAccessProfileResponse, SOAP_TYPE__ns3__CreateAccessProfileResponse, sizeof(struct _ns3__CreateAccessProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__CreateAccessProfileResponse * SOAP_FMAC4 soap_new__ns3__CreateAccessProfileResponse(struct soap *soap, int n)
{
	struct _ns3__CreateAccessProfileResponse *p;
	struct _ns3__CreateAccessProfileResponse *a = (struct _ns3__CreateAccessProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__CreateAccessProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__CreateAccessProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__CreateAccessProfileResponse(struct soap *soap, const struct _ns3__CreateAccessProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__CreateAccessProfileResponse(soap, tag ? tag : "ns3:CreateAccessProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__CreateAccessProfileResponse * SOAP_FMAC4 soap_get__ns3__CreateAccessProfileResponse(struct soap *soap, struct _ns3__CreateAccessProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreateAccessProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__CreateAccessProfile(struct soap *soap, struct _ns3__CreateAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__CreateAccessProfile(struct soap *soap, const struct _ns3__CreateAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__AccessProfile(soap, &a->AccessProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__CreateAccessProfile(struct soap *soap, const char *tag, int id, const struct _ns3__CreateAccessProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__CreateAccessProfile), type))
		return soap->error;
	if (!a->AccessProfile)
	{	if (soap_element_nil(soap, "ns3:AccessProfile"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__AccessProfile(soap, "ns3:AccessProfile", -1, &a->AccessProfile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__CreateAccessProfile * SOAP_FMAC4 soap_in__ns3__CreateAccessProfile(struct soap *soap, const char *tag, struct _ns3__CreateAccessProfile *a, const char *type)
{
	size_t soap_flag_AccessProfile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__CreateAccessProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__CreateAccessProfile, sizeof(struct _ns3__CreateAccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__CreateAccessProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccessProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AccessProfile(soap, "ns3:AccessProfile", &a->AccessProfile, "ns3:AccessProfile"))
				{	soap_flag_AccessProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccessProfile > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__CreateAccessProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__CreateAccessProfile, SOAP_TYPE__ns3__CreateAccessProfile, sizeof(struct _ns3__CreateAccessProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__CreateAccessProfile * SOAP_FMAC4 soap_new__ns3__CreateAccessProfile(struct soap *soap, int n)
{
	struct _ns3__CreateAccessProfile *p;
	struct _ns3__CreateAccessProfile *a = (struct _ns3__CreateAccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__CreateAccessProfile));
	for (p = a; p && n--; p++)
		soap_default__ns3__CreateAccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__CreateAccessProfile(struct soap *soap, const struct _ns3__CreateAccessProfile *a, const char *tag, const char *type)
{
	if (soap_out__ns3__CreateAccessProfile(soap, tag ? tag : "ns3:CreateAccessProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__CreateAccessProfile * SOAP_FMAC4 soap_get__ns3__CreateAccessProfile(struct soap *soap, struct _ns3__CreateAccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__CreateAccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfileListResponse(struct soap *soap, struct _ns3__GetAccessProfileListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeAccessProfile = 0;
	a->AccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfileListResponse(struct soap *soap, const struct _ns3__GetAccessProfileListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->AccessProfile)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfile; i++)
		{
			soap_embedded(soap, a->AccessProfile + i, SOAP_TYPE_ns3__AccessProfile);
			soap_serialize_ns3__AccessProfile(soap, a->AccessProfile + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfileListResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfileListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfileListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns3:NextStartReference");
	if (soap_out_string(soap, "ns3:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->AccessProfile)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfile; i++)
			if (soap_out_ns3__AccessProfile(soap, "ns3:AccessProfile", -1, a->AccessProfile + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileListResponse * SOAP_FMAC4 soap_in__ns3__GetAccessProfileListResponse(struct soap *soap, const char *tag, struct _ns3__GetAccessProfileListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_AccessProfile = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfileListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfileListResponse, sizeof(struct _ns3__GetAccessProfileListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfileListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:AccessProfile", 1, NULL))
			{	if (a->AccessProfile == NULL)
				{	if (soap_blist_AccessProfile == NULL)
						soap_blist_AccessProfile = soap_alloc_block(soap);
					a->AccessProfile = (struct ns3__AccessProfile *)soap_push_block_max(soap, soap_blist_AccessProfile, sizeof(struct ns3__AccessProfile));
					if (a->AccessProfile == NULL)
						return NULL;
					soap_default_ns3__AccessProfile(soap, a->AccessProfile);
				}
				soap_revert(soap);
				if (soap_in_ns3__AccessProfile(soap, "ns3:AccessProfile", a->AccessProfile, "ns3:AccessProfile"))
				{	a->__sizeAccessProfile++;
					a->AccessProfile = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns3:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessProfile)
			soap_pop_block(soap, soap_blist_AccessProfile);
		if (a->__sizeAccessProfile)
		{	a->AccessProfile = (struct ns3__AccessProfile *)soap_save_block(soap, soap_blist_AccessProfile, NULL, 1);
		}
		else
		{	a->AccessProfile = NULL;
			if (soap_blist_AccessProfile)
				soap_end_block(soap, soap_blist_AccessProfile);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfileListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfileListResponse, SOAP_TYPE__ns3__GetAccessProfileListResponse, sizeof(struct _ns3__GetAccessProfileListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfileListResponse * SOAP_FMAC4 soap_new__ns3__GetAccessProfileListResponse(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfileListResponse *p;
	struct _ns3__GetAccessProfileListResponse *a = (struct _ns3__GetAccessProfileListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfileListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfileListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfileListResponse(struct soap *soap, const struct _ns3__GetAccessProfileListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfileListResponse(soap, tag ? tag : "ns3:GetAccessProfileListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileListResponse * SOAP_FMAC4 soap_get__ns3__GetAccessProfileListResponse(struct soap *soap, struct _ns3__GetAccessProfileListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfileListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfileList(struct soap *soap, struct _ns3__GetAccessProfileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfileList(struct soap *soap, const struct _ns3__GetAccessProfileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfileList(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfileList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfileList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns3:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileList * SOAP_FMAC4 soap_in__ns3__GetAccessProfileList(struct soap *soap, const char *tag, struct _ns3__GetAccessProfileList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfileList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfileList, sizeof(struct _ns3__GetAccessProfileList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfileList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns3:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfileList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfileList, SOAP_TYPE__ns3__GetAccessProfileList, sizeof(struct _ns3__GetAccessProfileList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfileList * SOAP_FMAC4 soap_new__ns3__GetAccessProfileList(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfileList *p;
	struct _ns3__GetAccessProfileList *a = (struct _ns3__GetAccessProfileList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfileList));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfileList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfileList(struct soap *soap, const struct _ns3__GetAccessProfileList *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfileList(soap, tag ? tag : "ns3:GetAccessProfileList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileList * SOAP_FMAC4 soap_get__ns3__GetAccessProfileList(struct soap *soap, struct _ns3__GetAccessProfileList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfileList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__AccessProfile(struct soap *soap, struct ns3__AccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
	a->__sizeAccessPolicy = 0;
	a->AccessPolicy = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__AccessProfile(struct soap *soap, const struct ns3__AccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
	if (a->AccessPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessPolicy; i++)
		{
			soap_embedded(soap, a->AccessPolicy + i, SOAP_TYPE_ns3__AccessPolicy);
			soap_serialize_ns3__AccessPolicy(soap, a->AccessPolicy + i);
		}
	}
	soap_serialize_PointerTons3__AccessProfileExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AccessProfile(struct soap *soap, const char *tag, int id, const struct ns3__AccessProfile *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AccessProfile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns3:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns3:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns3:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (a->AccessPolicy)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessPolicy; i++)
			if (soap_out_ns3__AccessPolicy(soap, "ns3:AccessPolicy", -1, a->AccessPolicy + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons3__AccessProfileExtension(soap, "ns3:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__AccessProfile * SOAP_FMAC4 soap_in_ns3__AccessProfile(struct soap *soap, const char *tag, struct ns3__AccessProfile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	struct soap_blist *soap_blist_AccessPolicy = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__AccessProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AccessProfile, sizeof(struct ns3__AccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__AccessProfile(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns3:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns3:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:AccessPolicy", 1, NULL))
			{	if (a->AccessPolicy == NULL)
				{	if (soap_blist_AccessPolicy == NULL)
						soap_blist_AccessPolicy = soap_alloc_block(soap);
					a->AccessPolicy = (struct ns3__AccessPolicy *)soap_push_block_max(soap, soap_blist_AccessPolicy, sizeof(struct ns3__AccessPolicy));
					if (a->AccessPolicy == NULL)
						return NULL;
					soap_default_ns3__AccessPolicy(soap, a->AccessPolicy);
				}
				soap_revert(soap);
				if (soap_in_ns3__AccessPolicy(soap, "ns3:AccessPolicy", a->AccessPolicy, "ns3:AccessPolicy"))
				{	a->__sizeAccessPolicy++;
					a->AccessPolicy = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AccessProfileExtension(soap, "ns3:Extension", &a->Extension, "ns3:AccessProfileExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessPolicy)
			soap_pop_block(soap, soap_blist_AccessPolicy);
		if (a->__sizeAccessPolicy)
		{	a->AccessPolicy = (struct ns3__AccessPolicy *)soap_save_block(soap, soap_blist_AccessPolicy, NULL, 1);
		}
		else
		{	a->AccessPolicy = NULL;
			if (soap_blist_AccessPolicy)
				soap_end_block(soap, soap_blist_AccessPolicy);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns3__AccessProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AccessProfile, SOAP_TYPE_ns3__AccessProfile, sizeof(struct ns3__AccessProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__AccessProfile * SOAP_FMAC4 soap_new_ns3__AccessProfile(struct soap *soap, int n)
{
	struct ns3__AccessProfile *p;
	struct ns3__AccessProfile *a = (struct ns3__AccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__AccessProfile));
	for (p = a; p && n--; p++)
		soap_default_ns3__AccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AccessProfile(struct soap *soap, const struct ns3__AccessProfile *a, const char *tag, const char *type)
{
	if (soap_out_ns3__AccessProfile(soap, tag ? tag : "ns3:AccessProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__AccessProfile * SOAP_FMAC4 soap_get_ns3__AccessProfile(struct soap *soap, struct ns3__AccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfilesResponse(struct soap *soap, struct _ns3__GetAccessProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAccessProfile = 0;
	a->AccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfilesResponse(struct soap *soap, const struct _ns3__GetAccessProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AccessProfile)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfile; i++)
		{
			soap_embedded(soap, a->AccessProfile + i, SOAP_TYPE_ns3__AccessProfile);
			soap_serialize_ns3__AccessProfile(soap, a->AccessProfile + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfilesResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAccessProfile");
	if (a->AccessProfile)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfile; i++)
			if (soap_out_ns3__AccessProfile(soap, "ns3:AccessProfile", -1, a->AccessProfile + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfilesResponse * SOAP_FMAC4 soap_in__ns3__GetAccessProfilesResponse(struct soap *soap, const char *tag, struct _ns3__GetAccessProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AccessProfile = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfilesResponse, sizeof(struct _ns3__GetAccessProfilesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:AccessProfile", 1, NULL))
			{	if (a->AccessProfile == NULL)
				{	if (soap_blist_AccessProfile == NULL)
						soap_blist_AccessProfile = soap_alloc_block(soap);
					a->AccessProfile = (struct ns3__AccessProfile *)soap_push_block_max(soap, soap_blist_AccessProfile, sizeof(struct ns3__AccessProfile));
					if (a->AccessProfile == NULL)
						return NULL;
					soap_default_ns3__AccessProfile(soap, a->AccessProfile);
				}
				soap_revert(soap);
				if (soap_in_ns3__AccessProfile(soap, "ns3:AccessProfile", a->AccessProfile, "ns3:AccessProfile"))
				{	a->__sizeAccessProfile++;
					a->AccessProfile = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAccessProfile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessProfile)
			soap_pop_block(soap, soap_blist_AccessProfile);
		if (a->__sizeAccessProfile)
		{	a->AccessProfile = (struct ns3__AccessProfile *)soap_save_block(soap, soap_blist_AccessProfile, NULL, 1);
		}
		else
		{	a->AccessProfile = NULL;
			if (soap_blist_AccessProfile)
				soap_end_block(soap, soap_blist_AccessProfile);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfilesResponse, SOAP_TYPE__ns3__GetAccessProfilesResponse, sizeof(struct _ns3__GetAccessProfilesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfilesResponse * SOAP_FMAC4 soap_new__ns3__GetAccessProfilesResponse(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfilesResponse *p;
	struct _ns3__GetAccessProfilesResponse *a = (struct _ns3__GetAccessProfilesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfilesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfilesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfilesResponse(struct soap *soap, const struct _ns3__GetAccessProfilesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfilesResponse(soap, tag ? tag : "ns3:GetAccessProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfilesResponse * SOAP_FMAC4 soap_get__ns3__GetAccessProfilesResponse(struct soap *soap, struct _ns3__GetAccessProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfiles(struct soap *soap, struct _ns3__GetAccessProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfiles(struct soap *soap, const struct _ns3__GetAccessProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfiles(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfiles), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns3:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfiles * SOAP_FMAC4 soap_in__ns3__GetAccessProfiles(struct soap *soap, const char *tag, struct _ns3__GetAccessProfiles *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfiles, sizeof(struct _ns3__GetAccessProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns3:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfiles, SOAP_TYPE__ns3__GetAccessProfiles, sizeof(struct _ns3__GetAccessProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfiles * SOAP_FMAC4 soap_new__ns3__GetAccessProfiles(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfiles *p;
	struct _ns3__GetAccessProfiles *a = (struct _ns3__GetAccessProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfiles));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfiles(struct soap *soap, const struct _ns3__GetAccessProfiles *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfiles(soap, tag ? tag : "ns3:GetAccessProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfiles * SOAP_FMAC4 soap_get__ns3__GetAccessProfiles(struct soap *soap, struct _ns3__GetAccessProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfileInfoListResponse(struct soap *soap, struct _ns3__GetAccessProfileInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeAccessProfileInfo = 0;
	a->AccessProfileInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfileInfoListResponse(struct soap *soap, const struct _ns3__GetAccessProfileInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->AccessProfileInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfileInfo; i++)
		{
			soap_embedded(soap, a->AccessProfileInfo + i, SOAP_TYPE_ns3__AccessProfileInfo);
			soap_serialize_ns3__AccessProfileInfo(soap, a->AccessProfileInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfileInfoListResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfileInfoListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfileInfoListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns3:NextStartReference");
	if (soap_out_string(soap, "ns3:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->AccessProfileInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfileInfo; i++)
			if (soap_out_ns3__AccessProfileInfo(soap, "ns3:AccessProfileInfo", -1, a->AccessProfileInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoListResponse * SOAP_FMAC4 soap_in__ns3__GetAccessProfileInfoListResponse(struct soap *soap, const char *tag, struct _ns3__GetAccessProfileInfoListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_AccessProfileInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfileInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfileInfoListResponse, sizeof(struct _ns3__GetAccessProfileInfoListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfileInfoListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:AccessProfileInfo", 1, NULL))
			{	if (a->AccessProfileInfo == NULL)
				{	if (soap_blist_AccessProfileInfo == NULL)
						soap_blist_AccessProfileInfo = soap_alloc_block(soap);
					a->AccessProfileInfo = (struct ns3__AccessProfileInfo *)soap_push_block_max(soap, soap_blist_AccessProfileInfo, sizeof(struct ns3__AccessProfileInfo));
					if (a->AccessProfileInfo == NULL)
						return NULL;
					soap_default_ns3__AccessProfileInfo(soap, a->AccessProfileInfo);
				}
				soap_revert(soap);
				if (soap_in_ns3__AccessProfileInfo(soap, "ns3:AccessProfileInfo", a->AccessProfileInfo, "ns3:AccessProfileInfo"))
				{	a->__sizeAccessProfileInfo++;
					a->AccessProfileInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns3:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessProfileInfo)
			soap_pop_block(soap, soap_blist_AccessProfileInfo);
		if (a->__sizeAccessProfileInfo)
		{	a->AccessProfileInfo = (struct ns3__AccessProfileInfo *)soap_save_block(soap, soap_blist_AccessProfileInfo, NULL, 1);
		}
		else
		{	a->AccessProfileInfo = NULL;
			if (soap_blist_AccessProfileInfo)
				soap_end_block(soap, soap_blist_AccessProfileInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfileInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfileInfoListResponse, SOAP_TYPE__ns3__GetAccessProfileInfoListResponse, sizeof(struct _ns3__GetAccessProfileInfoListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoListResponse * SOAP_FMAC4 soap_new__ns3__GetAccessProfileInfoListResponse(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfileInfoListResponse *p;
	struct _ns3__GetAccessProfileInfoListResponse *a = (struct _ns3__GetAccessProfileInfoListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfileInfoListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfileInfoListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfileInfoListResponse(struct soap *soap, const struct _ns3__GetAccessProfileInfoListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfileInfoListResponse(soap, tag ? tag : "ns3:GetAccessProfileInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoListResponse * SOAP_FMAC4 soap_get__ns3__GetAccessProfileInfoListResponse(struct soap *soap, struct _ns3__GetAccessProfileInfoListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfileInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfileInfoList(struct soap *soap, struct _ns3__GetAccessProfileInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfileInfoList(struct soap *soap, const struct _ns3__GetAccessProfileInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfileInfoList(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfileInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfileInfoList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns3:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns3:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoList * SOAP_FMAC4 soap_in__ns3__GetAccessProfileInfoList(struct soap *soap, const char *tag, struct _ns3__GetAccessProfileInfoList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfileInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfileInfoList, sizeof(struct _ns3__GetAccessProfileInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfileInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns3:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns3:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfileInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfileInfoList, SOAP_TYPE__ns3__GetAccessProfileInfoList, sizeof(struct _ns3__GetAccessProfileInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoList * SOAP_FMAC4 soap_new__ns3__GetAccessProfileInfoList(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfileInfoList *p;
	struct _ns3__GetAccessProfileInfoList *a = (struct _ns3__GetAccessProfileInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfileInfoList));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfileInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfileInfoList(struct soap *soap, const struct _ns3__GetAccessProfileInfoList *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfileInfoList(soap, tag ? tag : "ns3:GetAccessProfileInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoList * SOAP_FMAC4 soap_get__ns3__GetAccessProfileInfoList(struct soap *soap, struct _ns3__GetAccessProfileInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfileInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__AccessProfileInfo(struct soap *soap, struct ns3__AccessProfileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__AccessProfileInfo(struct soap *soap, const struct ns3__AccessProfileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AccessProfileInfo(struct soap *soap, const char *tag, int id, const struct ns3__AccessProfileInfo *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AccessProfileInfo), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns3:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns3:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns3:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__AccessProfileInfo * SOAP_FMAC4 soap_in_ns3__AccessProfileInfo(struct soap *soap, const char *tag, struct ns3__AccessProfileInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__AccessProfileInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AccessProfileInfo, sizeof(struct ns3__AccessProfileInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__AccessProfileInfo(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns3:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns3:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns3__AccessProfileInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AccessProfileInfo, SOAP_TYPE_ns3__AccessProfileInfo, sizeof(struct ns3__AccessProfileInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__AccessProfileInfo * SOAP_FMAC4 soap_new_ns3__AccessProfileInfo(struct soap *soap, int n)
{
	struct ns3__AccessProfileInfo *p;
	struct ns3__AccessProfileInfo *a = (struct ns3__AccessProfileInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__AccessProfileInfo));
	for (p = a; p && n--; p++)
		soap_default_ns3__AccessProfileInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AccessProfileInfo(struct soap *soap, const struct ns3__AccessProfileInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns3__AccessProfileInfo(soap, tag ? tag : "ns3:AccessProfileInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__AccessProfileInfo * SOAP_FMAC4 soap_get_ns3__AccessProfileInfo(struct soap *soap, struct ns3__AccessProfileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AccessProfileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfileInfoResponse(struct soap *soap, struct _ns3__GetAccessProfileInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAccessProfileInfo = 0;
	a->AccessProfileInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfileInfoResponse(struct soap *soap, const struct _ns3__GetAccessProfileInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AccessProfileInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfileInfo; i++)
		{
			soap_embedded(soap, a->AccessProfileInfo + i, SOAP_TYPE_ns3__AccessProfileInfo);
			soap_serialize_ns3__AccessProfileInfo(soap, a->AccessProfileInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfileInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfileInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfileInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAccessProfileInfo");
	if (a->AccessProfileInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessProfileInfo; i++)
			if (soap_out_ns3__AccessProfileInfo(soap, "ns3:AccessProfileInfo", -1, a->AccessProfileInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoResponse * SOAP_FMAC4 soap_in__ns3__GetAccessProfileInfoResponse(struct soap *soap, const char *tag, struct _ns3__GetAccessProfileInfoResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AccessProfileInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfileInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfileInfoResponse, sizeof(struct _ns3__GetAccessProfileInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfileInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:AccessProfileInfo", 1, NULL))
			{	if (a->AccessProfileInfo == NULL)
				{	if (soap_blist_AccessProfileInfo == NULL)
						soap_blist_AccessProfileInfo = soap_alloc_block(soap);
					a->AccessProfileInfo = (struct ns3__AccessProfileInfo *)soap_push_block_max(soap, soap_blist_AccessProfileInfo, sizeof(struct ns3__AccessProfileInfo));
					if (a->AccessProfileInfo == NULL)
						return NULL;
					soap_default_ns3__AccessProfileInfo(soap, a->AccessProfileInfo);
				}
				soap_revert(soap);
				if (soap_in_ns3__AccessProfileInfo(soap, "ns3:AccessProfileInfo", a->AccessProfileInfo, "ns3:AccessProfileInfo"))
				{	a->__sizeAccessProfileInfo++;
					a->AccessProfileInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAccessProfileInfo");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessProfileInfo)
			soap_pop_block(soap, soap_blist_AccessProfileInfo);
		if (a->__sizeAccessProfileInfo)
		{	a->AccessProfileInfo = (struct ns3__AccessProfileInfo *)soap_save_block(soap, soap_blist_AccessProfileInfo, NULL, 1);
		}
		else
		{	a->AccessProfileInfo = NULL;
			if (soap_blist_AccessProfileInfo)
				soap_end_block(soap, soap_blist_AccessProfileInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfileInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfileInfoResponse, SOAP_TYPE__ns3__GetAccessProfileInfoResponse, sizeof(struct _ns3__GetAccessProfileInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoResponse * SOAP_FMAC4 soap_new__ns3__GetAccessProfileInfoResponse(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfileInfoResponse *p;
	struct _ns3__GetAccessProfileInfoResponse *a = (struct _ns3__GetAccessProfileInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfileInfoResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfileInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfileInfoResponse(struct soap *soap, const struct _ns3__GetAccessProfileInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfileInfoResponse(soap, tag ? tag : "ns3:GetAccessProfileInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfoResponse * SOAP_FMAC4 soap_get__ns3__GetAccessProfileInfoResponse(struct soap *soap, struct _ns3__GetAccessProfileInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfileInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetAccessProfileInfo(struct soap *soap, struct _ns3__GetAccessProfileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetAccessProfileInfo(struct soap *soap, const struct _ns3__GetAccessProfileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetAccessProfileInfo(struct soap *soap, const char *tag, int id, const struct _ns3__GetAccessProfileInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetAccessProfileInfo), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns3:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfo * SOAP_FMAC4 soap_in__ns3__GetAccessProfileInfo(struct soap *soap, const char *tag, struct _ns3__GetAccessProfileInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetAccessProfileInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetAccessProfileInfo, sizeof(struct _ns3__GetAccessProfileInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetAccessProfileInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns3:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns3:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__GetAccessProfileInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetAccessProfileInfo, SOAP_TYPE__ns3__GetAccessProfileInfo, sizeof(struct _ns3__GetAccessProfileInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfo * SOAP_FMAC4 soap_new__ns3__GetAccessProfileInfo(struct soap *soap, int n)
{
	struct _ns3__GetAccessProfileInfo *p;
	struct _ns3__GetAccessProfileInfo *a = (struct _ns3__GetAccessProfileInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetAccessProfileInfo));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetAccessProfileInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetAccessProfileInfo(struct soap *soap, const struct _ns3__GetAccessProfileInfo *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetAccessProfileInfo(soap, tag ? tag : "ns3:GetAccessProfileInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetAccessProfileInfo * SOAP_FMAC4 soap_get__ns3__GetAccessProfileInfo(struct soap *soap, struct _ns3__GetAccessProfileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetAccessProfileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns3__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns3__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons3__ServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _ns3__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns3:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns3:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons3__ServiceCapabilities(soap, "ns3:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__ns3__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns3__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetServiceCapabilitiesResponse, sizeof(struct _ns3__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__ServiceCapabilities(soap, "ns3:Capabilities", &a->Capabilities, "ns3:ServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns3:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns3__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetServiceCapabilitiesResponse, SOAP_TYPE__ns3__GetServiceCapabilitiesResponse, sizeof(struct _ns3__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__ns3__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _ns3__GetServiceCapabilitiesResponse *p;
	struct _ns3__GetServiceCapabilitiesResponse *a = (struct _ns3__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns3__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns3:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__ns3__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns3__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns3__GetServiceCapabilities(struct soap *soap, struct _ns3__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns3__GetServiceCapabilities(struct soap *soap, const struct _ns3__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns3__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns3__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns3__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns3__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns3__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns3__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__GetServiceCapabilities, sizeof(struct _ns3__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns3__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns3__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__GetServiceCapabilities, SOAP_TYPE__ns3__GetServiceCapabilities, sizeof(struct _ns3__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns3__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns3__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns3__GetServiceCapabilities *p;
	struct _ns3__GetServiceCapabilities *a = (struct _ns3__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns3__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns3__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns3__GetServiceCapabilities(struct soap *soap, const struct _ns3__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns3__GetServiceCapabilities(soap, tag ? tag : "ns3:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns3__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns3__GetServiceCapabilities(struct soap *soap, struct _ns3__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns3__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__AccessProfileExtension(struct soap *soap, struct ns3__AccessProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__AccessProfileExtension(struct soap *soap, const struct ns3__AccessProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AccessProfileExtension(struct soap *soap, const char *tag, int id, const struct ns3__AccessProfileExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AccessProfileExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__AccessProfileExtension * SOAP_FMAC4 soap_in_ns3__AccessProfileExtension(struct soap *soap, const char *tag, struct ns3__AccessProfileExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__AccessProfileExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AccessProfileExtension, sizeof(struct ns3__AccessProfileExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__AccessProfileExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__AccessProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AccessProfileExtension, SOAP_TYPE_ns3__AccessProfileExtension, sizeof(struct ns3__AccessProfileExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__AccessProfileExtension * SOAP_FMAC4 soap_new_ns3__AccessProfileExtension(struct soap *soap, int n)
{
	struct ns3__AccessProfileExtension *p;
	struct ns3__AccessProfileExtension *a = (struct ns3__AccessProfileExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__AccessProfileExtension));
	for (p = a; p && n--; p++)
		soap_default_ns3__AccessProfileExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AccessProfileExtension(struct soap *soap, const struct ns3__AccessProfileExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns3__AccessProfileExtension(soap, tag ? tag : "ns3:AccessProfileExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__AccessProfileExtension * SOAP_FMAC4 soap_get_ns3__AccessProfileExtension(struct soap *soap, struct ns3__AccessProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AccessProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__AccessPolicyExtension(struct soap *soap, struct ns3__AccessPolicyExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__AccessPolicyExtension(struct soap *soap, const struct ns3__AccessPolicyExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AccessPolicyExtension(struct soap *soap, const char *tag, int id, const struct ns3__AccessPolicyExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AccessPolicyExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__AccessPolicyExtension * SOAP_FMAC4 soap_in_ns3__AccessPolicyExtension(struct soap *soap, const char *tag, struct ns3__AccessPolicyExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__AccessPolicyExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AccessPolicyExtension, sizeof(struct ns3__AccessPolicyExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__AccessPolicyExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__AccessPolicyExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AccessPolicyExtension, SOAP_TYPE_ns3__AccessPolicyExtension, sizeof(struct ns3__AccessPolicyExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__AccessPolicyExtension * SOAP_FMAC4 soap_new_ns3__AccessPolicyExtension(struct soap *soap, int n)
{
	struct ns3__AccessPolicyExtension *p;
	struct ns3__AccessPolicyExtension *a = (struct ns3__AccessPolicyExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__AccessPolicyExtension));
	for (p = a; p && n--; p++)
		soap_default_ns3__AccessPolicyExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AccessPolicyExtension(struct soap *soap, const struct ns3__AccessPolicyExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns3__AccessPolicyExtension(soap, tag ? tag : "ns3:AccessPolicyExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__AccessPolicyExtension * SOAP_FMAC4 soap_get_ns3__AccessPolicyExtension(struct soap *soap, struct ns3__AccessPolicyExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AccessPolicyExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__AccessPolicy(struct soap *soap, struct ns3__AccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->ScheduleToken);
	soap_default_ns2__ReferenceToken(soap, &a->Entity);
	soap_default__QName(soap, &a->EntityType);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__AccessPolicy(struct soap *soap, const struct ns3__AccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->ScheduleToken);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Entity);
	soap_serialize__QName(soap, (char*const*)&a->EntityType);
	soap_serialize_PointerTons3__AccessPolicyExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AccessPolicy(struct soap *soap, const char *tag, int id, const struct ns3__AccessPolicy *a, const char *type)
{
	const char *soap_tmp_EntityType = soap_QName2s(soap, a->EntityType);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AccessPolicy), type))
		return soap->error;
	if (!a->ScheduleToken)
	{	if (soap_element_nil(soap, "ns3:ScheduleToken"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns3:ScheduleToken", -1, (char*const*)&a->ScheduleToken, ""))
		return soap->error;
	if (!a->Entity)
	{	if (soap_element_nil(soap, "ns3:Entity"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns3:Entity", -1, (char*const*)&a->Entity, ""))
		return soap->error;
	if (soap_out__QName(soap, "ns3:EntityType", -1, (char*const*)(void*)&soap_tmp_EntityType, ""))
		return soap->error;
	if (soap_out_PointerTons3__AccessPolicyExtension(soap, "ns3:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__AccessPolicy * SOAP_FMAC4 soap_in_ns3__AccessPolicy(struct soap *soap, const char *tag, struct ns3__AccessPolicy *a, const char *type)
{
	size_t soap_flag_ScheduleToken = 1;
	size_t soap_flag_Entity = 1;
	size_t soap_flag_EntityType = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__AccessPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AccessPolicy, sizeof(struct ns3__AccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__AccessPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScheduleToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns3:ScheduleToken", (char**)&a->ScheduleToken, "ns2:ReferenceToken"))
				{	soap_flag_ScheduleToken--;
					continue;
				}
			if (soap_flag_Entity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns3:Entity", (char**)&a->Entity, "ns2:ReferenceToken"))
				{	soap_flag_Entity--;
					continue;
				}
			if (soap_flag_EntityType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "ns3:EntityType", (char**)&a->EntityType, "xsd:QName"))
				{	soap_flag_EntityType--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AccessPolicyExtension(soap, "ns3:Extension", &a->Extension, "ns3:AccessPolicyExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScheduleToken > 0 || soap_flag_Entity > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns3__AccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AccessPolicy, SOAP_TYPE_ns3__AccessPolicy, sizeof(struct ns3__AccessPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__AccessPolicy * SOAP_FMAC4 soap_new_ns3__AccessPolicy(struct soap *soap, int n)
{
	struct ns3__AccessPolicy *p;
	struct ns3__AccessPolicy *a = (struct ns3__AccessPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__AccessPolicy));
	for (p = a; p && n--; p++)
		soap_default_ns3__AccessPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__AccessPolicy(struct soap *soap, const struct ns3__AccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out_ns3__AccessPolicy(soap, tag ? tag : "ns3:AccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__AccessPolicy * SOAP_FMAC4 soap_get_ns3__AccessPolicy(struct soap *soap, struct ns3__AccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__ServiceCapabilities(struct soap *soap, struct ns3__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->MaxLimit);
	soap_default_unsignedInt(soap, &a->MaxAccessProfiles);
	soap_default_unsignedInt(soap, &a->MaxAccessPoliciesPerAccessProfile);
	soap_default_xsd__boolean(soap, &a->MultipleSchedulesPerAccessPointSupported);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__ServiceCapabilities(struct soap *soap, const struct ns3__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__ServiceCapabilities(struct soap *soap, const char *tag, int id, const struct ns3__ServiceCapabilities *a, const char *type)
{
	soap_set_attr(soap, "MaxLimit", soap_unsignedInt2s(soap, a->MaxLimit), 1);
	soap_set_attr(soap, "MaxAccessProfiles", soap_unsignedInt2s(soap, a->MaxAccessProfiles), 1);
	soap_set_attr(soap, "MaxAccessPoliciesPerAccessProfile", soap_unsignedInt2s(soap, a->MaxAccessPoliciesPerAccessProfile), 1);
	soap_set_attr(soap, "MultipleSchedulesPerAccessPointSupported", soap_xsd__boolean2s(soap, a->MultipleSchedulesPerAccessPointSupported), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__ServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns3__ServiceCapabilities * SOAP_FMAC4 soap_in_ns3__ServiceCapabilities(struct soap *soap, const char *tag, struct ns3__ServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns3__ServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__ServiceCapabilities, sizeof(struct ns3__ServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns3__ServiceCapabilities(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MaxLimit", 1), &a->MaxLimit))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MaxAccessProfiles", 1), &a->MaxAccessProfiles))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MaxAccessPoliciesPerAccessProfile", 1), &a->MaxAccessPoliciesPerAccessProfile))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "MultipleSchedulesPerAccessPointSupported", 1), &a->MultipleSchedulesPerAccessPointSupported))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns3__ServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__ServiceCapabilities, SOAP_TYPE_ns3__ServiceCapabilities, sizeof(struct ns3__ServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns3__ServiceCapabilities * SOAP_FMAC4 soap_new_ns3__ServiceCapabilities(struct soap *soap, int n)
{
	struct ns3__ServiceCapabilities *p;
	struct ns3__ServiceCapabilities *a = (struct ns3__ServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns3__ServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns3__ServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__ServiceCapabilities(struct soap *soap, const struct ns3__ServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns3__ServiceCapabilities(soap, tag ? tag : "ns3:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns3__ServiceCapabilities * SOAP_FMAC4 soap_get_ns3__ServiceCapabilities(struct soap *soap, struct ns3__ServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__Attribute(struct soap *soap, struct ns2__Attribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_string(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Attribute(struct soap *soap, const struct ns2__Attribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Attribute(struct soap *soap, const char *tag, int id, const struct ns2__Attribute *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->Value)
		soap_set_attr(soap, "Value", soap_string2s(soap, a->Value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Attribute), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__Attribute * SOAP_FMAC4 soap_in_ns2__Attribute(struct soap *soap, const char *tag, struct ns2__Attribute *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__Attribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Attribute, sizeof(struct ns2__Attribute), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__Attribute(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Value", 0), &a->Value))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__Attribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Attribute, SOAP_TYPE_ns2__Attribute, sizeof(struct ns2__Attribute), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__Attribute * SOAP_FMAC4 soap_new_ns2__Attribute(struct soap *soap, int n)
{
	struct ns2__Attribute *p;
	struct ns2__Attribute *a = (struct ns2__Attribute*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__Attribute));
	for (p = a; p && n--; p++)
		soap_default_ns2__Attribute(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Attribute(struct soap *soap, const struct ns2__Attribute *a, const char *tag, const char *type)
{
	if (soap_out_ns2__Attribute(soap, tag ? tag : "ns2:Attribute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__Attribute * SOAP_FMAC4 soap_get_ns2__Attribute(struct soap *soap, struct ns2__Attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Attribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DataEntity(struct soap *soap, struct ns2__DataEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__DataEntity(struct soap *soap, const struct ns2__DataEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataEntity(struct soap *soap, const char *tag, int id, const struct ns2__DataEntity *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__DataEntity * SOAP_FMAC4 soap_in_ns2__DataEntity(struct soap *soap, const char *tag, struct ns2__DataEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__DataEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataEntity, sizeof(struct ns2__DataEntity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__DataEntity(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__DataEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataEntity, SOAP_TYPE_ns2__DataEntity, sizeof(struct ns2__DataEntity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns2__DataEntity * SOAP_FMAC4 soap_new_ns2__DataEntity(struct soap *soap, int n)
{
	struct ns2__DataEntity *p;
	struct ns2__DataEntity *a = (struct ns2__DataEntity*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns2__DataEntity));
	for (p = a; p && n--; p++)
		soap_default_ns2__DataEntity(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DataEntity(struct soap *soap, const struct ns2__DataEntity *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DataEntity(soap, tag ? tag : "ns2:DataEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__DataEntity * SOAP_FMAC4 soap_get_ns2__DataEntity(struct soap *soap, struct ns2__DataEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ExternalAuthorizationResponse(struct soap *soap, struct _ns1__ExternalAuthorizationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ExternalAuthorizationResponse(struct soap *soap, const struct _ns1__ExternalAuthorizationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExternalAuthorizationResponse(struct soap *soap, const char *tag, int id, const struct _ns1__ExternalAuthorizationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExternalAuthorizationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ExternalAuthorizationResponse * SOAP_FMAC4 soap_in__ns1__ExternalAuthorizationResponse(struct soap *soap, const char *tag, struct _ns1__ExternalAuthorizationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ExternalAuthorizationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExternalAuthorizationResponse, sizeof(struct _ns1__ExternalAuthorizationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ExternalAuthorizationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__ExternalAuthorizationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExternalAuthorizationResponse, SOAP_TYPE__ns1__ExternalAuthorizationResponse, sizeof(struct _ns1__ExternalAuthorizationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__ExternalAuthorizationResponse * SOAP_FMAC4 soap_new__ns1__ExternalAuthorizationResponse(struct soap *soap, int n)
{
	struct _ns1__ExternalAuthorizationResponse *p;
	struct _ns1__ExternalAuthorizationResponse *a = (struct _ns1__ExternalAuthorizationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__ExternalAuthorizationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__ExternalAuthorizationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ExternalAuthorizationResponse(struct soap *soap, const struct _ns1__ExternalAuthorizationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__ExternalAuthorizationResponse(soap, tag ? tag : "ns1:ExternalAuthorizationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ExternalAuthorizationResponse * SOAP_FMAC4 soap_get__ns1__ExternalAuthorizationResponse(struct soap *soap, struct _ns1__ExternalAuthorizationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExternalAuthorizationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ExternalAuthorization(struct soap *soap, struct _ns1__ExternalAuthorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->AccessPointToken);
	soap_default_ns2__ReferenceToken(soap, &a->CredentialToken);
	soap_default_string(soap, &a->Reason);
	soap_default_ns1__Decision(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__ExternalAuthorization(struct soap *soap, const struct _ns1__ExternalAuthorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->AccessPointToken);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->CredentialToken);
	soap_serialize_string(soap, (char*const*)&a->Reason);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExternalAuthorization(struct soap *soap, const char *tag, int id, const struct _ns1__ExternalAuthorization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExternalAuthorization), type))
		return soap->error;
	if (!a->AccessPointToken)
	{	if (soap_element_nil(soap, "ns1:AccessPointToken"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns1:AccessPointToken", -1, (char*const*)&a->AccessPointToken, ""))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:CredentialToken", -1, (char*const*)&a->CredentialToken, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:Reason", -1, (char*const*)&a->Reason, ""))
		return soap->error;
	if (soap_out_ns1__Decision(soap, "ns1:Decision", -1, &a->Decision, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__ExternalAuthorization * SOAP_FMAC4 soap_in__ns1__ExternalAuthorization(struct soap *soap, const char *tag, struct _ns1__ExternalAuthorization *a, const char *type)
{
	size_t soap_flag_AccessPointToken = 1;
	size_t soap_flag_CredentialToken = 1;
	size_t soap_flag_Reason = 1;
	size_t soap_flag_Decision = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__ExternalAuthorization *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExternalAuthorization, sizeof(struct _ns1__ExternalAuthorization), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__ExternalAuthorization(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccessPointToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:AccessPointToken", (char**)&a->AccessPointToken, "ns2:ReferenceToken"))
				{	soap_flag_AccessPointToken--;
					continue;
				}
			if (soap_flag_CredentialToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:CredentialToken", (char**)&a->CredentialToken, "ns2:ReferenceToken"))
				{	soap_flag_CredentialToken--;
					continue;
				}
			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:Reason", (char**)&a->Reason, "xsd:string"))
				{	soap_flag_Reason--;
					continue;
				}
			if (soap_flag_Decision && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__Decision(soap, "ns1:Decision", &a->Decision, "ns1:Decision"))
				{	soap_flag_Decision--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccessPointToken > 0 || soap_flag_Decision > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__ExternalAuthorization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExternalAuthorization, SOAP_TYPE__ns1__ExternalAuthorization, sizeof(struct _ns1__ExternalAuthorization), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__ExternalAuthorization * SOAP_FMAC4 soap_new__ns1__ExternalAuthorization(struct soap *soap, int n)
{
	struct _ns1__ExternalAuthorization *p;
	struct _ns1__ExternalAuthorization *a = (struct _ns1__ExternalAuthorization*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__ExternalAuthorization));
	for (p = a; p && n--; p++)
		soap_default__ns1__ExternalAuthorization(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ExternalAuthorization(struct soap *soap, const struct _ns1__ExternalAuthorization *a, const char *tag, const char *type)
{
	if (soap_out__ns1__ExternalAuthorization(soap, tag ? tag : "ns1:ExternalAuthorization", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ExternalAuthorization * SOAP_FMAC4 soap_get__ns1__ExternalAuthorization(struct soap *soap, struct _ns1__ExternalAuthorization *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExternalAuthorization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__DisableAccessPointResponse(struct soap *soap, struct _ns1__DisableAccessPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__DisableAccessPointResponse(struct soap *soap, const struct _ns1__DisableAccessPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DisableAccessPointResponse(struct soap *soap, const char *tag, int id, const struct _ns1__DisableAccessPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DisableAccessPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__DisableAccessPointResponse * SOAP_FMAC4 soap_in__ns1__DisableAccessPointResponse(struct soap *soap, const char *tag, struct _ns1__DisableAccessPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__DisableAccessPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DisableAccessPointResponse, sizeof(struct _ns1__DisableAccessPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__DisableAccessPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__DisableAccessPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DisableAccessPointResponse, SOAP_TYPE__ns1__DisableAccessPointResponse, sizeof(struct _ns1__DisableAccessPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__DisableAccessPointResponse * SOAP_FMAC4 soap_new__ns1__DisableAccessPointResponse(struct soap *soap, int n)
{
	struct _ns1__DisableAccessPointResponse *p;
	struct _ns1__DisableAccessPointResponse *a = (struct _ns1__DisableAccessPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__DisableAccessPointResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__DisableAccessPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__DisableAccessPointResponse(struct soap *soap, const struct _ns1__DisableAccessPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__DisableAccessPointResponse(soap, tag ? tag : "ns1:DisableAccessPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DisableAccessPointResponse * SOAP_FMAC4 soap_get__ns1__DisableAccessPointResponse(struct soap *soap, struct _ns1__DisableAccessPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DisableAccessPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__DisableAccessPoint(struct soap *soap, struct _ns1__DisableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__DisableAccessPoint(struct soap *soap, const struct _ns1__DisableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DisableAccessPoint(struct soap *soap, const char *tag, int id, const struct _ns1__DisableAccessPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DisableAccessPoint), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns1:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns1:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__DisableAccessPoint * SOAP_FMAC4 soap_in__ns1__DisableAccessPoint(struct soap *soap, const char *tag, struct _ns1__DisableAccessPoint *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__DisableAccessPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DisableAccessPoint, sizeof(struct _ns1__DisableAccessPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__DisableAccessPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__DisableAccessPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DisableAccessPoint, SOAP_TYPE__ns1__DisableAccessPoint, sizeof(struct _ns1__DisableAccessPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__DisableAccessPoint * SOAP_FMAC4 soap_new__ns1__DisableAccessPoint(struct soap *soap, int n)
{
	struct _ns1__DisableAccessPoint *p;
	struct _ns1__DisableAccessPoint *a = (struct _ns1__DisableAccessPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__DisableAccessPoint));
	for (p = a; p && n--; p++)
		soap_default__ns1__DisableAccessPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__DisableAccessPoint(struct soap *soap, const struct _ns1__DisableAccessPoint *a, const char *tag, const char *type)
{
	if (soap_out__ns1__DisableAccessPoint(soap, tag ? tag : "ns1:DisableAccessPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DisableAccessPoint * SOAP_FMAC4 soap_get__ns1__DisableAccessPoint(struct soap *soap, struct _ns1__DisableAccessPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DisableAccessPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__EnableAccessPointResponse(struct soap *soap, struct _ns1__EnableAccessPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__EnableAccessPointResponse(struct soap *soap, const struct _ns1__EnableAccessPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EnableAccessPointResponse(struct soap *soap, const char *tag, int id, const struct _ns1__EnableAccessPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EnableAccessPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__EnableAccessPointResponse * SOAP_FMAC4 soap_in__ns1__EnableAccessPointResponse(struct soap *soap, const char *tag, struct _ns1__EnableAccessPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__EnableAccessPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EnableAccessPointResponse, sizeof(struct _ns1__EnableAccessPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__EnableAccessPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__EnableAccessPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EnableAccessPointResponse, SOAP_TYPE__ns1__EnableAccessPointResponse, sizeof(struct _ns1__EnableAccessPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__EnableAccessPointResponse * SOAP_FMAC4 soap_new__ns1__EnableAccessPointResponse(struct soap *soap, int n)
{
	struct _ns1__EnableAccessPointResponse *p;
	struct _ns1__EnableAccessPointResponse *a = (struct _ns1__EnableAccessPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__EnableAccessPointResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__EnableAccessPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__EnableAccessPointResponse(struct soap *soap, const struct _ns1__EnableAccessPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__EnableAccessPointResponse(soap, tag ? tag : "ns1:EnableAccessPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__EnableAccessPointResponse * SOAP_FMAC4 soap_get__ns1__EnableAccessPointResponse(struct soap *soap, struct _ns1__EnableAccessPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EnableAccessPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__EnableAccessPoint(struct soap *soap, struct _ns1__EnableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__EnableAccessPoint(struct soap *soap, const struct _ns1__EnableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EnableAccessPoint(struct soap *soap, const char *tag, int id, const struct _ns1__EnableAccessPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EnableAccessPoint), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns1:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns1:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__EnableAccessPoint * SOAP_FMAC4 soap_in__ns1__EnableAccessPoint(struct soap *soap, const char *tag, struct _ns1__EnableAccessPoint *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__EnableAccessPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EnableAccessPoint, sizeof(struct _ns1__EnableAccessPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__EnableAccessPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__EnableAccessPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EnableAccessPoint, SOAP_TYPE__ns1__EnableAccessPoint, sizeof(struct _ns1__EnableAccessPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__EnableAccessPoint * SOAP_FMAC4 soap_new__ns1__EnableAccessPoint(struct soap *soap, int n)
{
	struct _ns1__EnableAccessPoint *p;
	struct _ns1__EnableAccessPoint *a = (struct _ns1__EnableAccessPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__EnableAccessPoint));
	for (p = a; p && n--; p++)
		soap_default__ns1__EnableAccessPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__EnableAccessPoint(struct soap *soap, const struct _ns1__EnableAccessPoint *a, const char *tag, const char *type)
{
	if (soap_out__ns1__EnableAccessPoint(soap, tag ? tag : "ns1:EnableAccessPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__EnableAccessPoint * SOAP_FMAC4 soap_get__ns1__EnableAccessPoint(struct soap *soap, struct _ns1__EnableAccessPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EnableAccessPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAccessPointStateResponse(struct soap *soap, struct _ns1__GetAccessPointStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AccessPointState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAccessPointStateResponse(struct soap *soap, const struct _ns1__GetAccessPointStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AccessPointState(soap, &a->AccessPointState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAccessPointStateResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetAccessPointStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAccessPointStateResponse), type))
		return soap->error;
	if (a->AccessPointState)
		soap_element_result(soap, "ns1:AccessPointState");
	if (!a->AccessPointState)
	{	if (soap_element_nil(soap, "ns1:AccessPointState"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__AccessPointState(soap, "ns1:AccessPointState", -1, &a->AccessPointState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAccessPointStateResponse * SOAP_FMAC4 soap_in__ns1__GetAccessPointStateResponse(struct soap *soap, const char *tag, struct _ns1__GetAccessPointStateResponse *a, const char *type)
{
	size_t soap_flag_AccessPointState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAccessPointStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAccessPointStateResponse, sizeof(struct _ns1__GetAccessPointStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAccessPointStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AccessPointState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessPointState(soap, "ns1:AccessPointState", &a->AccessPointState, "ns1:AccessPointState"))
				{	soap_flag_AccessPointState--;
					continue;
				}
			soap_check_result(soap, "ns1:AccessPointState");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AccessPointState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__GetAccessPointStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAccessPointStateResponse, SOAP_TYPE__ns1__GetAccessPointStateResponse, sizeof(struct _ns1__GetAccessPointStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAccessPointStateResponse * SOAP_FMAC4 soap_new__ns1__GetAccessPointStateResponse(struct soap *soap, int n)
{
	struct _ns1__GetAccessPointStateResponse *p;
	struct _ns1__GetAccessPointStateResponse *a = (struct _ns1__GetAccessPointStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAccessPointStateResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAccessPointStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAccessPointStateResponse(struct soap *soap, const struct _ns1__GetAccessPointStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAccessPointStateResponse(soap, tag ? tag : "ns1:GetAccessPointStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAccessPointStateResponse * SOAP_FMAC4 soap_get__ns1__GetAccessPointStateResponse(struct soap *soap, struct _ns1__GetAccessPointStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAccessPointStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAccessPointState(struct soap *soap, struct _ns1__GetAccessPointState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAccessPointState(struct soap *soap, const struct _ns1__GetAccessPointState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAccessPointState(struct soap *soap, const char *tag, int id, const struct _ns1__GetAccessPointState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAccessPointState), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns1:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns1:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAccessPointState * SOAP_FMAC4 soap_in__ns1__GetAccessPointState(struct soap *soap, const char *tag, struct _ns1__GetAccessPointState *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAccessPointState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAccessPointState, sizeof(struct _ns1__GetAccessPointState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAccessPointState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__GetAccessPointState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAccessPointState, SOAP_TYPE__ns1__GetAccessPointState, sizeof(struct _ns1__GetAccessPointState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAccessPointState * SOAP_FMAC4 soap_new__ns1__GetAccessPointState(struct soap *soap, int n)
{
	struct _ns1__GetAccessPointState *p;
	struct _ns1__GetAccessPointState *a = (struct _ns1__GetAccessPointState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAccessPointState));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAccessPointState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAccessPointState(struct soap *soap, const struct _ns1__GetAccessPointState *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAccessPointState(soap, tag ? tag : "ns1:GetAccessPointState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAccessPointState * SOAP_FMAC4 soap_get__ns1__GetAccessPointState(struct soap *soap, struct _ns1__GetAccessPointState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAccessPointState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAreaInfoResponse(struct soap *soap, struct _ns1__GetAreaInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAreaInfo = 0;
	a->AreaInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAreaInfoResponse(struct soap *soap, const struct _ns1__GetAreaInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AreaInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAreaInfo; i++)
		{
			soap_embedded(soap, a->AreaInfo + i, SOAP_TYPE_ns1__AreaInfo);
			soap_serialize_ns1__AreaInfo(soap, a->AreaInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAreaInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetAreaInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAreaInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAreaInfo");
	if (a->AreaInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAreaInfo; i++)
			if (soap_out_ns1__AreaInfo(soap, "ns1:AreaInfo", -1, a->AreaInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAreaInfoResponse * SOAP_FMAC4 soap_in__ns1__GetAreaInfoResponse(struct soap *soap, const char *tag, struct _ns1__GetAreaInfoResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AreaInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAreaInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAreaInfoResponse, sizeof(struct _ns1__GetAreaInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAreaInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AreaInfo", 1, NULL))
			{	if (a->AreaInfo == NULL)
				{	if (soap_blist_AreaInfo == NULL)
						soap_blist_AreaInfo = soap_alloc_block(soap);
					a->AreaInfo = (struct ns1__AreaInfo *)soap_push_block_max(soap, soap_blist_AreaInfo, sizeof(struct ns1__AreaInfo));
					if (a->AreaInfo == NULL)
						return NULL;
					soap_default_ns1__AreaInfo(soap, a->AreaInfo);
				}
				soap_revert(soap);
				if (soap_in_ns1__AreaInfo(soap, "ns1:AreaInfo", a->AreaInfo, "ns1:AreaInfo"))
				{	a->__sizeAreaInfo++;
					a->AreaInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAreaInfo");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AreaInfo)
			soap_pop_block(soap, soap_blist_AreaInfo);
		if (a->__sizeAreaInfo)
		{	a->AreaInfo = (struct ns1__AreaInfo *)soap_save_block(soap, soap_blist_AreaInfo, NULL, 1);
		}
		else
		{	a->AreaInfo = NULL;
			if (soap_blist_AreaInfo)
				soap_end_block(soap, soap_blist_AreaInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetAreaInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAreaInfoResponse, SOAP_TYPE__ns1__GetAreaInfoResponse, sizeof(struct _ns1__GetAreaInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAreaInfoResponse * SOAP_FMAC4 soap_new__ns1__GetAreaInfoResponse(struct soap *soap, int n)
{
	struct _ns1__GetAreaInfoResponse *p;
	struct _ns1__GetAreaInfoResponse *a = (struct _ns1__GetAreaInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAreaInfoResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAreaInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAreaInfoResponse(struct soap *soap, const struct _ns1__GetAreaInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAreaInfoResponse(soap, tag ? tag : "ns1:GetAreaInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAreaInfoResponse * SOAP_FMAC4 soap_get__ns1__GetAreaInfoResponse(struct soap *soap, struct _ns1__GetAreaInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAreaInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAreaInfo(struct soap *soap, struct _ns1__GetAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAreaInfo(struct soap *soap, const struct _ns1__GetAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAreaInfo(struct soap *soap, const char *tag, int id, const struct _ns1__GetAreaInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAreaInfo), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns1:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAreaInfo * SOAP_FMAC4 soap_in__ns1__GetAreaInfo(struct soap *soap, const char *tag, struct _ns1__GetAreaInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAreaInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAreaInfo, sizeof(struct _ns1__GetAreaInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAreaInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__GetAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAreaInfo, SOAP_TYPE__ns1__GetAreaInfo, sizeof(struct _ns1__GetAreaInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAreaInfo * SOAP_FMAC4 soap_new__ns1__GetAreaInfo(struct soap *soap, int n)
{
	struct _ns1__GetAreaInfo *p;
	struct _ns1__GetAreaInfo *a = (struct _ns1__GetAreaInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAreaInfo));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAreaInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAreaInfo(struct soap *soap, const struct _ns1__GetAreaInfo *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAreaInfo(soap, tag ? tag : "ns1:GetAreaInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAreaInfo * SOAP_FMAC4 soap_get__ns1__GetAreaInfo(struct soap *soap, struct _ns1__GetAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AreaInfo(struct soap *soap, struct ns1__AreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AreaInfo(struct soap *soap, const struct ns1__AreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AreaInfo(struct soap *soap, const char *tag, int id, const struct ns1__AreaInfo *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AreaInfo), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns1:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns1:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns1:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AreaInfo * SOAP_FMAC4 soap_in_ns1__AreaInfo(struct soap *soap, const char *tag, struct ns1__AreaInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AreaInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AreaInfo, sizeof(struct ns1__AreaInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AreaInfo(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns1:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns1:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AreaInfo, SOAP_TYPE_ns1__AreaInfo, sizeof(struct ns1__AreaInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AreaInfo * SOAP_FMAC4 soap_new_ns1__AreaInfo(struct soap *soap, int n)
{
	struct ns1__AreaInfo *p;
	struct ns1__AreaInfo *a = (struct ns1__AreaInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AreaInfo));
	for (p = a; p && n--; p++)
		soap_default_ns1__AreaInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AreaInfo(struct soap *soap, const struct ns1__AreaInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AreaInfo(soap, tag ? tag : "ns1:AreaInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AreaInfo * SOAP_FMAC4 soap_get_ns1__AreaInfo(struct soap *soap, struct ns1__AreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAreaInfoListResponse(struct soap *soap, struct _ns1__GetAreaInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeAreaInfo = 0;
	a->AreaInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAreaInfoListResponse(struct soap *soap, const struct _ns1__GetAreaInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->AreaInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAreaInfo; i++)
		{
			soap_embedded(soap, a->AreaInfo + i, SOAP_TYPE_ns1__AreaInfo);
			soap_serialize_ns1__AreaInfo(soap, a->AreaInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAreaInfoListResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetAreaInfoListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAreaInfoListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns1:NextStartReference");
	if (soap_out_string(soap, "ns1:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->AreaInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAreaInfo; i++)
			if (soap_out_ns1__AreaInfo(soap, "ns1:AreaInfo", -1, a->AreaInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAreaInfoListResponse * SOAP_FMAC4 soap_in__ns1__GetAreaInfoListResponse(struct soap *soap, const char *tag, struct _ns1__GetAreaInfoListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_AreaInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAreaInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAreaInfoListResponse, sizeof(struct _ns1__GetAreaInfoListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAreaInfoListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AreaInfo", 1, NULL))
			{	if (a->AreaInfo == NULL)
				{	if (soap_blist_AreaInfo == NULL)
						soap_blist_AreaInfo = soap_alloc_block(soap);
					a->AreaInfo = (struct ns1__AreaInfo *)soap_push_block_max(soap, soap_blist_AreaInfo, sizeof(struct ns1__AreaInfo));
					if (a->AreaInfo == NULL)
						return NULL;
					soap_default_ns1__AreaInfo(soap, a->AreaInfo);
				}
				soap_revert(soap);
				if (soap_in_ns1__AreaInfo(soap, "ns1:AreaInfo", a->AreaInfo, "ns1:AreaInfo"))
				{	a->__sizeAreaInfo++;
					a->AreaInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AreaInfo)
			soap_pop_block(soap, soap_blist_AreaInfo);
		if (a->__sizeAreaInfo)
		{	a->AreaInfo = (struct ns1__AreaInfo *)soap_save_block(soap, soap_blist_AreaInfo, NULL, 1);
		}
		else
		{	a->AreaInfo = NULL;
			if (soap_blist_AreaInfo)
				soap_end_block(soap, soap_blist_AreaInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetAreaInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAreaInfoListResponse, SOAP_TYPE__ns1__GetAreaInfoListResponse, sizeof(struct _ns1__GetAreaInfoListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAreaInfoListResponse * SOAP_FMAC4 soap_new__ns1__GetAreaInfoListResponse(struct soap *soap, int n)
{
	struct _ns1__GetAreaInfoListResponse *p;
	struct _ns1__GetAreaInfoListResponse *a = (struct _ns1__GetAreaInfoListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAreaInfoListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAreaInfoListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAreaInfoListResponse(struct soap *soap, const struct _ns1__GetAreaInfoListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAreaInfoListResponse(soap, tag ? tag : "ns1:GetAreaInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAreaInfoListResponse * SOAP_FMAC4 soap_get__ns1__GetAreaInfoListResponse(struct soap *soap, struct _ns1__GetAreaInfoListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAreaInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAreaInfoList(struct soap *soap, struct _ns1__GetAreaInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAreaInfoList(struct soap *soap, const struct _ns1__GetAreaInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAreaInfoList(struct soap *soap, const char *tag, int id, const struct _ns1__GetAreaInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAreaInfoList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAreaInfoList * SOAP_FMAC4 soap_in__ns1__GetAreaInfoList(struct soap *soap, const char *tag, struct _ns1__GetAreaInfoList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAreaInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAreaInfoList, sizeof(struct _ns1__GetAreaInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAreaInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetAreaInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAreaInfoList, SOAP_TYPE__ns1__GetAreaInfoList, sizeof(struct _ns1__GetAreaInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAreaInfoList * SOAP_FMAC4 soap_new__ns1__GetAreaInfoList(struct soap *soap, int n)
{
	struct _ns1__GetAreaInfoList *p;
	struct _ns1__GetAreaInfoList *a = (struct _ns1__GetAreaInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAreaInfoList));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAreaInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAreaInfoList(struct soap *soap, const struct _ns1__GetAreaInfoList *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAreaInfoList(soap, tag ? tag : "ns1:GetAreaInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAreaInfoList * SOAP_FMAC4 soap_get__ns1__GetAreaInfoList(struct soap *soap, struct _ns1__GetAreaInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAreaInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
