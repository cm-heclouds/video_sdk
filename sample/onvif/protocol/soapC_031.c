/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceTag);
	soap_default_tt__TrackReference(soap, &a->Destination);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobTrack(struct soap *soap, const struct tt__RecordingJobTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SourceTag);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->Destination);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobTrack(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobTrack), type))
		return soap->error;
	if (!a->SourceTag)
	{	if (soap_element_nil(soap, "tt:SourceTag"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:SourceTag", -1, (char*const*)&a->SourceTag, ""))
		return soap->error;
	if (!a->Destination)
	{	if (soap_element_nil(soap, "tt:Destination"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, (char*const*)&a->Destination, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_in_tt__RecordingJobTrack(struct soap *soap, const char *tag, struct tt__RecordingJobTrack *a, const char *type)
{
	size_t soap_flag_SourceTag = 1;
	size_t soap_flag_Destination = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobTrack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SourceTag", (char**)&a->SourceTag, "xsd:string"))
				{	soap_flag_SourceTag--;
					continue;
				}
			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:Destination", (char**)&a->Destination, "tt:TrackReference"))
				{	soap_flag_Destination--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceTag > 0 || soap_flag_Destination > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobTrack, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_new_tt__RecordingJobTrack(struct soap *soap, int n)
{
	struct tt__RecordingJobTrack *p;
	struct tt__RecordingJobTrack *a = (struct tt__RecordingJobTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobTrack));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobTrack(struct soap *soap, const struct tt__RecordingJobTrack *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobTrack(soap, tag ? tag : "tt:RecordingJobTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_get_tt__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobConfigurationExtension(struct soap *soap, const struct tt__RecordingJobConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfigurationExtension, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_new_tt__RecordingJobConfigurationExtension(struct soap *soap, int n)
{
	struct tt__RecordingJobConfigurationExtension *p;
	struct tt__RecordingJobConfigurationExtension *a = (struct tt__RecordingJobConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobConfigurationExtension(struct soap *soap, const struct tt__RecordingJobConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobConfigurationExtension(soap, tag ? tag : "tt:RecordingJobConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SourceToken = NULL;
	a->AutoCreateReceiver = NULL;
	a->__sizeTracks = 0;
	a->Tracks = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobSource(struct soap *soap, const struct tt__RecordingJobSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceReference(soap, &a->SourceToken);
	soap_serialize_PointerToxsd__boolean(soap, &a->AutoCreateReceiver);
	if (a->Tracks)
	{	int i;
		for (i = 0; i < (int)a->__sizeTracks; i++)
		{
			soap_embedded(soap, a->Tracks + i, SOAP_TYPE_tt__RecordingJobTrack);
			soap_serialize_tt__RecordingJobTrack(soap, a->Tracks + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobSourceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSource(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSource), type))
		return soap->error;
	if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:AutoCreateReceiver", -1, &a->AutoCreateReceiver, ""))
		return soap->error;
	if (a->Tracks)
	{	int i;
		for (i = 0; i < (int)a->__sizeTracks; i++)
			if (soap_out_tt__RecordingJobTrack(soap, "tt:Tracks", -1, a->Tracks + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_in_tt__RecordingJobSource(struct soap *soap, const char *tag, struct tt__RecordingJobSource *a, const char *type)
{
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_AutoCreateReceiver = 1;
	struct soap_blist *soap_blist_Tracks = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobSource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_AutoCreateReceiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:AutoCreateReceiver", &a->AutoCreateReceiver, "xsd:boolean"))
				{	soap_flag_AutoCreateReceiver--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Tracks", 1, NULL))
			{	if (a->Tracks == NULL)
				{	if (soap_blist_Tracks == NULL)
						soap_blist_Tracks = soap_alloc_block(soap);
					a->Tracks = (struct tt__RecordingJobTrack *)soap_push_block_max(soap, soap_blist_Tracks, sizeof(struct tt__RecordingJobTrack));
					if (a->Tracks == NULL)
						return NULL;
					soap_default_tt__RecordingJobTrack(soap, a->Tracks);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobTrack(soap, "tt:Tracks", a->Tracks, "tt:RecordingJobTrack"))
				{	a->__sizeTracks++;
					a->Tracks = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobSourceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Tracks)
			soap_pop_block(soap, soap_blist_Tracks);
		if (a->__sizeTracks)
		{	a->Tracks = (struct tt__RecordingJobTrack *)soap_save_block(soap, soap_blist_Tracks, NULL, 1);
		}
		else
		{	a->Tracks = NULL;
			if (soap_blist_Tracks)
				soap_end_block(soap, soap_blist_Tracks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSource, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_new_tt__RecordingJobSource(struct soap *soap, int n)
{
	struct tt__RecordingJobSource *p;
	struct tt__RecordingJobSource *a = (struct tt__RecordingJobSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobSource));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobSource(struct soap *soap, const struct tt__RecordingJobSource *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobSource(soap, tag ? tag : "tt:RecordingJobSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_get_tt__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__RecordingJobMode(soap, &a->Mode);
	soap_default_int(soap, &a->Priority);
	a->__sizeSource = 0;
	a->Source = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobConfiguration(struct soap *soap, const struct tt__RecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__RecordingJobMode(soap, (char*const*)&a->Mode);
	soap_embedded(soap, &a->Priority, SOAP_TYPE_int);
	if (a->Source)
	{	int i;
		for (i = 0; i < (int)a->__sizeSource; i++)
		{
			soap_embedded(soap, a->Source + i, SOAP_TYPE_tt__RecordingJobSource);
			soap_serialize_tt__RecordingJobSource(soap, a->Source + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->Mode)
	{	if (soap_element_nil(soap, "tt:Mode"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobMode(soap, "tt:Mode", -1, (char*const*)&a->Mode, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Source)
	{	int i;
		for (i = 0; i < (int)a->__sizeSource; i++)
			if (soap_out_tt__RecordingJobSource(soap, "tt:Source", -1, a->Source + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_in_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, struct tt__RecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	struct soap_blist *soap_blist_Source = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobMode(soap, "tt:Mode", (char**)&a->Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Priority", &a->Priority, "xsd:int"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Source", 1, NULL))
			{	if (a->Source == NULL)
				{	if (soap_blist_Source == NULL)
						soap_blist_Source = soap_alloc_block(soap);
					a->Source = (struct tt__RecordingJobSource *)soap_push_block_max(soap, soap_blist_Source, sizeof(struct tt__RecordingJobSource));
					if (a->Source == NULL)
						return NULL;
					soap_default_tt__RecordingJobSource(soap, a->Source);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobSource(soap, "tt:Source", a->Source, "tt:RecordingJobSource"))
				{	a->__sizeSource++;
					a->Source = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Source)
			soap_pop_block(soap, soap_blist_Source);
		if (a->__sizeSource)
		{	a->Source = (struct tt__RecordingJobSource *)soap_save_block(soap, soap_blist_Source, NULL, 1);
		}
		else
		{	a->Source = NULL;
			if (soap_blist_Source)
				soap_end_block(soap, soap_blist_Source);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_Mode > 0 || soap_flag_Priority > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfiguration, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_new_tt__RecordingJobConfiguration(struct soap *soap, int n)
{
	struct tt__RecordingJobConfiguration *p;
	struct tt__RecordingJobConfiguration *a = (struct tt__RecordingJobConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobConfiguration(struct soap *soap, const struct tt__RecordingJobConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobConfiguration(soap, tag ? tag : "tt:RecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_get_tt__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetTracksResponseItem(struct soap *soap, const struct tt__GetTracksResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetTracksResponseItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseItem), type))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "tt:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tt:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__TrackConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_in_tt__GetTracksResponseItem(struct soap *soap, const char *tag, struct tt__GetTracksResponseItem *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetTracksResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetTracksResponseItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:TrackConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken > 0 || soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseItem, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_new_tt__GetTracksResponseItem(struct soap *soap, int n)
{
	struct tt__GetTracksResponseItem *p;
	struct tt__GetTracksResponseItem *a = (struct tt__GetTracksResponseItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetTracksResponseItem));
	for (p = a; p && n--; p++)
		soap_default_tt__GetTracksResponseItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetTracksResponseItem(struct soap *soap, const struct tt__GetTracksResponseItem *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetTracksResponseItem(soap, tag ? tag : "tt:GetTracksResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_get_tt__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTrack = 0;
	a->Track = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetTracksResponseList(struct soap *soap, const struct tt__GetTracksResponseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__GetTracksResponseItem);
			soap_serialize_tt__GetTracksResponseItem(soap, a->Track + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseList(struct soap *soap, const char *tag, int id, const struct tt__GetTracksResponseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseList), type))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
			if (soap_out_tt__GetTracksResponseItem(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_in_tt__GetTracksResponseList(struct soap *soap, const char *tag, struct tt__GetTracksResponseList *a, const char *type)
{
	struct soap_blist *soap_blist_Track = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetTracksResponseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetTracksResponseList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_alloc_block(soap);
					a->Track = (struct tt__GetTracksResponseItem *)soap_push_block_max(soap, soap_blist_Track, sizeof(struct tt__GetTracksResponseItem));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__GetTracksResponseItem(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__GetTracksResponseItem(soap, "tt:Track", a->Track, "tt:GetTracksResponseItem"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
		{	a->Track = (struct tt__GetTracksResponseItem *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		}
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseList, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_new_tt__GetTracksResponseList(struct soap *soap, int n)
{
	struct tt__GetTracksResponseList *p;
	struct tt__GetTracksResponseList *a = (struct tt__GetTracksResponseList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetTracksResponseList));
	for (p = a; p && n--; p++)
		soap_default_tt__GetTracksResponseList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetTracksResponseList(struct soap *soap, const struct tt__GetTracksResponseList *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetTracksResponseList(soap, tag ? tag : "tt:GetTracksResponseList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_get_tt__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->Configuration = NULL;
	a->Tracks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetRecordingsResponseItem(struct soap *soap, const struct tt__GetRecordingsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->Configuration);
	soap_serialize_PointerTott__GetTracksResponseList(soap, &a->Tracks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetRecordingsResponseItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingsResponseItem), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tt:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (!a->Tracks)
	{	if (soap_element_nil(soap, "tt:Tracks"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__GetTracksResponseList(soap, "tt:Tracks", -1, &a->Tracks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingsResponseItem *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_Tracks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetRecordingsResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetRecordingsResponseItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:RecordingConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__GetTracksResponseList(soap, "tt:Tracks", &a->Tracks, "tt:GetTracksResponseList"))
				{	soap_flag_Tracks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_Configuration > 0 || soap_flag_Tracks > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__GetRecordingsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingsResponseItem, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_new_tt__GetRecordingsResponseItem(struct soap *soap, int n)
{
	struct tt__GetRecordingsResponseItem *p;
	struct tt__GetRecordingsResponseItem *a = (struct tt__GetRecordingsResponseItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetRecordingsResponseItem));
	for (p = a; p && n--; p++)
		soap_default_tt__GetRecordingsResponseItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetRecordingsResponseItem(struct soap *soap, const struct tt__GetRecordingsResponseItem *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetRecordingsResponseItem(soap, tag ? tag : "tt:GetRecordingsResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackType(soap, &a->TrackType);
	soap_default_tt__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackConfiguration(struct soap *soap, const struct tt__TrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackConfiguration(struct soap *soap, const char *tag, int id, const struct tt__TrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackConfiguration), type))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->TrackType, ""))
		return soap->error;
	if (!a->Description)
	{	if (soap_element_nil(soap, "tt:Description"))
			return soap->error;
	}
	else
	if (soap_out_tt__Description(soap, "tt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_in_tt__TrackConfiguration(struct soap *soap, const char *tag, struct tt__TrackConfiguration *a, const char *type)
{
	size_t soap_flag_TrackType = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->TrackType, "tt:TrackType"))
				{	soap_flag_TrackType--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackType > 0 || soap_flag_Description > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackConfiguration, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_new_tt__TrackConfiguration(struct soap *soap, int n)
{
	struct tt__TrackConfiguration *p;
	struct tt__TrackConfiguration *a = (struct tt__TrackConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackConfiguration(struct soap *soap, const struct tt__TrackConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackConfiguration(soap, tag ? tag : "tt:TrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_get_tt__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	soap_default_tt__Description(soap, &a->Content);
	soap_default_xsd__duration(soap, &a->MaximumRetentionTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingConfiguration(struct soap *soap, const struct tt__RecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &a->Source);
	soap_serialize_tt__Description(soap, (char*const*)&a->Content);
	soap_embedded(soap, &a->MaximumRetentionTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingConfiguration), type))
		return soap->error;
	if (!a->Source)
	{	if (soap_element_nil(soap, "tt:Source"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (!a->Content)
	{	if (soap_element_nil(soap, "tt:Content"))
			return soap->error;
	}
	else
	if (soap_out_tt__Description(soap, "tt:Content", -1, (char*const*)&a->Content, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:MaximumRetentionTime", -1, &a->MaximumRetentionTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_in_tt__RecordingConfiguration(struct soap *soap, const char *tag, struct tt__RecordingConfiguration *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Content = 1;
	size_t soap_flag_MaximumRetentionTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Content", (char**)&a->Content, "tt:Description"))
				{	soap_flag_Content--;
					continue;
				}
			if (soap_flag_MaximumRetentionTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:MaximumRetentionTime", &a->MaximumRetentionTime, "xsd:duration"))
				{	soap_flag_MaximumRetentionTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Source > 0 || soap_flag_Content > 0 || soap_flag_MaximumRetentionTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingConfiguration, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_new_tt__RecordingConfiguration(struct soap *soap, int n)
{
	struct tt__RecordingConfiguration *p;
	struct tt__RecordingConfiguration *a = (struct tt__RecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingConfiguration(struct soap *soap, const struct tt__RecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingConfiguration(soap, tag ? tag : "tt:RecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_get_tt__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackAttributesExtension(struct soap *soap, const struct tt__TrackAttributesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributesExtension(struct soap *soap, const char *tag, int id, const struct tt__TrackAttributesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_in_tt__TrackAttributesExtension(struct soap *soap, const char *tag, struct tt__TrackAttributesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackAttributesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackAttributesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributesExtension, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_new_tt__TrackAttributesExtension(struct soap *soap, int n)
{
	struct tt__TrackAttributesExtension *p;
	struct tt__TrackAttributesExtension *a = (struct tt__TrackAttributesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackAttributesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackAttributesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackAttributesExtension(struct soap *soap, const struct tt__TrackAttributesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackAttributesExtension(soap, tag ? tag : "tt:TrackAttributesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_get_tt__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->CanContainPTZ);
	soap_default_xsd__boolean(soap, &a->CanContainAnalytics);
	soap_default_xsd__boolean(soap, &a->CanContainNotifications);
	soap_default_tt__StringAttrList(soap, &a->PtzSpaces);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataAttributes(struct soap *soap, const struct tt__MetadataAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CanContainPTZ, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->CanContainAnalytics, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->CanContainNotifications, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataAttributes(struct soap *soap, const char *tag, int id, const struct tt__MetadataAttributes *a, const char *type)
{
	if (a->PtzSpaces)
		soap_set_attr(soap, "PtzSpaces", soap_tt__StringAttrList2s(soap, a->PtzSpaces), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataAttributes), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:CanContainPTZ", -1, &a->CanContainPTZ, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:CanContainAnalytics", -1, &a->CanContainAnalytics, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:CanContainNotifications", -1, &a->CanContainNotifications, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_in_tt__MetadataAttributes(struct soap *soap, const char *tag, struct tt__MetadataAttributes *a, const char *type)
{
	size_t soap_flag_CanContainPTZ = 1;
	size_t soap_flag_CanContainAnalytics = 1;
	size_t soap_flag_CanContainNotifications = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataAttributes(soap, a);
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "PtzSpaces", 0), &a->PtzSpaces))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanContainPTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:CanContainPTZ", &a->CanContainPTZ, "xsd:boolean"))
				{	soap_flag_CanContainPTZ--;
					continue;
				}
			if (soap_flag_CanContainAnalytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:CanContainAnalytics", &a->CanContainAnalytics, "xsd:boolean"))
				{	soap_flag_CanContainAnalytics--;
					continue;
				}
			if (soap_flag_CanContainNotifications && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:CanContainNotifications", &a->CanContainNotifications, "xsd:boolean"))
				{	soap_flag_CanContainNotifications--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanContainPTZ > 0 || soap_flag_CanContainAnalytics > 0 || soap_flag_CanContainNotifications > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MetadataAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataAttributes, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_new_tt__MetadataAttributes(struct soap *soap, int n)
{
	struct tt__MetadataAttributes *p;
	struct tt__MetadataAttributes *a = (struct tt__MetadataAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataAttributes(struct soap *soap, const struct tt__MetadataAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataAttributes(soap, tag ? tag : "tt:MetadataAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_get_tt__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	soap_default_int(soap, &a->Samplerate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAttributes(struct soap *soap, const struct tt__AudioAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Bitrate);
	soap_embedded(soap, &a->Samplerate, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAttributes(struct soap *soap, const char *tag, int id, const struct tt__AudioAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Samplerate", -1, &a->Samplerate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_in_tt__AudioAttributes(struct soap *soap, const char *tag, struct tt__AudioAttributes *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Samplerate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Samplerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Samplerate", &a->Samplerate, "xsd:int"))
				{	soap_flag_Samplerate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_Samplerate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAttributes, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_new_tt__AudioAttributes(struct soap *soap, int n)
{
	struct tt__AudioAttributes *p;
	struct tt__AudioAttributes *a = (struct tt__AudioAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAttributes(struct soap *soap, const struct tt__AudioAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioAttributes(soap, tag ? tag : "tt:AudioAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_get_tt__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
	soap_default_tt__VideoEncoding(soap, &a->Encoding);
	soap_default_float(soap, &a->Framerate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAttributes(struct soap *soap, const struct tt__VideoAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Bitrate);
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
	soap_embedded(soap, &a->Framerate, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAttributes(struct soap *soap, const char *tag, int id, const struct tt__VideoAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->Framerate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_in_tt__VideoAttributes(struct soap *soap, const char *tag, struct tt__VideoAttributes *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Framerate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Framerate", &a->Framerate, "xsd:float"))
				{	soap_flag_Framerate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0 || soap_flag_Encoding > 0 || soap_flag_Framerate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAttributes, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_new_tt__VideoAttributes(struct soap *soap, int n)
{
	struct tt__VideoAttributes *p;
	struct tt__VideoAttributes *a = (struct tt__VideoAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAttributes(struct soap *soap, const struct tt__VideoAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAttributes(soap, tag ? tag : "tt:VideoAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_get_tt__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TrackInformation = NULL;
	a->VideoAttributes = NULL;
	a->AudioAttributes = NULL;
	a->MetadataAttributes = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackAttributes(struct soap *soap, const struct tt__TrackAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TrackInformation(soap, &a->TrackInformation);
	soap_serialize_PointerTott__VideoAttributes(soap, &a->VideoAttributes);
	soap_serialize_PointerTott__AudioAttributes(soap, &a->AudioAttributes);
	soap_serialize_PointerTott__MetadataAttributes(soap, &a->MetadataAttributes);
	soap_serialize_PointerTott__TrackAttributesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributes(struct soap *soap, const char *tag, int id, const struct tt__TrackAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributes), type))
		return soap->error;
	if (!a->TrackInformation)
	{	if (soap_element_nil(soap, "tt:TrackInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__TrackInformation(soap, "tt:TrackInformation", -1, &a->TrackInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", -1, &a->VideoAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", -1, &a->AudioAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", -1, &a->MetadataAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__TrackAttributesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_in_tt__TrackAttributes(struct soap *soap, const char *tag, struct tt__TrackAttributes *a, const char *type)
{
	size_t soap_flag_TrackInformation = 1;
	size_t soap_flag_VideoAttributes = 1;
	size_t soap_flag_AudioAttributes = 1;
	size_t soap_flag_MetadataAttributes = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackInformation(soap, "tt:TrackInformation", &a->TrackInformation, "tt:TrackInformation"))
				{	soap_flag_TrackInformation--;
					continue;
				}
			if (soap_flag_VideoAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", &a->VideoAttributes, "tt:VideoAttributes"))
				{	soap_flag_VideoAttributes--;
					continue;
				}
			if (soap_flag_AudioAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", &a->AudioAttributes, "tt:AudioAttributes"))
				{	soap_flag_AudioAttributes--;
					continue;
				}
			if (soap_flag_MetadataAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", &a->MetadataAttributes, "tt:MetadataAttributes"))
				{	soap_flag_MetadataAttributes--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackAttributesExtension(soap, "tt:Extension", &a->Extension, "tt:TrackAttributesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TrackAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributes, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_new_tt__TrackAttributes(struct soap *soap, int n)
{
	struct tt__TrackAttributes *p;
	struct tt__TrackAttributes *a = (struct tt__TrackAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackAttributes(struct soap *soap, const struct tt__TrackAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackAttributes(soap, tag ? tag : "tt:TrackAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_get_tt__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->__sizeTrackAttributes = 0;
	a->TrackAttributes = NULL;
	soap_default_dateTime(soap, &a->From);
	soap_default_dateTime(soap, &a->Until);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaAttributes(struct soap *soap, const struct tt__MediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	if (a->TrackAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrackAttributes; i++)
		{
			soap_embedded(soap, a->TrackAttributes + i, SOAP_TYPE_tt__TrackAttributes);
			soap_serialize_tt__TrackAttributes(soap, a->TrackAttributes + i);
		}
	}
	soap_embedded(soap, &a->From, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->Until, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaAttributes(struct soap *soap, const char *tag, int id, const struct tt__MediaAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaAttributes), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (a->TrackAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrackAttributes; i++)
			if (soap_out_tt__TrackAttributes(soap, "tt:TrackAttributes", -1, a->TrackAttributes + i, ""))
				return soap->error;
	}
	if (soap_out_dateTime(soap, "tt:From", -1, &a->From, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Until", -1, &a->Until, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_in_tt__MediaAttributes(struct soap *soap, const char *tag, struct tt__MediaAttributes *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	struct soap_blist *soap_blist_TrackAttributes = NULL;
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TrackAttributes", 1, NULL))
			{	if (a->TrackAttributes == NULL)
				{	if (soap_blist_TrackAttributes == NULL)
						soap_blist_TrackAttributes = soap_alloc_block(soap);
					a->TrackAttributes = (struct tt__TrackAttributes *)soap_push_block_max(soap, soap_blist_TrackAttributes, sizeof(struct tt__TrackAttributes));
					if (a->TrackAttributes == NULL)
						return NULL;
					soap_default_tt__TrackAttributes(soap, a->TrackAttributes);
				}
				soap_revert(soap);
				if (soap_in_tt__TrackAttributes(soap, "tt:TrackAttributes", a->TrackAttributes, "tt:TrackAttributes"))
				{	a->__sizeTrackAttributes++;
					a->TrackAttributes = NULL;
					continue;
				}
			}
			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:From", &a->From, "xsd:dateTime"))
				{	soap_flag_From--;
					continue;
				}
			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:Until", &a->Until, "xsd:dateTime"))
				{	soap_flag_Until--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TrackAttributes)
			soap_pop_block(soap, soap_blist_TrackAttributes);
		if (a->__sizeTrackAttributes)
		{	a->TrackAttributes = (struct tt__TrackAttributes *)soap_save_block(soap, soap_blist_TrackAttributes, NULL, 1);
		}
		else
		{	a->TrackAttributes = NULL;
			if (soap_blist_TrackAttributes)
				soap_end_block(soap, soap_blist_TrackAttributes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_From > 0 || soap_flag_Until > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaAttributes, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_new_tt__MediaAttributes(struct soap *soap, int n)
{
	struct tt__MediaAttributes *p;
	struct tt__MediaAttributes *a = (struct tt__MediaAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaAttributes));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaAttributes(struct soap *soap, const struct tt__MediaAttributes *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaAttributes(soap, tag ? tag : "tt:MediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_get_tt__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackInformation(struct soap *soap, struct tt__TrackInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_tt__TrackType(soap, &a->TrackType);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_dateTime(soap, &a->DataFrom);
	soap_default_dateTime(soap, &a->DataTo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackInformation(struct soap *soap, const struct tt__TrackInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
	soap_embedded(soap, &a->DataFrom, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->DataTo, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackInformation(struct soap *soap, const char *tag, int id, const struct tt__TrackInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackInformation), type))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "tt:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->TrackType, ""))
		return soap->error;
	if (!a->Description)
	{	if (soap_element_nil(soap, "tt:Description"))
			return soap->error;
	}
	else
	if (soap_out_tt__Description(soap, "tt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataFrom", -1, &a->DataFrom, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataTo", -1, &a->DataTo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_in_tt__TrackInformation(struct soap *soap, const char *tag, struct tt__TrackInformation *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_TrackType = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_DataFrom = 1;
	size_t soap_flag_DataTo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->TrackType, "tt:TrackType"))
				{	soap_flag_TrackType--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:DataFrom", &a->DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom--;
					continue;
				}
			if (soap_flag_DataTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:DataTo", &a->DataTo, "xsd:dateTime"))
				{	soap_flag_DataTo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken > 0 || soap_flag_TrackType > 0 || soap_flag_Description > 0 || soap_flag_DataFrom > 0 || soap_flag_DataTo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TrackInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackInformation, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_new_tt__TrackInformation(struct soap *soap, int n)
{
	struct tt__TrackInformation *p;
	struct tt__TrackInformation *a = (struct tt__TrackInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TrackInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__TrackInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackInformation(struct soap *soap, const struct tt__TrackInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__TrackInformation(soap, tag ? tag : "tt:TrackInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_get_tt__TrackInformation(struct soap *soap, struct tt__TrackInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->SourceId);
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__Description(soap, &a->Location);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_xsd__anyURI(soap, &a->Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingSourceInformation(struct soap *soap, const struct tt__RecordingSourceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SourceId);
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_tt__Description(soap, (char*const*)&a->Location);
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSourceInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingSourceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSourceInformation), type))
		return soap->error;
	if (!a->SourceId)
	{	if (soap_element_nil(soap, "tt:SourceId"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:SourceId", -1, (char*const*)&a->SourceId, ""))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->Location)
	{	if (soap_element_nil(soap, "tt:Location"))
			return soap->error;
	}
	else
	if (soap_out_tt__Description(soap, "tt:Location", -1, (char*const*)&a->Location, ""))
		return soap->error;
	if (!a->Description)
	{	if (soap_element_nil(soap, "tt:Description"))
			return soap->error;
	}
	else
	if (soap_out_tt__Description(soap, "tt:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_nil(soap, "tt:Address"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_in_tt__RecordingSourceInformation(struct soap *soap, const char *tag, struct tt__RecordingSourceInformation *a, const char *type)
{
	size_t soap_flag_SourceId = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Location = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingSourceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingSourceInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:SourceId", (char**)&a->SourceId, "xsd:anyURI"))
				{	soap_flag_SourceId--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Location", (char**)&a->Location, "tt:Description"))
				{	soap_flag_Location--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:Address", (char**)&a->Address, "xsd:anyURI"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceId > 0 || soap_flag_Name > 0 || soap_flag_Location > 0 || soap_flag_Description > 0 || soap_flag_Address > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingSourceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSourceInformation, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_new_tt__RecordingSourceInformation(struct soap *soap, int n)
{
	struct tt__RecordingSourceInformation *p;
	struct tt__RecordingSourceInformation *a = (struct tt__RecordingSourceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingSourceInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingSourceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingSourceInformation(struct soap *soap, const struct tt__RecordingSourceInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingSourceInformation(soap, tag ? tag : "tt:RecordingSourceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_get_tt__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_dateTime(soap, &a->Time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindMetadataResult(struct soap *soap, const struct tt__FindMetadataResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResult(struct soap *soap, const char *tag, int id, const struct tt__FindMetadataResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResult), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "tt:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_in_tt__FindMetadataResult(struct soap *soap, const char *tag, struct tt__FindMetadataResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindMetadataResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindMetadataResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_Time > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResult, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_new_tt__FindMetadataResult(struct soap *soap, int n)
{
	struct tt__FindMetadataResult *p;
	struct tt__FindMetadataResult *a = (struct tt__FindMetadataResult*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindMetadataResult));
	for (p = a; p && n--; p++)
		soap_default_tt__FindMetadataResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindMetadataResult(struct soap *soap, const struct tt__FindMetadataResult *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindMetadataResult(soap, tag ? tag : "tt:FindMetadataResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_get_tt__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindMetadataResultList(struct soap *soap, const struct tt__FindMetadataResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindMetadataResult);
			soap_serialize_tt__FindMetadataResult(soap, a->Result + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResultList(struct soap *soap, const char *tag, int id, const struct tt__FindMetadataResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
			if (soap_out_tt__FindMetadataResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_in_tt__FindMetadataResultList(struct soap *soap, const char *tag, struct tt__FindMetadataResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindMetadataResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindMetadataResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_alloc_block(soap);
					a->Result = (struct tt__FindMetadataResult *)soap_push_block_max(soap, soap_blist_Result, sizeof(struct tt__FindMetadataResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindMetadataResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindMetadataResult(soap, "tt:Result", a->Result, "tt:FindMetadataResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
		{	a->Result = (struct tt__FindMetadataResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		}
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResultList, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_new_tt__FindMetadataResultList(struct soap *soap, int n)
{
	struct tt__FindMetadataResultList *p;
	struct tt__FindMetadataResultList *a = (struct tt__FindMetadataResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindMetadataResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindMetadataResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindMetadataResultList(struct soap *soap, const struct tt__FindMetadataResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindMetadataResultList(soap, tag ? tag : "tt:FindMetadataResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_get_tt__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_dateTime(soap, &a->Time);
	a->Position = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindPTZPositionResult(struct soap *soap, const struct tt__FindPTZPositionResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResult(struct soap *soap, const char *tag, int id, const struct tt__FindPTZPositionResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResult), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "tt:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_nil(soap, "tt:Position"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_in_tt__FindPTZPositionResult(struct soap *soap, const char *tag, struct tt__FindPTZPositionResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Position = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindPTZPositionResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindPTZPositionResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_Time > 0 || soap_flag_Position > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResult, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_new_tt__FindPTZPositionResult(struct soap *soap, int n)
{
	struct tt__FindPTZPositionResult *p;
	struct tt__FindPTZPositionResult *a = (struct tt__FindPTZPositionResult*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindPTZPositionResult));
	for (p = a; p && n--; p++)
		soap_default_tt__FindPTZPositionResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindPTZPositionResult(struct soap *soap, const struct tt__FindPTZPositionResult *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindPTZPositionResult(soap, tag ? tag : "tt:FindPTZPositionResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_get_tt__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindPTZPositionResultList(struct soap *soap, const struct tt__FindPTZPositionResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindPTZPositionResult);
			soap_serialize_tt__FindPTZPositionResult(soap, a->Result + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, int id, const struct tt__FindPTZPositionResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
			if (soap_out_tt__FindPTZPositionResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_in_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, struct tt__FindPTZPositionResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindPTZPositionResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindPTZPositionResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_alloc_block(soap);
					a->Result = (struct tt__FindPTZPositionResult *)soap_push_block_max(soap, soap_blist_Result, sizeof(struct tt__FindPTZPositionResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindPTZPositionResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindPTZPositionResult(soap, "tt:Result", a->Result, "tt:FindPTZPositionResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
		{	a->Result = (struct tt__FindPTZPositionResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		}
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResultList, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_new_tt__FindPTZPositionResultList(struct soap *soap, int n)
{
	struct tt__FindPTZPositionResultList *p;
	struct tt__FindPTZPositionResultList *a = (struct tt__FindPTZPositionResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindPTZPositionResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindPTZPositionResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindPTZPositionResultList(struct soap *soap, const struct tt__FindPTZPositionResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindPTZPositionResultList(soap, tag ? tag : "tt:FindPTZPositionResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_get_tt__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindEventResult(struct soap *soap, struct tt__FindEventResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_dateTime(soap, &a->Time);
	a->Event = NULL;
	soap_default_xsd__boolean(soap, &a->StartStateEvent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindEventResult(struct soap *soap, const struct tt__FindEventResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->Event);
	soap_embedded(soap, &a->StartStateEvent, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResult(struct soap *soap, const char *tag, int id, const struct tt__FindEventResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResult), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "tt:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (!a->Event)
	{	if (soap_element_nil(soap, "tt:Event"))
			return soap->error;
	}
	else
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", -1, &a->Event, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:StartStateEvent", -1, &a->StartStateEvent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_in_tt__FindEventResult(struct soap *soap, const char *tag, struct tt__FindEventResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Event = 1;
	size_t soap_flag_StartStateEvent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindEventResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindEventResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Event && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", &a->Event, "wsnt:NotificationMessageHolderType"))
				{	soap_flag_Event--;
					continue;
				}
			if (soap_flag_StartStateEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:StartStateEvent", &a->StartStateEvent, "xsd:boolean"))
				{	soap_flag_StartStateEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_Time > 0 || soap_flag_Event > 0 || soap_flag_StartStateEvent > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindEventResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResult, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_new_tt__FindEventResult(struct soap *soap, int n)
{
	struct tt__FindEventResult *p;
	struct tt__FindEventResult *a = (struct tt__FindEventResult*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindEventResult));
	for (p = a; p && n--; p++)
		soap_default_tt__FindEventResult(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindEventResult(struct soap *soap, const struct tt__FindEventResult *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindEventResult(soap, tag ? tag : "tt:FindEventResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_get_tt__FindEventResult(struct soap *soap, struct tt__FindEventResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindEventResultList(struct soap *soap, const struct tt__FindEventResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindEventResult);
			soap_serialize_tt__FindEventResult(soap, a->Result + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResultList(struct soap *soap, const char *tag, int id, const struct tt__FindEventResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < (int)a->__sizeResult; i++)
			if (soap_out_tt__FindEventResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_in_tt__FindEventResultList(struct soap *soap, const char *tag, struct tt__FindEventResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindEventResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindEventResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_alloc_block(soap);
					a->Result = (struct tt__FindEventResult *)soap_push_block_max(soap, soap_blist_Result, sizeof(struct tt__FindEventResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindEventResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindEventResult(soap, "tt:Result", a->Result, "tt:FindEventResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
		{	a->Result = (struct tt__FindEventResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		}
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindEventResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResultList, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_new_tt__FindEventResultList(struct soap *soap, int n)
{
	struct tt__FindEventResultList *p;
	struct tt__FindEventResultList *a = (struct tt__FindEventResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindEventResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindEventResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindEventResultList(struct soap *soap, const struct tt__FindEventResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindEventResultList(soap, tag ? tag : "tt:FindEventResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_get_tt__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->Source = NULL;
	a->EarliestRecording = NULL;
	a->LatestRecording = NULL;
	soap_default_tt__Description(soap, &a->Content);
	a->__sizeTrack = 0;
	a->Track = NULL;
	soap_default_tt__RecordingStatus(soap, &a->RecordingStatus);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingInformation(struct soap *soap, const struct tt__RecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &a->Source);
	soap_serialize_PointerTodateTime(soap, &a->EarliestRecording);
	soap_serialize_PointerTodateTime(soap, &a->LatestRecording);
	soap_serialize_tt__Description(soap, (char*const*)&a->Content);
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__TrackInformation);
			soap_serialize_tt__TrackInformation(soap, a->Track + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingInformation), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->Source)
	{	if (soap_element_nil(soap, "tt:Source"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tt:EarliestRecording", -1, &a->EarliestRecording, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tt:LatestRecording", -1, &a->LatestRecording, ""))
		return soap->error;
	if (!a->Content)
	{	if (soap_element_nil(soap, "tt:Content"))
			return soap->error;
	}
	else
	if (soap_out_tt__Description(soap, "tt:Content", -1, (char*const*)&a->Content, ""))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
			if (soap_out_tt__TrackInformation(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	if (soap_out_tt__RecordingStatus(soap, "tt:RecordingStatus", -1, &a->RecordingStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_in_tt__RecordingInformation(struct soap *soap, const char *tag, struct tt__RecordingInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Source = 1;
	size_t soap_flag_EarliestRecording = 1;
	size_t soap_flag_LatestRecording = 1;
	size_t soap_flag_Content = 1;
	struct soap_blist *soap_blist_Track = NULL;
	size_t soap_flag_RecordingStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_EarliestRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "tt:EarliestRecording", &a->EarliestRecording, "xsd:dateTime"))
				{	soap_flag_EarliestRecording--;
					continue;
				}
			if (soap_flag_LatestRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "tt:LatestRecording", &a->LatestRecording, "xsd:dateTime"))
				{	soap_flag_LatestRecording--;
					continue;
				}
			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Content", (char**)&a->Content, "tt:Description"))
				{	soap_flag_Content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_alloc_block(soap);
					a->Track = (struct tt__TrackInformation *)soap_push_block_max(soap, soap_blist_Track, sizeof(struct tt__TrackInformation));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__TrackInformation(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__TrackInformation(soap, "tt:Track", a->Track, "tt:TrackInformation"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap_flag_RecordingStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RecordingStatus(soap, "tt:RecordingStatus", &a->RecordingStatus, "tt:RecordingStatus"))
				{	soap_flag_RecordingStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
		{	a->Track = (struct tt__TrackInformation *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		}
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_Source > 0 || soap_flag_Content > 0 || soap_flag_RecordingStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingInformation, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_new_tt__RecordingInformation(struct soap *soap, int n)
{
	struct tt__RecordingInformation *p;
	struct tt__RecordingInformation *a = (struct tt__RecordingInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingInformation(struct soap *soap, const struct tt__RecordingInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingInformation(soap, tag ? tag : "tt:RecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_get_tt__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeRecordingInformation = 0;
	a->RecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindRecordingResultList(struct soap *soap, const struct tt__FindRecordingResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RecordingInformation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingInformation; i++)
		{
			soap_embedded(soap, a->RecordingInformation + i, SOAP_TYPE_tt__RecordingInformation);
			soap_serialize_tt__RecordingInformation(soap, a->RecordingInformation + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindRecordingResultList(struct soap *soap, const char *tag, int id, const struct tt__FindRecordingResultList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindRecordingResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->RecordingInformation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingInformation; i++)
			if (soap_out_tt__RecordingInformation(soap, "tt:RecordingInformation", -1, a->RecordingInformation + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_in_tt__FindRecordingResultList(struct soap *soap, const char *tag, struct tt__FindRecordingResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_RecordingInformation = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindRecordingResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindRecordingResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RecordingInformation", 1, NULL))
			{	if (a->RecordingInformation == NULL)
				{	if (soap_blist_RecordingInformation == NULL)
						soap_blist_RecordingInformation = soap_alloc_block(soap);
					a->RecordingInformation = (struct tt__RecordingInformation *)soap_push_block_max(soap, soap_blist_RecordingInformation, sizeof(struct tt__RecordingInformation));
					if (a->RecordingInformation == NULL)
						return NULL;
					soap_default_tt__RecordingInformation(soap, a->RecordingInformation);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingInformation(soap, "tt:RecordingInformation", a->RecordingInformation, "tt:RecordingInformation"))
				{	a->__sizeRecordingInformation++;
					a->RecordingInformation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingInformation)
			soap_pop_block(soap, soap_blist_RecordingInformation);
		if (a->__sizeRecordingInformation)
		{	a->RecordingInformation = (struct tt__RecordingInformation *)soap_save_block(soap, soap_blist_RecordingInformation, NULL, 1);
		}
		else
		{	a->RecordingInformation = NULL;
			if (soap_blist_RecordingInformation)
				soap_end_block(soap, soap_blist_RecordingInformation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FindRecordingResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindRecordingResultList, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_new_tt__FindRecordingResultList(struct soap *soap, int n)
{
	struct tt__FindRecordingResultList *p;
	struct tt__FindRecordingResultList *a = (struct tt__FindRecordingResultList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FindRecordingResultList));
	for (p = a; p && n--; p++)
		soap_default_tt__FindRecordingResultList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindRecordingResultList(struct soap *soap, const struct tt__FindRecordingResultList *a, const char *tag, const char *type)
{
	if (soap_out_tt__FindRecordingResultList(soap, tag ? tag : "tt:FindRecordingResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_get_tt__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindRecordingResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__XPathExpression(soap, &a->MetadataStreamFilter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataFilter(struct soap *soap, const struct tt__MetadataFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__XPathExpression(soap, (char*const*)&a->MetadataStreamFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataFilter(struct soap *soap, const char *tag, int id, const struct tt__MetadataFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataFilter), type))
		return soap->error;
	if (!a->MetadataStreamFilter)
	{	if (soap_element_nil(soap, "tt:MetadataStreamFilter"))
			return soap->error;
	}
	else
	if (soap_out_tt__XPathExpression(soap, "tt:MetadataStreamFilter", -1, (char*const*)&a->MetadataStreamFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_in_tt__MetadataFilter(struct soap *soap, const char *tag, struct tt__MetadataFilter *a, const char *type)
{
	size_t soap_flag_MetadataStreamFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MetadataStreamFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__XPathExpression(soap, "tt:MetadataStreamFilter", (char**)&a->MetadataStreamFilter, "tt:XPathExpression"))
				{	soap_flag_MetadataStreamFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MetadataStreamFilter > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MetadataFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataFilter, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_new_tt__MetadataFilter(struct soap *soap, int n)
{
	struct tt__MetadataFilter *p;
	struct tt__MetadataFilter *a = (struct tt__MetadataFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataFilter(struct soap *soap, const struct tt__MetadataFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataFilter(soap, tag ? tag : "tt:MetadataFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_get_tt__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MinPosition = NULL;
	a->MaxPosition = NULL;
	soap_default_xsd__boolean(soap, &a->EnterOrExit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPositionFilter(struct soap *soap, const struct tt__PTZPositionFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &a->MinPosition);
	soap_serialize_PointerTott__PTZVector(soap, &a->MaxPosition);
	soap_embedded(soap, &a->EnterOrExit, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPositionFilter(struct soap *soap, const char *tag, int id, const struct tt__PTZPositionFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPositionFilter), type))
		return soap->error;
	if (!a->MinPosition)
	{	if (soap_element_nil(soap, "tt:MinPosition"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZVector(soap, "tt:MinPosition", -1, &a->MinPosition, ""))
		return soap->error;
	if (!a->MaxPosition)
	{	if (soap_element_nil(soap, "tt:MaxPosition"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZVector(soap, "tt:MaxPosition", -1, &a->MaxPosition, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:EnterOrExit", -1, &a->EnterOrExit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_in_tt__PTZPositionFilter(struct soap *soap, const char *tag, struct tt__PTZPositionFilter *a, const char *type)
{
	size_t soap_flag_MinPosition = 1;
	size_t soap_flag_MaxPosition = 1;
	size_t soap_flag_EnterOrExit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPositionFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPositionFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:MinPosition", &a->MinPosition, "tt:PTZVector"))
				{	soap_flag_MinPosition--;
					continue;
				}
			if (soap_flag_MaxPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:MaxPosition", &a->MaxPosition, "tt:PTZVector"))
				{	soap_flag_MaxPosition--;
					continue;
				}
			if (soap_flag_EnterOrExit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:EnterOrExit", &a->EnterOrExit, "xsd:boolean"))
				{	soap_flag_EnterOrExit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MinPosition > 0 || soap_flag_MaxPosition > 0 || soap_flag_EnterOrExit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPositionFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPositionFilter, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_new_tt__PTZPositionFilter(struct soap *soap, int n)
{
	struct tt__PTZPositionFilter *p;
	struct tt__PTZPositionFilter *a = (struct tt__PTZPositionFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPositionFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPositionFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPositionFilter(struct soap *soap, const struct tt__PTZPositionFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPositionFilter(soap, tag ? tag : "tt:PTZPositionFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_get_tt__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPositionFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchScopeExtension(struct soap *soap, const struct tt__SearchScopeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScopeExtension(struct soap *soap, const char *tag, int id, const struct tt__SearchScopeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScopeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_in_tt__SearchScopeExtension(struct soap *soap, const char *tag, struct tt__SearchScopeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchScopeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchScopeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScopeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScopeExtension, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_new_tt__SearchScopeExtension(struct soap *soap, int n)
{
	struct tt__SearchScopeExtension *p;
	struct tt__SearchScopeExtension *a = (struct tt__SearchScopeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SearchScopeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SearchScopeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchScopeExtension(struct soap *soap, const struct tt__SearchScopeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SearchScopeExtension(soap, tag ? tag : "tt:SearchScopeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_get_tt__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchScope(struct soap *soap, struct tt__SearchScope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIncludedSources = 0;
	a->IncludedSources = NULL;
	a->__sizeIncludedRecordings = 0;
	a->IncludedRecordings = NULL;
	soap_default_tt__XPathExpression(soap, &a->RecordingInformationFilter);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchScope(struct soap *soap, const struct tt__SearchScope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IncludedSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedSources; i++)
		{
			soap_embedded(soap, a->IncludedSources + i, SOAP_TYPE_tt__SourceReference);
			soap_serialize_tt__SourceReference(soap, a->IncludedSources + i);
		}
	}
	if (a->IncludedRecordings)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedRecordings; i++)
		{
			soap_serialize_tt__RecordingReference(soap, (char*const*)(a->IncludedRecordings + i));
		}
	}
	soap_serialize_tt__XPathExpression(soap, (char*const*)&a->RecordingInformationFilter);
	soap_serialize_PointerTott__SearchScopeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScope(struct soap *soap, const char *tag, int id, const struct tt__SearchScope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScope), type))
		return soap->error;
	if (a->IncludedSources)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedSources; i++)
			if (soap_out_tt__SourceReference(soap, "tt:IncludedSources", -1, a->IncludedSources + i, ""))
				return soap->error;
	}
	if (a->IncludedRecordings)
	{	int i;
		for (i = 0; i < (int)a->__sizeIncludedRecordings; i++)
			soap_out_string(soap, "tt:IncludedRecordings", -1, (char*const*)(a->IncludedRecordings + i), "");
	}
	if (soap_out_tt__XPathExpression(soap, "tt:RecordingInformationFilter", -1, (char*const*)&a->RecordingInformationFilter, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchScopeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_in_tt__SearchScope(struct soap *soap, const char *tag, struct tt__SearchScope *a, const char *type)
{
	struct soap_blist *soap_blist_IncludedSources = NULL;
	struct soap_blist *soap_blist_IncludedRecordings = NULL;
	size_t soap_flag_RecordingInformationFilter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchScope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchScope(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedSources", 1, NULL))
			{	if (a->IncludedSources == NULL)
				{	if (soap_blist_IncludedSources == NULL)
						soap_blist_IncludedSources = soap_alloc_block(soap);
					a->IncludedSources = (struct tt__SourceReference *)soap_push_block_max(soap, soap_blist_IncludedSources, sizeof(struct tt__SourceReference));
					if (a->IncludedSources == NULL)
						return NULL;
					soap_default_tt__SourceReference(soap, a->IncludedSources);
				}
				soap_revert(soap);
				if (soap_in_tt__SourceReference(soap, "tt:IncludedSources", a->IncludedSources, "tt:SourceReference"))
				{	a->__sizeIncludedSources++;
					a->IncludedSources = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedRecordings", 1, NULL))
			{	if (a->IncludedRecordings == NULL)
				{	if (soap_blist_IncludedRecordings == NULL)
						soap_blist_IncludedRecordings = soap_alloc_block(soap);
					a->IncludedRecordings = (char **)soap_push_block_max(soap, soap_blist_IncludedRecordings, sizeof(char *));
					if (a->IncludedRecordings == NULL)
						return NULL;
					*a->IncludedRecordings = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingReference(soap, "tt:IncludedRecordings", (char**)a->IncludedRecordings, "tt:RecordingReference"))
				{	a->__sizeIncludedRecordings++;
					a->IncludedRecordings = NULL;
					continue;
				}
			}
			if (soap_flag_RecordingInformationFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__XPathExpression(soap, "tt:RecordingInformationFilter", (char**)&a->RecordingInformationFilter, "tt:XPathExpression"))
				{	soap_flag_RecordingInformationFilter--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScopeExtension(soap, "tt:Extension", &a->Extension, "tt:SearchScopeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IncludedSources)
			soap_pop_block(soap, soap_blist_IncludedSources);
		if (a->__sizeIncludedSources)
		{	a->IncludedSources = (struct tt__SourceReference *)soap_save_block(soap, soap_blist_IncludedSources, NULL, 1);
		}
		else
		{	a->IncludedSources = NULL;
			if (soap_blist_IncludedSources)
				soap_end_block(soap, soap_blist_IncludedSources);
		}
		if (a->IncludedRecordings)
			soap_pop_block(soap, soap_blist_IncludedRecordings);
		if (a->__sizeIncludedRecordings)
		{	a->IncludedRecordings = (char **)soap_save_block(soap, soap_blist_IncludedRecordings, NULL, 1);
		}
		else
		{	a->IncludedRecordings = NULL;
			if (soap_blist_IncludedRecordings)
				soap_end_block(soap, soap_blist_IncludedRecordings);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScope, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_new_tt__SearchScope(struct soap *soap, int n)
{
	struct tt__SearchScope *p;
	struct tt__SearchScope *a = (struct tt__SearchScope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SearchScope));
	for (p = a; p && n--; p++)
		soap_default_tt__SearchScope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchScope(struct soap *soap, const struct tt__SearchScope *a, const char *tag, const char *type)
{
	if (soap_out_tt__SearchScope(soap, tag ? tag : "tt:SearchScope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_get_tt__SearchScope(struct soap *soap, struct tt__SearchScope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->DataFrom);
	soap_default_dateTime(soap, &a->DataUntil);
	soap_default_int(soap, &a->NumberRecordings);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingSummary(struct soap *soap, const struct tt__RecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DataFrom, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->DataUntil, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->NumberRecordings, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSummary(struct soap *soap, const char *tag, int id, const struct tt__RecordingSummary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSummary), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataFrom", -1, &a->DataFrom, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:DataUntil", -1, &a->DataUntil, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:NumberRecordings", -1, &a->NumberRecordings, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_in_tt__RecordingSummary(struct soap *soap, const char *tag, struct tt__RecordingSummary *a, const char *type)
{
	size_t soap_flag_DataFrom = 1;
	size_t soap_flag_DataUntil = 1;
	size_t soap_flag_NumberRecordings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:DataFrom", &a->DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom--;
					continue;
				}
			if (soap_flag_DataUntil && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:DataUntil", &a->DataUntil, "xsd:dateTime"))
				{	soap_flag_DataUntil--;
					continue;
				}
			if (soap_flag_NumberRecordings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:NumberRecordings", &a->NumberRecordings, "xsd:int"))
				{	soap_flag_NumberRecordings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataFrom > 0 || soap_flag_DataUntil > 0 || soap_flag_NumberRecordings > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSummary, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_new_tt__RecordingSummary(struct soap *soap, int n)
{
	struct tt__RecordingSummary *p;
	struct tt__RecordingSummary *a = (struct tt__RecordingSummary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingSummary));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingSummary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingSummary(struct soap *soap, const struct tt__RecordingSummary *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingSummary(soap, tag ? tag : "tt:RecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_get_tt__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceReference(struct soap *soap, struct tt__SourceReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->Type = (char*)"http://www.onvif.org/ver10/schema/Receiver";
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceReference(struct soap *soap, const struct tt__SourceReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceReference(struct soap *soap, const char *tag, int id, const struct tt__SourceReference *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_xsd__anyURI2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceReference), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "tt:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_in_tt__SourceReference(struct soap *soap, const char *tag, struct tt__SourceReference *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SourceReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceReference(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SourceReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceReference, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_new_tt__SourceReference(struct soap *soap, int n)
{
	struct tt__SourceReference *p;
	struct tt__SourceReference *a = (struct tt__SourceReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceReference));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceReference(struct soap *soap, const struct tt__SourceReference *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceReference(soap, tag ? tag : "tt:SourceReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_get_tt__SourceReference(struct soap *soap, struct tt__SourceReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReceiverState(soap, &a->State);
	soap_default_xsd__boolean(soap, &a->AutoCreated);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverStateInformation(struct soap *soap, const struct tt__ReceiverStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AutoCreated, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverStateInformation(struct soap *soap, const char *tag, int id, const struct tt__ReceiverStateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverStateInformation), type))
		return soap->error;
	if (soap_out_tt__ReceiverState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoCreated", -1, &a->AutoCreated, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_in_tt__ReceiverStateInformation(struct soap *soap, const char *tag, struct tt__ReceiverStateInformation *a, const char *type)
{
	size_t soap_flag_State = 1;
	size_t soap_flag_AutoCreated = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverStateInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReceiverState(soap, "tt:State", &a->State, "tt:ReceiverState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap_flag_AutoCreated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AutoCreated", &a->AutoCreated, "xsd:boolean"))
				{	soap_flag_AutoCreated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0 || soap_flag_AutoCreated > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReceiverStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverStateInformation, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_new_tt__ReceiverStateInformation(struct soap *soap, int n)
{
	struct tt__ReceiverStateInformation *p;
	struct tt__ReceiverStateInformation *a = (struct tt__ReceiverStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReceiverStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverStateInformation(struct soap *soap, const struct tt__ReceiverStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverStateInformation(soap, tag ? tag : "tt:ReceiverStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_get_tt__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReceiverMode(soap, &a->Mode);
	soap_default_xsd__anyURI(soap, &a->MediaUri);
	a->StreamSetup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverConfiguration(struct soap *soap, const struct tt__ReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->MediaUri);
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverConfiguration(struct soap *soap, const char *tag, int id, const struct tt__ReceiverConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (!a->MediaUri)
	{	if (soap_element_nil(soap, "tt:MediaUri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:MediaUri", -1, (char*const*)&a->MediaUri, ""))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_nil(soap, "tt:StreamSetup"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__StreamSetup(soap, "tt:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_in_tt__ReceiverConfiguration(struct soap *soap, const char *tag, struct tt__ReceiverConfiguration *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_MediaUri = 1;
	size_t soap_flag_StreamSetup = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReceiverMode(soap, "tt:Mode", &a->Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_MediaUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:MediaUri", (char**)&a->MediaUri, "xsd:anyURI"))
				{	soap_flag_MediaUri--;
					continue;
				}
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "tt:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_MediaUri > 0 || soap_flag_StreamSetup > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverConfiguration, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_new_tt__ReceiverConfiguration(struct soap *soap, int n)
{
	struct tt__ReceiverConfiguration *p;
	struct tt__ReceiverConfiguration *a = (struct tt__ReceiverConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReceiverConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverConfiguration(struct soap *soap, const struct tt__ReceiverConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverConfiguration(soap, tag ? tag : "tt:ReceiverConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_get_tt__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Receiver(struct soap *soap, struct tt__Receiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Receiver(struct soap *soap, const struct tt__Receiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Receiver(struct soap *soap, const char *tag, int id, const struct tt__Receiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Receiver), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "tt:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tt:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_in_tt__Receiver(struct soap *soap, const char *tag, struct tt__Receiver *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Receiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Receiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Receiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Receiver, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_new_tt__Receiver(struct soap *soap, int n)
{
	struct tt__Receiver *p;
	struct tt__Receiver *a = (struct tt__Receiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Receiver));
	for (p = a; p && n--; p++)
		soap_default_tt__Receiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Receiver(struct soap *soap, const struct tt__Receiver *a, const char *tag, const char *type)
{
	if (soap_out_tt__Receiver(soap, tag ? tag : "tt:Receiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_get_tt__Receiver(struct soap *soap, struct tt__Receiver *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Receiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneOptionExtension(struct soap *soap, const struct tt__PaneOptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneOptionExtension(struct soap *soap, const char *tag, int id, const struct tt__PaneOptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneOptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_in_tt__PaneOptionExtension(struct soap *soap, const char *tag, struct tt__PaneOptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneOptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneOptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PaneOptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneOptionExtension, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_new_tt__PaneOptionExtension(struct soap *soap, int n)
{
	struct tt__PaneOptionExtension *p;
	struct tt__PaneOptionExtension *a = (struct tt__PaneOptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneOptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneOptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneOptionExtension(struct soap *soap, const struct tt__PaneOptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneOptionExtension(soap, tag ? tag : "tt:PaneOptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_get_tt__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutOptionsExtension(struct soap *soap, const struct tt__LayoutOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__LayoutOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_in_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, struct tt__LayoutOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LayoutOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptionsExtension, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_new_tt__LayoutOptionsExtension(struct soap *soap, int n)
{
	struct tt__LayoutOptionsExtension *p;
	struct tt__LayoutOptionsExtension *a = (struct tt__LayoutOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LayoutOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__LayoutOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutOptionsExtension(struct soap *soap, const struct tt__LayoutOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__LayoutOptionsExtension(soap, tag ? tag : "tt:LayoutOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_get_tt__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeArea = 0;
	a->Area = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneLayoutOptions(struct soap *soap, const struct tt__PaneLayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Area)
	{	int i;
		for (i = 0; i < (int)a->__sizeArea; i++)
		{
			soap_embedded(soap, a->Area + i, SOAP_TYPE_tt__Rectangle);
			soap_serialize_tt__Rectangle(soap, a->Area + i);
		}
	}
	soap_serialize_PointerTott__PaneOptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayoutOptions(struct soap *soap, const char *tag, int id, const struct tt__PaneLayoutOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayoutOptions), type))
		return soap->error;
	if (a->Area)
	{	int i;
		for (i = 0; i < (int)a->__sizeArea; i++)
			if (soap_out_tt__Rectangle(soap, "tt:Area", -1, a->Area + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PaneOptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_in_tt__PaneLayoutOptions(struct soap *soap, const char *tag, struct tt__PaneLayoutOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Area = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneLayoutOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneLayoutOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Area", 1, NULL))
			{	if (a->Area == NULL)
				{	if (soap_blist_Area == NULL)
						soap_blist_Area = soap_alloc_block(soap);
					a->Area = (struct tt__Rectangle *)soap_push_block_max(soap, soap_blist_Area, sizeof(struct tt__Rectangle));
					if (a->Area == NULL)
						return NULL;
					soap_default_tt__Rectangle(soap, a->Area);
				}
				soap_revert(soap);
				if (soap_in_tt__Rectangle(soap, "tt:Area", a->Area, "tt:Rectangle"))
				{	a->__sizeArea++;
					a->Area = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneOptionExtension(soap, "tt:Extension", &a->Extension, "tt:PaneOptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Area)
			soap_pop_block(soap, soap_blist_Area);
		if (a->__sizeArea)
		{	a->Area = (struct tt__Rectangle *)soap_save_block(soap, soap_blist_Area, NULL, 1);
		}
		else
		{	a->Area = NULL;
			if (soap_blist_Area)
				soap_end_block(soap, soap_blist_Area);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeArea < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PaneLayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayoutOptions, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_new_tt__PaneLayoutOptions(struct soap *soap, int n)
{
	struct tt__PaneLayoutOptions *p;
	struct tt__PaneLayoutOptions *a = (struct tt__PaneLayoutOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneLayoutOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneLayoutOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneLayoutOptions(struct soap *soap, const struct tt__PaneLayoutOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneLayoutOptions(soap, tag ? tag : "tt:PaneLayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_get_tt__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneLayoutOptions = 0;
	a->PaneLayoutOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutOptions(struct soap *soap, const struct tt__LayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PaneLayoutOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayoutOptions; i++)
		{
			soap_embedded(soap, a->PaneLayoutOptions + i, SOAP_TYPE_tt__PaneLayoutOptions);
			soap_serialize_tt__PaneLayoutOptions(soap, a->PaneLayoutOptions + i);
		}
	}
	soap_serialize_PointerTott__LayoutOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptions(struct soap *soap, const char *tag, int id, const struct tt__LayoutOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptions), type))
		return soap->error;
	if (a->PaneLayoutOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayoutOptions; i++)
			if (soap_out_tt__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", -1, a->PaneLayoutOptions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_in_tt__LayoutOptions(struct soap *soap, const char *tag, struct tt__LayoutOptions *a, const char *type)
{
	struct soap_blist *soap_blist_PaneLayoutOptions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LayoutOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayoutOptions", 1, NULL))
			{	if (a->PaneLayoutOptions == NULL)
				{	if (soap_blist_PaneLayoutOptions == NULL)
						soap_blist_PaneLayoutOptions = soap_alloc_block(soap);
					a->PaneLayoutOptions = (struct tt__PaneLayoutOptions *)soap_push_block_max(soap, soap_blist_PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions));
					if (a->PaneLayoutOptions == NULL)
						return NULL;
					soap_default_tt__PaneLayoutOptions(soap, a->PaneLayoutOptions);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", a->PaneLayoutOptions, "tt:PaneLayoutOptions"))
				{	a->__sizePaneLayoutOptions++;
					a->PaneLayoutOptions = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:LayoutOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneLayoutOptions)
			soap_pop_block(soap, soap_blist_PaneLayoutOptions);
		if (a->__sizePaneLayoutOptions)
		{	a->PaneLayoutOptions = (struct tt__PaneLayoutOptions *)soap_save_block(soap, soap_blist_PaneLayoutOptions, NULL, 1);
		}
		else
		{	a->PaneLayoutOptions = NULL;
			if (soap_blist_PaneLayoutOptions)
				soap_end_block(soap, soap_blist_PaneLayoutOptions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayoutOptions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__LayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptions, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_new_tt__LayoutOptions(struct soap *soap, int n)
{
	struct tt__LayoutOptions *p;
	struct tt__LayoutOptions *a = (struct tt__LayoutOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LayoutOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__LayoutOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutOptions(struct soap *soap, const struct tt__LayoutOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__LayoutOptions(soap, tag ? tag : "tt:LayoutOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_get_tt__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioEncodingCapabilities = NULL;
	a->AudioDecodingCapabilities = NULL;
	a->VideoDecodingCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CodingCapabilities(struct soap *soap, const struct tt__CodingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioEncoderConfigurationOptions(soap, &a->AudioEncodingCapabilities);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptions(soap, &a->AudioDecodingCapabilities);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptions(soap, &a->VideoDecodingCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CodingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__CodingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CodingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", -1, &a->AudioEncodingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", -1, &a->AudioDecodingCapabilities, ""))
		return soap->error;
	if (!a->VideoDecodingCapabilities)
	{	if (soap_element_nil(soap, "tt:VideoDecodingCapabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", -1, &a->VideoDecodingCapabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_in_tt__CodingCapabilities(struct soap *soap, const char *tag, struct tt__CodingCapabilities *a, const char *type)
{
	size_t soap_flag_AudioEncodingCapabilities = 1;
	size_t soap_flag_AudioDecodingCapabilities = 1;
	size_t soap_flag_VideoDecodingCapabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CodingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CodingCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioEncodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", &a->AudioEncodingCapabilities, "tt:AudioEncoderConfigurationOptions"))
				{	soap_flag_AudioEncodingCapabilities--;
					continue;
				}
			if (soap_flag_AudioDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", &a->AudioDecodingCapabilities, "tt:AudioDecoderConfigurationOptions"))
				{	soap_flag_AudioDecodingCapabilities--;
					continue;
				}
			if (soap_flag_VideoDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", &a->VideoDecodingCapabilities, "tt:VideoDecoderConfigurationOptions"))
				{	soap_flag_VideoDecodingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoDecodingCapabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CodingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CodingCapabilities, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_new_tt__CodingCapabilities(struct soap *soap, int n)
{
	struct tt__CodingCapabilities *p;
	struct tt__CodingCapabilities *a = (struct tt__CodingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CodingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__CodingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CodingCapabilities(struct soap *soap, const struct tt__CodingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__CodingCapabilities(soap, tag ? tag : "tt:CodingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_get_tt__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CodingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutExtension(struct soap *soap, const struct tt__LayoutExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutExtension(struct soap *soap, const char *tag, int id, const struct tt__LayoutExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_in_tt__LayoutExtension(struct soap *soap, const char *tag, struct tt__LayoutExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LayoutExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutExtension, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_new_tt__LayoutExtension(struct soap *soap, int n)
{
	struct tt__LayoutExtension *p;
	struct tt__LayoutExtension *a = (struct tt__LayoutExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__LayoutExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__LayoutExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutExtension(struct soap *soap, const struct tt__LayoutExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__LayoutExtension(soap, tag ? tag : "tt:LayoutExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_get_tt__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Layout(struct soap *soap, struct tt__Layout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneLayout = 0;
	a->PaneLayout = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Layout(struct soap *soap, const struct tt__Layout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PaneLayout)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayout; i++)
		{
			soap_embedded(soap, a->PaneLayout + i, SOAP_TYPE_tt__PaneLayout);
			soap_serialize_tt__PaneLayout(soap, a->PaneLayout + i);
		}
	}
	soap_serialize_PointerTott__LayoutExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Layout(struct soap *soap, const char *tag, int id, const struct tt__Layout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Layout), type))
		return soap->error;
	if (a->PaneLayout)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneLayout; i++)
			if (soap_out_tt__PaneLayout(soap, "tt:PaneLayout", -1, a->PaneLayout + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LayoutExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_in_tt__Layout(struct soap *soap, const char *tag, struct tt__Layout *a, const char *type)
{
	struct soap_blist *soap_blist_PaneLayout = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Layout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Layout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayout", 1, NULL))
			{	if (a->PaneLayout == NULL)
				{	if (soap_blist_PaneLayout == NULL)
						soap_blist_PaneLayout = soap_alloc_block(soap);
					a->PaneLayout = (struct tt__PaneLayout *)soap_push_block_max(soap, soap_blist_PaneLayout, sizeof(struct tt__PaneLayout));
					if (a->PaneLayout == NULL)
						return NULL;
					soap_default_tt__PaneLayout(soap, a->PaneLayout);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneLayout(soap, "tt:PaneLayout", a->PaneLayout, "tt:PaneLayout"))
				{	a->__sizePaneLayout++;
					a->PaneLayout = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LayoutExtension(soap, "tt:Extension", &a->Extension, "tt:LayoutExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneLayout)
			soap_pop_block(soap, soap_blist_PaneLayout);
		if (a->__sizePaneLayout)
		{	a->PaneLayout = (struct tt__PaneLayout *)soap_save_block(soap, soap_blist_PaneLayout, NULL, 1);
		}
		else
		{	a->PaneLayout = NULL;
			if (soap_blist_PaneLayout)
				soap_end_block(soap, soap_blist_PaneLayout);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayout < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Layout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Layout, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_new_tt__Layout(struct soap *soap, int n)
{
	struct tt__Layout *p;
	struct tt__Layout *a = (struct tt__Layout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Layout));
	for (p = a; p && n--; p++)
		soap_default_tt__Layout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Layout(struct soap *soap, const struct tt__Layout *a, const char *tag, const char *type)
{
	if (soap_out_tt__Layout(soap, tag ? tag : "tt:Layout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_get_tt__Layout(struct soap *soap, struct tt__Layout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneLayout(struct soap *soap, struct tt__PaneLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Pane);
	a->Area = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneLayout(struct soap *soap, const struct tt__PaneLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Pane);
	soap_serialize_PointerTott__Rectangle(soap, &a->Area);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayout(struct soap *soap, const char *tag, int id, const struct tt__PaneLayout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayout), type))
		return soap->error;
	if (!a->Pane)
	{	if (soap_element_nil(soap, "tt:Pane"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:Pane", -1, (char*const*)&a->Pane, ""))
		return soap->error;
	if (!a->Area)
	{	if (soap_element_nil(soap, "tt:Area"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Rectangle(soap, "tt:Area", -1, &a->Area, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_in_tt__PaneLayout(struct soap *soap, const char *tag, struct tt__PaneLayout *a, const char *type)
{
	size_t soap_flag_Pane = 1;
	size_t soap_flag_Area = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneLayout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Pane", (char**)&a->Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane--;
					continue;
				}
			if (soap_flag_Area && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:Area", &a->Area, "tt:Rectangle"))
				{	soap_flag_Area--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pane > 0 || soap_flag_Area > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PaneLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayout, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_new_tt__PaneLayout(struct soap *soap, int n)
{
	struct tt__PaneLayout *p;
	struct tt__PaneLayout *a = (struct tt__PaneLayout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneLayout));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneLayout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneLayout(struct soap *soap, const struct tt__PaneLayout *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneLayout(soap, tag ? tag : "tt:PaneLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_get_tt__PaneLayout(struct soap *soap, struct tt__PaneLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PaneName);
	soap_default_tt__ReferenceToken(soap, &a->AudioOutputToken);
	soap_default_tt__ReferenceToken(soap, &a->AudioSourceToken);
	a->AudioEncoderConfiguration = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneConfiguration(struct soap *soap, const struct tt__PaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->PaneName);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioOutputToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AudioSourceToken);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneConfiguration), type))
		return soap->error;
	if (soap_out_string(soap, "tt:PaneName", -1, (char*const*)&a->PaneName, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AudioOutputToken", -1, (char*const*)&a->AudioOutputToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AudioSourceToken", -1, (char*const*)&a->AudioSourceToken, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "tt:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_in_tt__PaneConfiguration(struct soap *soap, const char *tag, struct tt__PaneConfiguration *a, const char *type)
{
	size_t soap_flag_PaneName = 1;
	size_t soap_flag_AudioOutputToken = 1;
	size_t soap_flag_AudioSourceToken = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:PaneName", (char**)&a->PaneName, "xsd:string"))
				{	soap_flag_PaneName--;
					continue;
				}
			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:AudioOutputToken", (char**)&a->AudioOutputToken, "tt:ReferenceToken"))
				{	soap_flag_AudioOutputToken--;
					continue;
				}
			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:AudioSourceToken", (char**)&a->AudioSourceToken, "tt:ReferenceToken"))
				{	soap_flag_AudioSourceToken--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration--;
					continue;
				}
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneConfiguration, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_new_tt__PaneConfiguration(struct soap *soap, int n)
{
	struct tt__PaneConfiguration *p;
	struct tt__PaneConfiguration *a = (struct tt__PaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__PaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneConfiguration(struct soap *soap, const struct tt__PaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__PaneConfiguration(soap, tag ? tag : "tt:PaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_get_tt__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventStreamExtension(struct soap *soap, const struct tt__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__EventStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStreamExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_in_tt__EventStreamExtension(struct soap *soap, const char *tag, struct tt__EventStreamExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStreamExtension, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_new_tt__EventStreamExtension(struct soap *soap, int n)
{
	struct tt__EventStreamExtension *p;
	struct tt__EventStreamExtension *a = (struct tt__EventStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__EventStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventStreamExtension(struct soap *soap, const struct tt__EventStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventStreamExtension(soap, tag ? tag : "tt:EventStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_get_tt__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotificationMessageHolderType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", &a->Message, ""))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_new_wsnt__NotificationMessageHolderType(struct soap *soap, int n)
{
	struct wsnt__NotificationMessageHolderType *p;
	struct wsnt__NotificationMessageHolderType *a = (struct wsnt__NotificationMessageHolderType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__NotificationMessageHolderType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__NotificationMessageHolderType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_EventStream = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_EventStream(struct soap *soap, const struct __tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_EventStream(struct soap *soap, const char *tag, int id, const struct __tt__union_EventStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_in___tt__union_EventStream(struct soap *soap, const char *tag, struct __tt__union_EventStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_EventStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_EventStream, sizeof(struct __tt__union_EventStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_EventStream(soap, a);
		if (!soap_in__tt__union_EventStream(soap, &a->__union_EventStream, &a->union_EventStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_new___tt__union_EventStream(struct soap *soap, int n)
{
	struct __tt__union_EventStream *p;
	struct __tt__union_EventStream *a = (struct __tt__union_EventStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_EventStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_EventStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_EventStream(struct soap *soap, const struct __tt__union_EventStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_EventStream(soap, tag ? tag : "-tt:union-EventStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_get___tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStreamExtension(struct soap *soap, const struct tt__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStreamExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_in_tt__PTZStreamExtension(struct soap *soap, const char *tag, struct tt__PTZStreamExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStreamExtension, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_new_tt__PTZStreamExtension(struct soap *soap, int n)
{
	struct tt__PTZStreamExtension *p;
	struct tt__PTZStreamExtension *a = (struct tt__PTZStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStreamExtension(struct soap *soap, const struct tt__PTZStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStreamExtension(soap, tag ? tag : "tt:PTZStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_get_tt__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PTZStream = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_PTZStream(struct soap *soap, const struct __tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_PTZStream(struct soap *soap, const char *tag, int id, const struct __tt__union_PTZStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_in___tt__union_PTZStream(struct soap *soap, const char *tag, struct __tt__union_PTZStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_PTZStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_PTZStream, sizeof(struct __tt__union_PTZStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_PTZStream(soap, a);
		if (!soap_in__tt__union_PTZStream(soap, &a->__union_PTZStream, &a->union_PTZStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_new___tt__union_PTZStream(struct soap *soap, int n)
{
	struct __tt__union_PTZStream *p;
	struct __tt__union_PTZStream *a = (struct __tt__union_PTZStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_PTZStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_PTZStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_PTZStream(struct soap *soap, const struct __tt__union_PTZStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_PTZStream(soap, tag ? tag : "-tt:union-PTZStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_get___tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsStreamExtension(struct soap *soap, const struct tt__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAnalyticsStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_new_tt__VideoAnalyticsStreamExtension(struct soap *soap, int n)
{
	struct tt__VideoAnalyticsStreamExtension *p;
	struct tt__VideoAnalyticsStreamExtension *a = (struct tt__VideoAnalyticsStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAnalyticsStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAnalyticsStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsStreamExtension(struct soap *soap, const struct tt__VideoAnalyticsStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAnalyticsStreamExtension(soap, tag ? tag : "tt:VideoAnalyticsStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_VideoAnalyticsStream = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_VideoAnalyticsStream(struct soap *soap, const struct __tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct __tt__union_VideoAnalyticsStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __tt__union_VideoAnalyticsStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_VideoAnalyticsStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_VideoAnalyticsStream(soap, a);
		if (!soap_in__tt__union_VideoAnalyticsStream(soap, &a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_new___tt__union_VideoAnalyticsStream(struct soap *soap, int n)
{
	struct __tt__union_VideoAnalyticsStream *p;
	struct __tt__union_VideoAnalyticsStream *a = (struct __tt__union_VideoAnalyticsStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_VideoAnalyticsStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_VideoAnalyticsStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_VideoAnalyticsStream(struct soap *soap, const struct __tt__union_VideoAnalyticsStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_VideoAnalyticsStream(soap, tag ? tag : "-tt:union-VideoAnalyticsStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_get___tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
