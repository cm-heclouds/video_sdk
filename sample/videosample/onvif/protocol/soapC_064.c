/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResultList))
		soap_serialize_tt__FindEventResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResultList(struct soap *soap, const char *tag, int id, struct tt__FindEventResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResultList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindEventResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindEventResultList ** SOAP_FMAC4 soap_in_PointerTott__FindEventResultList(struct soap *soap, const char *tag, struct tt__FindEventResultList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindEventResultList **)soap_malloc(soap, sizeof(struct tt__FindEventResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindEventResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindEventResultList(soap, tag ? tag : "tt:FindEventResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResultList ** SOAP_FMAC4 soap_get_PointerTott__FindEventResultList(struct soap *soap, struct tt__FindEventResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventFilter(struct soap *soap, struct tt__EventFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventFilter))
		soap_serialize_tt__EventFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventFilter(struct soap *soap, const char *tag, int id, struct tt__EventFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventFilter ** SOAP_FMAC4 soap_in_PointerTott__EventFilter(struct soap *soap, const char *tag, struct tt__EventFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventFilter **)soap_malloc(soap, sizeof(struct tt__EventFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventFilter(struct soap *soap, struct tt__EventFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventFilter(soap, tag ? tag : "tt:EventFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventFilter ** SOAP_FMAC4 soap_get_PointerTott__EventFilter(struct soap *soap, struct tt__EventFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindRecordingResultList))
		soap_serialize_tt__FindRecordingResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindRecordingResultList(struct soap *soap, const char *tag, int id, struct tt__FindRecordingResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindRecordingResultList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindRecordingResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindRecordingResultList ** SOAP_FMAC4 soap_in_PointerTott__FindRecordingResultList(struct soap *soap, const char *tag, struct tt__FindRecordingResultList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindRecordingResultList **)soap_malloc(soap, sizeof(struct tt__FindRecordingResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindRecordingResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindRecordingResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindRecordingResultList(soap, tag ? tag : "tt:FindRecordingResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindRecordingResultList ** SOAP_FMAC4 soap_get_PointerTott__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindRecordingResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaAttributes))
		soap_serialize_tt__MediaAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaAttributes(struct soap *soap, const char *tag, int id, struct tt__MediaAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaAttributes ** SOAP_FMAC4 soap_in_PointerTott__MediaAttributes(struct soap *soap, const char *tag, struct tt__MediaAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaAttributes **)soap_malloc(soap, sizeof(struct tt__MediaAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaAttributes(soap, tag ? tag : "tt:MediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaAttributes ** SOAP_FMAC4 soap_get_PointerTott__MediaAttributes(struct soap *soap, struct tt__MediaAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSummary))
		soap_serialize_tt__RecordingSummary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSummary(struct soap *soap, const char *tag, int id, struct tt__RecordingSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSummary, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingSummary ** SOAP_FMAC4 soap_in_PointerTott__RecordingSummary(struct soap *soap, const char *tag, struct tt__RecordingSummary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingSummary **)soap_malloc(soap, sizeof(struct tt__RecordingSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingSummary(soap, tag ? tag : "tt:RecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSummary ** SOAP_FMAC4 soap_get_PointerTott__RecordingSummary(struct soap *soap, struct tt__RecordingSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotse__Capabilities(struct soap *soap, struct tse__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tse__Capabilities))
		soap_serialize_tse__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotse__Capabilities(struct soap *soap, const char *tag, int id, struct tse__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tse__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tse__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tse__Capabilities ** SOAP_FMAC4 soap_in_PointerTotse__Capabilities(struct soap *soap, const char *tag, struct tse__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tse__Capabilities **)soap_malloc(soap, sizeof(struct tse__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tse__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tse__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotse__Capabilities(struct soap *soap, struct tse__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotse__Capabilities(soap, tag ? tag : "tse:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tse__Capabilities ** SOAP_FMAC4 soap_get_PointerTotse__Capabilities(struct soap *soap, struct tse__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotse__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SpecialDayGroup(struct soap *soap, struct ns7__SpecialDayGroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SpecialDayGroup))
		soap_serialize_ns7__SpecialDayGroup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SpecialDayGroup(struct soap *soap, const char *tag, int id, struct ns7__SpecialDayGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SpecialDayGroup, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__SpecialDayGroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__SpecialDayGroup ** SOAP_FMAC4 soap_in_PointerTons7__SpecialDayGroup(struct soap *soap, const char *tag, struct ns7__SpecialDayGroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__SpecialDayGroup **)soap_malloc(soap, sizeof(struct ns7__SpecialDayGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__SpecialDayGroup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__SpecialDayGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SpecialDayGroup, sizeof(struct ns7__SpecialDayGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SpecialDayGroup(struct soap *soap, struct ns7__SpecialDayGroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SpecialDayGroup(soap, tag ? tag : "ns7:SpecialDayGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDayGroup ** SOAP_FMAC4 soap_get_PointerTons7__SpecialDayGroup(struct soap *soap, struct ns7__SpecialDayGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SpecialDayGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SpecialDayGroupInfo(struct soap *soap, struct ns7__SpecialDayGroupInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SpecialDayGroupInfo))
		soap_serialize_ns7__SpecialDayGroupInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SpecialDayGroupInfo(struct soap *soap, const char *tag, int id, struct ns7__SpecialDayGroupInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SpecialDayGroupInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__SpecialDayGroupInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__SpecialDayGroupInfo ** SOAP_FMAC4 soap_in_PointerTons7__SpecialDayGroupInfo(struct soap *soap, const char *tag, struct ns7__SpecialDayGroupInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__SpecialDayGroupInfo **)soap_malloc(soap, sizeof(struct ns7__SpecialDayGroupInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__SpecialDayGroupInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__SpecialDayGroupInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SpecialDayGroupInfo, sizeof(struct ns7__SpecialDayGroupInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SpecialDayGroupInfo(struct soap *soap, struct ns7__SpecialDayGroupInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SpecialDayGroupInfo(soap, tag ? tag : "ns7:SpecialDayGroupInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDayGroupInfo ** SOAP_FMAC4 soap_get_PointerTons7__SpecialDayGroupInfo(struct soap *soap, struct ns7__SpecialDayGroupInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SpecialDayGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__Schedule(struct soap *soap, struct ns7__Schedule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__Schedule))
		soap_serialize_ns7__Schedule(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__Schedule(struct soap *soap, const char *tag, int id, struct ns7__Schedule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__Schedule, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__Schedule(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__Schedule ** SOAP_FMAC4 soap_in_PointerTons7__Schedule(struct soap *soap, const char *tag, struct ns7__Schedule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__Schedule **)soap_malloc(soap, sizeof(struct ns7__Schedule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__Schedule(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__Schedule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__Schedule, sizeof(struct ns7__Schedule), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__Schedule(struct soap *soap, struct ns7__Schedule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__Schedule(soap, tag ? tag : "ns7:Schedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__Schedule ** SOAP_FMAC4 soap_get_PointerTons7__Schedule(struct soap *soap, struct ns7__Schedule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__Schedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ScheduleInfo(struct soap *soap, struct ns7__ScheduleInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ScheduleInfo))
		soap_serialize_ns7__ScheduleInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ScheduleInfo(struct soap *soap, const char *tag, int id, struct ns7__ScheduleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ScheduleInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__ScheduleInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__ScheduleInfo ** SOAP_FMAC4 soap_in_PointerTons7__ScheduleInfo(struct soap *soap, const char *tag, struct ns7__ScheduleInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__ScheduleInfo **)soap_malloc(soap, sizeof(struct ns7__ScheduleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__ScheduleInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__ScheduleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ScheduleInfo, sizeof(struct ns7__ScheduleInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ScheduleInfo(struct soap *soap, struct ns7__ScheduleInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__ScheduleInfo(soap, tag ? tag : "ns7:ScheduleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleInfo ** SOAP_FMAC4 soap_get_PointerTons7__ScheduleInfo(struct soap *soap, struct ns7__ScheduleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ScheduleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ScheduleState(struct soap *soap, struct ns7__ScheduleState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ScheduleState))
		soap_serialize_ns7__ScheduleState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ScheduleState(struct soap *soap, const char *tag, int id, struct ns7__ScheduleState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ScheduleState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__ScheduleState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__ScheduleState ** SOAP_FMAC4 soap_in_PointerTons7__ScheduleState(struct soap *soap, const char *tag, struct ns7__ScheduleState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__ScheduleState **)soap_malloc(soap, sizeof(struct ns7__ScheduleState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__ScheduleState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__ScheduleState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ScheduleState, sizeof(struct ns7__ScheduleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ScheduleState(struct soap *soap, struct ns7__ScheduleState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__ScheduleState(soap, tag ? tag : "ns7:ScheduleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleState ** SOAP_FMAC4 soap_get_PointerTons7__ScheduleState(struct soap *soap, struct ns7__ScheduleState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ScheduleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ServiceCapabilities(struct soap *soap, struct ns7__ServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ServiceCapabilities))
		soap_serialize_ns7__ServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ServiceCapabilities(struct soap *soap, const char *tag, int id, struct ns7__ServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__ServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__ServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTons7__ServiceCapabilities(struct soap *soap, const char *tag, struct ns7__ServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__ServiceCapabilities **)soap_malloc(soap, sizeof(struct ns7__ServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__ServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__ServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ServiceCapabilities, sizeof(struct ns7__ServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ServiceCapabilities(struct soap *soap, struct ns7__ServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__ServiceCapabilities(soap, tag ? tag : "ns7:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTons7__ServiceCapabilities(struct soap *soap, struct ns7__ServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__TimePeriodExtension(struct soap *soap, struct ns7__TimePeriodExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__TimePeriodExtension))
		soap_serialize_ns7__TimePeriodExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__TimePeriodExtension(struct soap *soap, const char *tag, int id, struct ns7__TimePeriodExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__TimePeriodExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__TimePeriodExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__TimePeriodExtension ** SOAP_FMAC4 soap_in_PointerTons7__TimePeriodExtension(struct soap *soap, const char *tag, struct ns7__TimePeriodExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__TimePeriodExtension **)soap_malloc(soap, sizeof(struct ns7__TimePeriodExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__TimePeriodExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__TimePeriodExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__TimePeriodExtension, sizeof(struct ns7__TimePeriodExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__TimePeriodExtension(struct soap *soap, struct ns7__TimePeriodExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__TimePeriodExtension(soap, tag ? tag : "ns7:TimePeriodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__TimePeriodExtension ** SOAP_FMAC4 soap_get_PointerTons7__TimePeriodExtension(struct soap *soap, struct ns7__TimePeriodExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__TimePeriodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__ScheduleStateExtension(struct soap *soap, struct ns7__ScheduleStateExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__ScheduleStateExtension))
		soap_serialize_ns7__ScheduleStateExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__ScheduleStateExtension(struct soap *soap, const char *tag, int id, struct ns7__ScheduleStateExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__ScheduleStateExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__ScheduleStateExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__ScheduleStateExtension ** SOAP_FMAC4 soap_in_PointerTons7__ScheduleStateExtension(struct soap *soap, const char *tag, struct ns7__ScheduleStateExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__ScheduleStateExtension **)soap_malloc(soap, sizeof(struct ns7__ScheduleStateExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__ScheduleStateExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__ScheduleStateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__ScheduleStateExtension, sizeof(struct ns7__ScheduleStateExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__ScheduleStateExtension(struct soap *soap, struct ns7__ScheduleStateExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__ScheduleStateExtension(soap, tag ? tag : "ns7:ScheduleStateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleStateExtension ** SOAP_FMAC4 soap_get_PointerTons7__ScheduleStateExtension(struct soap *soap, struct ns7__ScheduleStateExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__ScheduleStateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__SpecialDaysScheduleExtension(struct soap *soap, struct ns7__SpecialDaysScheduleExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__SpecialDaysScheduleExtension))
		soap_serialize_ns7__SpecialDaysScheduleExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__SpecialDaysScheduleExtension(struct soap *soap, const char *tag, int id, struct ns7__SpecialDaysScheduleExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__SpecialDaysScheduleExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__SpecialDaysScheduleExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__SpecialDaysScheduleExtension ** SOAP_FMAC4 soap_in_PointerTons7__SpecialDaysScheduleExtension(struct soap *soap, const char *tag, struct ns7__SpecialDaysScheduleExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__SpecialDaysScheduleExtension **)soap_malloc(soap, sizeof(struct ns7__SpecialDaysScheduleExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__SpecialDaysScheduleExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__SpecialDaysScheduleExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__SpecialDaysScheduleExtension, sizeof(struct ns7__SpecialDaysScheduleExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__SpecialDaysScheduleExtension(struct soap *soap, struct ns7__SpecialDaysScheduleExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__SpecialDaysScheduleExtension(soap, tag ? tag : "ns7:SpecialDaysScheduleExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDaysScheduleExtension ** SOAP_FMAC4 soap_get_PointerTons7__SpecialDaysScheduleExtension(struct soap *soap, struct ns7__SpecialDaysScheduleExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__SpecialDaysScheduleExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__TimePeriod(struct soap *soap, struct ns7__TimePeriod *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__TimePeriod))
		soap_serialize_ns7__TimePeriod(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__TimePeriod(struct soap *soap, const char *tag, int id, struct ns7__TimePeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__TimePeriod, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns7__TimePeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns7__TimePeriod ** SOAP_FMAC4 soap_in_PointerTons7__TimePeriod(struct soap *soap, const char *tag, struct ns7__TimePeriod **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns7__TimePeriod **)soap_malloc(soap, sizeof(struct ns7__TimePeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns7__TimePeriod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns7__TimePeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__TimePeriod, sizeof(struct ns7__TimePeriod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__TimePeriod(struct soap *soap, struct ns7__TimePeriod *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons7__TimePeriod(soap, tag ? tag : "ns7:TimePeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__TimePeriod ** SOAP_FMAC4 soap_get_PointerTons7__TimePeriod(struct soap *soap, struct ns7__TimePeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__TimePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayConfiguration))
		soap_serialize_tt__ReplayConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayConfiguration(struct soap *soap, const char *tag, int id, struct tt__ReplayConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReplayConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReplayConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ReplayConfiguration(struct soap *soap, const char *tag, struct tt__ReplayConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReplayConfiguration **)soap_malloc(soap, sizeof(struct tt__ReplayConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReplayConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReplayConfiguration(soap, tag ? tag : "tt:ReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrp__Capabilities(struct soap *soap, struct trp__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trp__Capabilities))
		soap_serialize_trp__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrp__Capabilities(struct soap *soap, const char *tag, int id, struct trp__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trp__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trp__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trp__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrp__Capabilities(struct soap *soap, const char *tag, struct trp__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trp__Capabilities **)soap_malloc(soap, sizeof(struct trp__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trp__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trp__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrp__Capabilities(struct soap *soap, struct trp__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrp__Capabilities(soap, tag ? tag : "trp:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trp__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrp__Capabilities(struct soap *soap, struct trp__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrp__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ArrayOfFileProgress))
		soap_serialize_tt__ArrayOfFileProgress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ArrayOfFileProgress(struct soap *soap, const char *tag, int id, struct tt__ArrayOfFileProgress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ArrayOfFileProgress, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ArrayOfFileProgress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress ** SOAP_FMAC4 soap_in_PointerTott__ArrayOfFileProgress(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ArrayOfFileProgress **)soap_malloc(soap, sizeof(struct tt__ArrayOfFileProgress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ArrayOfFileProgress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ArrayOfFileProgress(soap, tag ? tag : "tt:ArrayOfFileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress ** SOAP_FMAC4 soap_get_PointerTott__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ArrayOfFileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension))
		soap_serialize__trc__ExportRecordedDataResponse_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__ExportRecordedDataResponse_Extension(struct soap *soap, const char *tag, int id, struct _trc__ExportRecordedDataResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__ExportRecordedDataResponse_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_trc__ExportRecordedDataResponse_Extension(struct soap *soap, const char *tag, struct _trc__ExportRecordedDataResponse_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__ExportRecordedDataResponse_Extension **)soap_malloc(soap, sizeof(struct _trc__ExportRecordedDataResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__ExportRecordedDataResponse_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedDataResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, tag ? tag : "trc:ExportRecordedDataResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StorageReferencePath))
		soap_serialize_tt__StorageReferencePath(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StorageReferencePath(struct soap *soap, const char *tag, int id, struct tt__StorageReferencePath *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StorageReferencePath, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StorageReferencePath(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StorageReferencePath ** SOAP_FMAC4 soap_in_PointerTott__StorageReferencePath(struct soap *soap, const char *tag, struct tt__StorageReferencePath **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StorageReferencePath **)soap_malloc(soap, sizeof(struct tt__StorageReferencePath *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StorageReferencePath(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StorageReferencePath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StorageReferencePath(soap, tag ? tag : "tt:StorageReferencePath", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StorageReferencePath ** SOAP_FMAC4 soap_get_PointerTott__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StorageReferencePath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScope(struct soap *soap, struct tt__SearchScope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScope))
		soap_serialize_tt__SearchScope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScope(struct soap *soap, const char *tag, int id, struct tt__SearchScope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScope, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchScope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchScope ** SOAP_FMAC4 soap_in_PointerTott__SearchScope(struct soap *soap, const char *tag, struct tt__SearchScope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchScope **)soap_malloc(soap, sizeof(struct tt__SearchScope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchScope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScope(struct soap *soap, struct tt__SearchScope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchScope(soap, tag ? tag : "tt:SearchScope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScope ** SOAP_FMAC4 soap_get_PointerTott__SearchScope(struct soap *soap, struct tt__SearchScope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__RecordingOptions))
		soap_serialize_trc__RecordingOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__RecordingOptions(struct soap *soap, const char *tag, int id, struct trc__RecordingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__RecordingOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trc__RecordingOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__RecordingOptions ** SOAP_FMAC4 soap_in_PointerTotrc__RecordingOptions(struct soap *soap, const char *tag, struct trc__RecordingOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__RecordingOptions **)soap_malloc(soap, sizeof(struct trc__RecordingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__RecordingOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__RecordingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrc__RecordingOptions(soap, tag ? tag : "trc:RecordingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__RecordingOptions ** SOAP_FMAC4 soap_get_PointerTotrc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__RecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformation))
		soap_serialize_tt__RecordingJobStateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformation(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateInformation **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingJobStateInformation(soap, tag ? tag : "tt:RecordingJobStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetRecordingJobsResponseItem))
		soap_serialize_tt__GetRecordingJobsResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetRecordingJobsResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetRecordingJobsResponseItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetRecordingJobsResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingJobsResponseItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetRecordingJobsResponseItem **)soap_malloc(soap, sizeof(struct tt__GetRecordingJobsResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetRecordingJobsResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetRecordingJobsResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetRecordingJobsResponseItem(soap, tag ? tag : "tt:GetRecordingJobsResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetRecordingJobsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetRecordingsResponseItem))
		soap_serialize_tt__GetRecordingsResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetRecordingsResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetRecordingsResponseItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetRecordingsResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetRecordingsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingsResponseItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetRecordingsResponseItem **)soap_malloc(soap, sizeof(struct tt__GetRecordingsResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetRecordingsResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetRecordingsResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GetRecordingsResponseItem(soap, tag ? tag : "tt:GetRecordingsResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetRecordingsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__Capabilities(struct soap *soap, struct trc__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__Capabilities))
		soap_serialize_trc__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__Capabilities(struct soap *soap, const char *tag, int id, struct trc__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trc__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrc__Capabilities(struct soap *soap, const char *tag, struct trc__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__Capabilities **)soap_malloc(soap, sizeof(struct trc__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__Capabilities(struct soap *soap, struct trc__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrc__Capabilities(soap, tag ? tag : "trc:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrc__Capabilities(struct soap *soap, struct trc__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__TrackOptions(struct soap *soap, struct trc__TrackOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__TrackOptions))
		soap_serialize_trc__TrackOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__TrackOptions(struct soap *soap, const char *tag, int id, struct trc__TrackOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__TrackOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trc__TrackOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__TrackOptions ** SOAP_FMAC4 soap_in_PointerTotrc__TrackOptions(struct soap *soap, const char *tag, struct trc__TrackOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__TrackOptions **)soap_malloc(soap, sizeof(struct trc__TrackOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__TrackOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__TrackOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__TrackOptions(struct soap *soap, struct trc__TrackOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrc__TrackOptions(soap, tag ? tag : "trc:TrackOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__TrackOptions ** SOAP_FMAC4 soap_get_PointerTotrc__TrackOptions(struct soap *soap, struct trc__TrackOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__TrackOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__JobOptions(struct soap *soap, struct trc__JobOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__JobOptions))
		soap_serialize_trc__JobOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__JobOptions(struct soap *soap, const char *tag, int id, struct trc__JobOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__JobOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trc__JobOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__JobOptions ** SOAP_FMAC4 soap_in_PointerTotrc__JobOptions(struct soap *soap, const char *tag, struct trc__JobOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__JobOptions **)soap_malloc(soap, sizeof(struct trc__JobOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__JobOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__JobOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__JobOptions(struct soap *soap, struct trc__JobOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrc__JobOptions(soap, tag ? tag : "trc:JobOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__JobOptions ** SOAP_FMAC4 soap_get_PointerTotrc__JobOptions(struct soap *soap, struct trc__JobOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__JobOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverStateInformation))
		soap_serialize_tt__ReceiverStateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverStateInformation(struct soap *soap, const char *tag, int id, struct tt__ReceiverStateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverStateInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverStateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation ** SOAP_FMAC4 soap_in_PointerTott__ReceiverStateInformation(struct soap *soap, const char *tag, struct tt__ReceiverStateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverStateInformation **)soap_malloc(soap, sizeof(struct tt__ReceiverStateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverStateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverStateInformation(soap, tag ? tag : "tt:ReceiverStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation ** SOAP_FMAC4 soap_get_PointerTott__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Receiver(struct soap *soap, struct tt__Receiver *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Receiver))
		soap_serialize_tt__Receiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Receiver(struct soap *soap, const char *tag, int id, struct tt__Receiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Receiver, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Receiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Receiver ** SOAP_FMAC4 soap_in_PointerTott__Receiver(struct soap *soap, const char *tag, struct tt__Receiver **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Receiver **)soap_malloc(soap, sizeof(struct tt__Receiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Receiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Receiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Receiver(struct soap *soap, struct tt__Receiver *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Receiver(soap, tag ? tag : "tt:Receiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Receiver ** SOAP_FMAC4 soap_get_PointerTott__Receiver(struct soap *soap, struct tt__Receiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Receiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrv__Capabilities(struct soap *soap, struct trv__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trv__Capabilities))
		soap_serialize_trv__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrv__Capabilities(struct soap *soap, const char *tag, int id, struct trv__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trv__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_trv__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trv__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrv__Capabilities(struct soap *soap, const char *tag, struct trv__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trv__Capabilities **)soap_malloc(soap, sizeof(struct trv__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trv__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trv__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrv__Capabilities(struct soap *soap, struct trv__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrv__Capabilities(soap, tag ? tag : "trv:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trv__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrv__Capabilities(struct soap *soap, struct trv__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrv__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourOptions))
		soap_serialize_tt__PTZPresetTourOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourOptions(soap, tag ? tag : "tt:PTZPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PresetTour(struct soap *soap, struct tt__PresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PresetTour))
		soap_serialize_tt__PresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PresetTour(struct soap *soap, const char *tag, int id, struct tt__PresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PresetTour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PresetTour ** SOAP_FMAC4 soap_in_PointerTott__PresetTour(struct soap *soap, const char *tag, struct tt__PresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PresetTour **)soap_malloc(soap, sizeof(struct tt__PresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PresetTour(struct soap *soap, struct tt__PresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PresetTour(soap, tag ? tag : "tt:PresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PresetTour ** SOAP_FMAC4 soap_get_PointerTott__PresetTour(struct soap *soap, struct tt__PresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPreset(struct soap *soap, struct tt__PTZPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPreset))
		soap_serialize_tt__PTZPreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPreset(struct soap *soap, const char *tag, int id, struct tt__PTZPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPreset, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPreset ** SOAP_FMAC4 soap_in_PointerTott__PTZPreset(struct soap *soap, const char *tag, struct tt__PTZPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPreset **)soap_malloc(soap, sizeof(struct tt__PTZPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPreset(struct soap *soap, struct tt__PTZPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPreset ** SOAP_FMAC4 soap_get_PointerTott__PTZPreset(struct soap *soap, struct tt__PTZPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions))
		soap_serialize_tt__PTZConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationOptions(soap, tag ? tag : "tt:PTZConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence))
		soap_serialize___tptz__SetConfigurationResponse_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, struct __tptz__SetConfigurationResponse_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___tptz__SetConfigurationResponse_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tptz__SetConfigurationResponse_sequence **)soap_malloc(soap, sizeof(struct __tptz__SetConfigurationResponse_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tptz__SetConfigurationResponse_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag ? tag : "-tptz:SetConfigurationResponse-sequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_get_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNode(struct soap *soap, struct tt__PTZNode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNode))
		soap_serialize_tt__PTZNode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNode(struct soap *soap, const char *tag, int id, struct tt__PTZNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNode ** SOAP_FMAC4 soap_in_PointerTott__PTZNode(struct soap *soap, const char *tag, struct tt__PTZNode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNode **)soap_malloc(soap, sizeof(struct tt__PTZNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNode(struct soap *soap, struct tt__PTZNode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNode ** SOAP_FMAC4 soap_get_PointerTott__PTZNode(struct soap *soap, struct tt__PTZNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotptz__Capabilities(struct soap *soap, struct tptz__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tptz__Capabilities))
		soap_serialize_tptz__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotptz__Capabilities(struct soap *soap, const char *tag, int id, struct tptz__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tptz__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tptz__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tptz__Capabilities ** SOAP_FMAC4 soap_in_PointerTotptz__Capabilities(struct soap *soap, const char *tag, struct tptz__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tptz__Capabilities **)soap_malloc(soap, sizeof(struct tptz__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tptz__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tptz__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotptz__Capabilities(struct soap *soap, struct tptz__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotptz__Capabilities(soap, tag ? tag : "tptz:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tptz__Capabilities ** SOAP_FMAC4 soap_get_PointerTotptz__Capabilities(struct soap *soap, struct tptz__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__VideoSourceMode(struct soap *soap, struct ns6__VideoSourceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__VideoSourceMode))
		soap_serialize_ns6__VideoSourceMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__VideoSourceMode(struct soap *soap, const char *tag, int id, struct ns6__VideoSourceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__VideoSourceMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__VideoSourceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__VideoSourceMode ** SOAP_FMAC4 soap_in_PointerTons6__VideoSourceMode(struct soap *soap, const char *tag, struct ns6__VideoSourceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__VideoSourceMode **)soap_malloc(soap, sizeof(struct ns6__VideoSourceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__VideoSourceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__VideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__VideoSourceMode, sizeof(struct ns6__VideoSourceMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__VideoSourceMode(struct soap *soap, struct ns6__VideoSourceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__VideoSourceMode(soap, tag ? tag : "ns6:VideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__VideoSourceMode ** SOAP_FMAC4 soap_get_PointerTons6__VideoSourceMode(struct soap *soap, struct ns6__VideoSourceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__VideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EncoderInstanceInfo(struct soap *soap, struct ns6__EncoderInstanceInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__EncoderInstanceInfo))
		soap_serialize_ns6__EncoderInstanceInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__EncoderInstanceInfo(struct soap *soap, const char *tag, int id, struct ns6__EncoderInstanceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EncoderInstanceInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__EncoderInstanceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__EncoderInstanceInfo ** SOAP_FMAC4 soap_in_PointerTons6__EncoderInstanceInfo(struct soap *soap, const char *tag, struct ns6__EncoderInstanceInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__EncoderInstanceInfo **)soap_malloc(soap, sizeof(struct ns6__EncoderInstanceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__EncoderInstanceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__EncoderInstanceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EncoderInstanceInfo, sizeof(struct ns6__EncoderInstanceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EncoderInstanceInfo(struct soap *soap, struct ns6__EncoderInstanceInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__EncoderInstanceInfo(soap, tag ? tag : "ns6:EncoderInstanceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__EncoderInstanceInfo ** SOAP_FMAC4 soap_get_PointerTons6__EncoderInstanceInfo(struct soap *soap, struct ns6__EncoderInstanceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__EncoderInstanceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoder2ConfigurationOptions(struct soap *soap, struct tt__AudioEncoder2ConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions))
		soap_serialize_tt__AudioEncoder2ConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoder2ConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioEncoder2ConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoder2ConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoder2ConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoder2ConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoder2ConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoder2ConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioEncoder2ConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoder2ConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoder2ConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(struct tt__AudioEncoder2ConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoder2ConfigurationOptions(struct soap *soap, struct tt__AudioEncoder2ConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoder2ConfigurationOptions(soap, tag ? tag : "tt:AudioEncoder2ConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoder2ConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoder2ConfigurationOptions(struct soap *soap, struct tt__AudioEncoder2ConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoder2ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoder2ConfigurationOptions(struct soap *soap, struct tt__VideoEncoder2ConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions))
		soap_serialize_tt__VideoEncoder2ConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoder2ConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoEncoder2ConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoder2ConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoder2ConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoder2ConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoder2ConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoder2ConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoEncoder2ConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoder2ConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoder2ConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(struct tt__VideoEncoder2ConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoder2ConfigurationOptions(struct soap *soap, struct tt__VideoEncoder2ConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoder2ConfigurationOptions(soap, tag ? tag : "tt:VideoEncoder2ConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoder2ConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoder2ConfigurationOptions(struct soap *soap, struct tt__VideoEncoder2ConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoder2ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__MediaProfile(struct soap *soap, struct ns6__MediaProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__MediaProfile))
		soap_serialize_ns6__MediaProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__MediaProfile(struct soap *soap, const char *tag, int id, struct ns6__MediaProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__MediaProfile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__MediaProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__MediaProfile ** SOAP_FMAC4 soap_in_PointerTons6__MediaProfile(struct soap *soap, const char *tag, struct ns6__MediaProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__MediaProfile **)soap_malloc(soap, sizeof(struct ns6__MediaProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__MediaProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__MediaProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__MediaProfile, sizeof(struct ns6__MediaProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__MediaProfile(struct soap *soap, struct ns6__MediaProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__MediaProfile(soap, tag ? tag : "ns6:MediaProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__MediaProfile ** SOAP_FMAC4 soap_get_PointerTons6__MediaProfile(struct soap *soap, struct ns6__MediaProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__MediaProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ConfigurationRef(struct soap *soap, struct ns6__ConfigurationRef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ConfigurationRef))
		soap_serialize_ns6__ConfigurationRef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ConfigurationRef(struct soap *soap, const char *tag, int id, struct ns6__ConfigurationRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ConfigurationRef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__ConfigurationRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__ConfigurationRef ** SOAP_FMAC4 soap_in_PointerTons6__ConfigurationRef(struct soap *soap, const char *tag, struct ns6__ConfigurationRef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__ConfigurationRef **)soap_malloc(soap, sizeof(struct ns6__ConfigurationRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__ConfigurationRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__ConfigurationRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ConfigurationRef, sizeof(struct ns6__ConfigurationRef), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ConfigurationRef(struct soap *soap, struct ns6__ConfigurationRef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ConfigurationRef(soap, tag ? tag : "ns6:ConfigurationRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ConfigurationRef ** SOAP_FMAC4 soap_get_PointerTons6__ConfigurationRef(struct soap *soap, struct ns6__ConfigurationRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ConfigurationRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Capabilities2(struct soap *soap, struct ns6__Capabilities2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Capabilities2))
		soap_serialize_ns6__Capabilities2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Capabilities2(struct soap *soap, const char *tag, int id, struct ns6__Capabilities2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Capabilities2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__Capabilities2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__Capabilities2 ** SOAP_FMAC4 soap_in_PointerTons6__Capabilities2(struct soap *soap, const char *tag, struct ns6__Capabilities2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__Capabilities2 **)soap_malloc(soap, sizeof(struct ns6__Capabilities2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__Capabilities2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__Capabilities2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Capabilities2, sizeof(struct ns6__Capabilities2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Capabilities2(struct soap *soap, struct ns6__Capabilities2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__Capabilities2(soap, tag ? tag : "ns6:Capabilities2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__Capabilities2 ** SOAP_FMAC4 soap_get_PointerTons6__Capabilities2(struct soap *soap, struct ns6__Capabilities2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Capabilities2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__EncoderInstance(struct soap *soap, struct ns6__EncoderInstance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__EncoderInstance))
		soap_serialize_ns6__EncoderInstance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__EncoderInstance(struct soap *soap, const char *tag, int id, struct ns6__EncoderInstance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__EncoderInstance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__EncoderInstance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__EncoderInstance ** SOAP_FMAC4 soap_in_PointerTons6__EncoderInstance(struct soap *soap, const char *tag, struct ns6__EncoderInstance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__EncoderInstance **)soap_malloc(soap, sizeof(struct ns6__EncoderInstance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__EncoderInstance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__EncoderInstance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__EncoderInstance, sizeof(struct ns6__EncoderInstance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__EncoderInstance(struct soap *soap, struct ns6__EncoderInstance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__EncoderInstance(soap, tag ? tag : "ns6:EncoderInstance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__EncoderInstance ** SOAP_FMAC4 soap_get_PointerTons6__EncoderInstance(struct soap *soap, struct ns6__EncoderInstance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__EncoderInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ConfigurationSet(struct soap *soap, struct ns6__ConfigurationSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ConfigurationSet))
		soap_serialize_ns6__ConfigurationSet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ConfigurationSet(struct soap *soap, const char *tag, int id, struct ns6__ConfigurationSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ConfigurationSet, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__ConfigurationSet(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__ConfigurationSet ** SOAP_FMAC4 soap_in_PointerTons6__ConfigurationSet(struct soap *soap, const char *tag, struct ns6__ConfigurationSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__ConfigurationSet **)soap_malloc(soap, sizeof(struct ns6__ConfigurationSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__ConfigurationSet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__ConfigurationSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ConfigurationSet, sizeof(struct ns6__ConfigurationSet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ConfigurationSet(struct soap *soap, struct ns6__ConfigurationSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__ConfigurationSet(soap, tag ? tag : "ns6:ConfigurationSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ConfigurationSet ** SOAP_FMAC4 soap_get_PointerTons6__ConfigurationSet(struct soap *soap, struct ns6__ConfigurationSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ConfigurationSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigurationEntity))
		soap_serialize_tt__ConfigurationEntity(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigurationEntity(struct soap *soap, const char *tag, int id, struct tt__ConfigurationEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigurationEntity, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigurationEntity(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigurationEntity ** SOAP_FMAC4 soap_in_PointerTott__ConfigurationEntity(struct soap *soap, const char *tag, struct tt__ConfigurationEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigurationEntity **)soap_malloc(soap, sizeof(struct tt__ConfigurationEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigurationEntity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigurationEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigurationEntity ** SOAP_FMAC4 soap_get_PointerTott__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoder2Configuration))
		soap_serialize_tt__AudioEncoder2Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoder2Configuration(struct soap *soap, const char *tag, int id, struct tt__AudioEncoder2Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoder2Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoder2Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoder2Configuration(struct soap *soap, const char *tag, struct tt__AudioEncoder2Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoder2Configuration **)soap_malloc(soap, sizeof(struct tt__AudioEncoder2Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoder2Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoder2Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoder2Configuration(soap, tag ? tag : "tt:AudioEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
