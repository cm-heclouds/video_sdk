/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__SpecialDaysScheduleExtension(struct soap *soap, struct ns7__SpecialDaysScheduleExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__SpecialDaysScheduleExtension(struct soap *soap, const struct ns7__SpecialDaysScheduleExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SpecialDaysScheduleExtension(struct soap *soap, const char *tag, int id, const struct ns7__SpecialDaysScheduleExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SpecialDaysScheduleExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__SpecialDaysScheduleExtension * SOAP_FMAC4 soap_in_ns7__SpecialDaysScheduleExtension(struct soap *soap, const char *tag, struct ns7__SpecialDaysScheduleExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__SpecialDaysScheduleExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SpecialDaysScheduleExtension, sizeof(struct ns7__SpecialDaysScheduleExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__SpecialDaysScheduleExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns7__SpecialDaysScheduleExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SpecialDaysScheduleExtension, SOAP_TYPE_ns7__SpecialDaysScheduleExtension, sizeof(struct ns7__SpecialDaysScheduleExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__SpecialDaysScheduleExtension * SOAP_FMAC4 soap_new_ns7__SpecialDaysScheduleExtension(struct soap *soap, int n)
{
	struct ns7__SpecialDaysScheduleExtension *p;
	struct ns7__SpecialDaysScheduleExtension *a = (struct ns7__SpecialDaysScheduleExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__SpecialDaysScheduleExtension));
	for (p = a; p && n--; p++)
		soap_default_ns7__SpecialDaysScheduleExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SpecialDaysScheduleExtension(struct soap *soap, const struct ns7__SpecialDaysScheduleExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SpecialDaysScheduleExtension(soap, tag ? tag : "ns7:SpecialDaysScheduleExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDaysScheduleExtension * SOAP_FMAC4 soap_get_ns7__SpecialDaysScheduleExtension(struct soap *soap, struct ns7__SpecialDaysScheduleExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SpecialDaysScheduleExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__TimePeriod(struct soap *soap, struct ns7__TimePeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__time(soap, &a->From);
	soap_default_xsd__time(soap, &a->Until);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__TimePeriod(struct soap *soap, const struct ns7__TimePeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__time(soap, (char*const*)&a->From);
	soap_serialize_xsd__time(soap, (char*const*)&a->Until);
	soap_serialize_PointerTons7__TimePeriodExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__TimePeriod(struct soap *soap, const char *tag, int id, const struct ns7__TimePeriod *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__TimePeriod), type))
		return soap->error;
	if (!a->From)
	{	if (soap_element_nil(soap, "ns7:From"))
			return soap->error;
	}
	else
	if (soap_out_xsd__time(soap, "ns7:From", -1, (char*const*)&a->From, ""))
		return soap->error;
	if (soap_out_xsd__time(soap, "ns7:Until", -1, (char*const*)&a->Until, ""))
		return soap->error;
	if (soap_out_PointerTons7__TimePeriodExtension(soap, "ns7:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__TimePeriod * SOAP_FMAC4 soap_in_ns7__TimePeriod(struct soap *soap, const char *tag, struct ns7__TimePeriod *a, const char *type)
{
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__TimePeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__TimePeriod, sizeof(struct ns7__TimePeriod), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__TimePeriod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__time(soap, "ns7:From", (char**)&a->From, "xsd:time"))
				{	soap_flag_From--;
					continue;
				}
			if (soap_flag_Until && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__time(soap, "ns7:Until", (char**)&a->Until, "xsd:time"))
				{	soap_flag_Until--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__TimePeriodExtension(soap, "ns7:Extension", &a->Extension, "ns7:TimePeriodExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__TimePeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__TimePeriod, SOAP_TYPE_ns7__TimePeriod, sizeof(struct ns7__TimePeriod), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__TimePeriod * SOAP_FMAC4 soap_new_ns7__TimePeriod(struct soap *soap, int n)
{
	struct ns7__TimePeriod *p;
	struct ns7__TimePeriod *a = (struct ns7__TimePeriod*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__TimePeriod));
	for (p = a; p && n--; p++)
		soap_default_ns7__TimePeriod(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__TimePeriod(struct soap *soap, const struct ns7__TimePeriod *a, const char *tag, const char *type)
{
	if (soap_out_ns7__TimePeriod(soap, tag ? tag : "ns7:TimePeriod", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__TimePeriod * SOAP_FMAC4 soap_get_ns7__TimePeriod(struct soap *soap, struct ns7__TimePeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__TimePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__SpecialDaysSchedule(struct soap *soap, struct ns7__SpecialDaysSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->GroupToken);
	a->__sizeTimeRange = 0;
	a->TimeRange = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__SpecialDaysSchedule(struct soap *soap, const struct ns7__SpecialDaysSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->GroupToken);
	if (a->TimeRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeTimeRange; i++)
		{
			soap_embedded(soap, a->TimeRange + i, SOAP_TYPE_ns7__TimePeriod);
			soap_serialize_ns7__TimePeriod(soap, a->TimeRange + i);
		}
	}
	soap_serialize_PointerTons7__SpecialDaysScheduleExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SpecialDaysSchedule(struct soap *soap, const char *tag, int id, const struct ns7__SpecialDaysSchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SpecialDaysSchedule), type))
		return soap->error;
	if (!a->GroupToken)
	{	if (soap_element_nil(soap, "ns7:GroupToken"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns7:GroupToken", -1, (char*const*)&a->GroupToken, ""))
		return soap->error;
	if (a->TimeRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeTimeRange; i++)
			if (soap_out_ns7__TimePeriod(soap, "ns7:TimeRange", -1, a->TimeRange + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons7__SpecialDaysScheduleExtension(soap, "ns7:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__SpecialDaysSchedule * SOAP_FMAC4 soap_in_ns7__SpecialDaysSchedule(struct soap *soap, const char *tag, struct ns7__SpecialDaysSchedule *a, const char *type)
{
	size_t soap_flag_GroupToken = 1;
	struct soap_blist *soap_blist_TimeRange = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__SpecialDaysSchedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SpecialDaysSchedule, sizeof(struct ns7__SpecialDaysSchedule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__SpecialDaysSchedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns7:GroupToken", (char**)&a->GroupToken, "ns2:ReferenceToken"))
				{	soap_flag_GroupToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:TimeRange", 1, NULL))
			{	if (a->TimeRange == NULL)
				{	if (soap_blist_TimeRange == NULL)
						soap_blist_TimeRange = soap_alloc_block(soap);
					a->TimeRange = (struct ns7__TimePeriod *)soap_push_block_max(soap, soap_blist_TimeRange, sizeof(struct ns7__TimePeriod));
					if (a->TimeRange == NULL)
						return NULL;
					soap_default_ns7__TimePeriod(soap, a->TimeRange);
				}
				soap_revert(soap);
				if (soap_in_ns7__TimePeriod(soap, "ns7:TimeRange", a->TimeRange, "ns7:TimePeriod"))
				{	a->__sizeTimeRange++;
					a->TimeRange = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__SpecialDaysScheduleExtension(soap, "ns7:Extension", &a->Extension, "ns7:SpecialDaysScheduleExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TimeRange)
			soap_pop_block(soap, soap_blist_TimeRange);
		if (a->__sizeTimeRange)
		{	a->TimeRange = (struct ns7__TimePeriod *)soap_save_block(soap, soap_blist_TimeRange, NULL, 1);
		}
		else
		{	a->TimeRange = NULL;
			if (soap_blist_TimeRange)
				soap_end_block(soap, soap_blist_TimeRange);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GroupToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__SpecialDaysSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SpecialDaysSchedule, SOAP_TYPE_ns7__SpecialDaysSchedule, sizeof(struct ns7__SpecialDaysSchedule), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__SpecialDaysSchedule * SOAP_FMAC4 soap_new_ns7__SpecialDaysSchedule(struct soap *soap, int n)
{
	struct ns7__SpecialDaysSchedule *p;
	struct ns7__SpecialDaysSchedule *a = (struct ns7__SpecialDaysSchedule*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__SpecialDaysSchedule));
	for (p = a; p && n--; p++)
		soap_default_ns7__SpecialDaysSchedule(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SpecialDaysSchedule(struct soap *soap, const struct ns7__SpecialDaysSchedule *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SpecialDaysSchedule(soap, tag ? tag : "ns7:SpecialDaysSchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDaysSchedule * SOAP_FMAC4 soap_get_ns7__SpecialDaysSchedule(struct soap *soap, struct ns7__SpecialDaysSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SpecialDaysSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ScheduleExtension(struct soap *soap, struct ns7__ScheduleExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__ScheduleExtension(struct soap *soap, const struct ns7__ScheduleExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ScheduleExtension(struct soap *soap, const char *tag, int id, const struct ns7__ScheduleExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ScheduleExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__ScheduleExtension * SOAP_FMAC4 soap_in_ns7__ScheduleExtension(struct soap *soap, const char *tag, struct ns7__ScheduleExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__ScheduleExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ScheduleExtension, sizeof(struct ns7__ScheduleExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__ScheduleExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns7__ScheduleExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ScheduleExtension, SOAP_TYPE_ns7__ScheduleExtension, sizeof(struct ns7__ScheduleExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__ScheduleExtension * SOAP_FMAC4 soap_new_ns7__ScheduleExtension(struct soap *soap, int n)
{
	struct ns7__ScheduleExtension *p;
	struct ns7__ScheduleExtension *a = (struct ns7__ScheduleExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__ScheduleExtension));
	for (p = a; p && n--; p++)
		soap_default_ns7__ScheduleExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ScheduleExtension(struct soap *soap, const struct ns7__ScheduleExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns7__ScheduleExtension(soap, tag ? tag : "ns7:ScheduleExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleExtension * SOAP_FMAC4 soap_get_ns7__ScheduleExtension(struct soap *soap, struct ns7__ScheduleExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ScheduleExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ServiceCapabilities(struct soap *soap, struct ns7__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__PositiveInteger(soap, &a->MaxLimit);
	soap_default_ns2__PositiveInteger(soap, &a->MaxSchedules);
	soap_default_ns2__PositiveInteger(soap, &a->MaxTimePeriodsPerDay);
	soap_default_ns2__PositiveInteger(soap, &a->MaxSpecialDayGroups);
	soap_default_ns2__PositiveInteger(soap, &a->MaxDaysInSpecialDayGroup);
	soap_default_ns2__PositiveInteger(soap, &a->MaxSpecialDaysSchedules);
	soap_default_xsd__boolean(soap, &a->ExtendedRecurrenceSupported);
	soap_default_xsd__boolean(soap, &a->SpecialDaysSupported);
	soap_default_xsd__boolean(soap, &a->StateReportingSupported);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__ServiceCapabilities(struct soap *soap, const struct ns7__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ServiceCapabilities(struct soap *soap, const char *tag, int id, const struct ns7__ServiceCapabilities *a, const char *type)
{
	soap_set_attr(soap, "MaxLimit", soap_ns2__PositiveInteger2s(soap, a->MaxLimit), 1);
	soap_set_attr(soap, "MaxSchedules", soap_ns2__PositiveInteger2s(soap, a->MaxSchedules), 1);
	soap_set_attr(soap, "MaxTimePeriodsPerDay", soap_ns2__PositiveInteger2s(soap, a->MaxTimePeriodsPerDay), 1);
	soap_set_attr(soap, "MaxSpecialDayGroups", soap_ns2__PositiveInteger2s(soap, a->MaxSpecialDayGroups), 1);
	soap_set_attr(soap, "MaxDaysInSpecialDayGroup", soap_ns2__PositiveInteger2s(soap, a->MaxDaysInSpecialDayGroup), 1);
	soap_set_attr(soap, "MaxSpecialDaysSchedules", soap_ns2__PositiveInteger2s(soap, a->MaxSpecialDaysSchedules), 1);
	soap_set_attr(soap, "ExtendedRecurrenceSupported", soap_xsd__boolean2s(soap, a->ExtendedRecurrenceSupported), 1);
	soap_set_attr(soap, "SpecialDaysSupported", soap_xsd__boolean2s(soap, a->SpecialDaysSupported), 1);
	soap_set_attr(soap, "StateReportingSupported", soap_xsd__boolean2s(soap, a->StateReportingSupported), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__ServiceCapabilities * SOAP_FMAC4 soap_in_ns7__ServiceCapabilities(struct soap *soap, const char *tag, struct ns7__ServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__ServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ServiceCapabilities, sizeof(struct ns7__ServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__ServiceCapabilities(soap, a);
	if (soap_s2ns2__PositiveInteger(soap, soap_attr_value(soap, "MaxLimit", 1), &a->MaxLimit))
		return NULL;
	if (soap_s2ns2__PositiveInteger(soap, soap_attr_value(soap, "MaxSchedules", 1), &a->MaxSchedules))
		return NULL;
	if (soap_s2ns2__PositiveInteger(soap, soap_attr_value(soap, "MaxTimePeriodsPerDay", 1), &a->MaxTimePeriodsPerDay))
		return NULL;
	if (soap_s2ns2__PositiveInteger(soap, soap_attr_value(soap, "MaxSpecialDayGroups", 1), &a->MaxSpecialDayGroups))
		return NULL;
	if (soap_s2ns2__PositiveInteger(soap, soap_attr_value(soap, "MaxDaysInSpecialDayGroup", 1), &a->MaxDaysInSpecialDayGroup))
		return NULL;
	if (soap_s2ns2__PositiveInteger(soap, soap_attr_value(soap, "MaxSpecialDaysSchedules", 1), &a->MaxSpecialDaysSchedules))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "ExtendedRecurrenceSupported", 1), &a->ExtendedRecurrenceSupported))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "SpecialDaysSupported", 1), &a->SpecialDaysSupported))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "StateReportingSupported", 1), &a->StateReportingSupported))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns7__ServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ServiceCapabilities, SOAP_TYPE_ns7__ServiceCapabilities, sizeof(struct ns7__ServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__ServiceCapabilities * SOAP_FMAC4 soap_new_ns7__ServiceCapabilities(struct soap *soap, int n)
{
	struct ns7__ServiceCapabilities *p;
	struct ns7__ServiceCapabilities *a = (struct ns7__ServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__ServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns7__ServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ServiceCapabilities(struct soap *soap, const struct ns7__ServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns7__ServiceCapabilities(soap, tag ? tag : "ns7:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ServiceCapabilities * SOAP_FMAC4 soap_get_ns7__ServiceCapabilities(struct soap *soap, struct ns7__ServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayConfigurationResponse(struct soap *soap, const struct _trp__GetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReplayConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trp:Configuration");
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "trp:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ReplayConfiguration(soap, "trp:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_in__trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__GetReplayConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReplayConfiguration(soap, "trp:Configuration", &a->Configuration, "tt:ReplayConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trp:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfigurationResponse, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_new__trp__GetReplayConfigurationResponse(struct soap *soap, int n)
{
	struct _trp__GetReplayConfigurationResponse *p;
	struct _trp__GetReplayConfigurationResponse *a = (struct _trp__GetReplayConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayConfigurationResponse(struct soap *soap, const struct _trp__GetReplayConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayConfigurationResponse(soap, tag ? tag : "trp:GetReplayConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_get__trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayConfiguration(struct soap *soap, const struct _trp__GetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayConfiguration(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_in__trp__GetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__GetReplayConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfiguration, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_new__trp__GetReplayConfiguration(struct soap *soap, int n)
{
	struct _trp__GetReplayConfiguration *p;
	struct _trp__GetReplayConfiguration *a = (struct _trp__GetReplayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayConfiguration(struct soap *soap, const struct _trp__GetReplayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayConfiguration(soap, tag ? tag : "trp:GetReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_get__trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__SetReplayConfigurationResponse(struct soap *soap, const struct _trp__SetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trp__SetReplayConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_in__trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__SetReplayConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__SetReplayConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfigurationResponse, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_new__trp__SetReplayConfigurationResponse(struct soap *soap, int n)
{
	struct _trp__SetReplayConfigurationResponse *p;
	struct _trp__SetReplayConfigurationResponse *a = (struct _trp__SetReplayConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__SetReplayConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__SetReplayConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__SetReplayConfigurationResponse(struct soap *soap, const struct _trp__SetReplayConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__SetReplayConfigurationResponse(soap, tag ? tag : "trp:SetReplayConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_get__trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__SetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__SetReplayConfiguration(struct soap *soap, const struct _trp__SetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReplayConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__SetReplayConfiguration(struct soap *soap, const char *tag, int id, const struct _trp__SetReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__SetReplayConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "trp:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ReplayConfiguration(soap, "trp:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_in__trp__SetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__SetReplayConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__SetReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__SetReplayConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReplayConfiguration(soap, "trp:Configuration", &a->Configuration, "tt:ReplayConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfiguration, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_new__trp__SetReplayConfiguration(struct soap *soap, int n)
{
	struct _trp__SetReplayConfiguration *p;
	struct _trp__SetReplayConfiguration *a = (struct _trp__SetReplayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__SetReplayConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trp__SetReplayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__SetReplayConfiguration(struct soap *soap, const struct _trp__SetReplayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trp__SetReplayConfiguration(soap, tag ? tag : "trp:SetReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_get__trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__SetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayUriResponse(struct soap *soap, const struct _trp__GetReplayUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayUriResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "trp:Uri");
	if (!a->Uri)
	{	if (soap_element_nil(soap, "trp:Uri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "trp:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_in__trp__GetReplayUriResponse(struct soap *soap, const char *tag, struct _trp__GetReplayUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "trp:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			soap_check_result(soap, "trp:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUriResponse, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_new__trp__GetReplayUriResponse(struct soap *soap, int n)
{
	struct _trp__GetReplayUriResponse *p;
	struct _trp__GetReplayUriResponse *a = (struct _trp__GetReplayUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayUriResponse(struct soap *soap, const struct _trp__GetReplayUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayUriResponse(soap, tag ? tag : "trp:GetReplayUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_get__trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayUri(struct soap *soap, const struct _trp__GetReplayUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayUri(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayUri), type))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_nil(soap, "trp:StreamSetup"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__StreamSetup(soap, "trp:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trp:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trp:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_in__trp__GetReplayUri(struct soap *soap, const char *tag, struct _trp__GetReplayUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "trp:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trp:RecordingToken", (char**)&a->RecordingToken, "tt:ReferenceToken"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StreamSetup > 0 || soap_flag_RecordingToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUri, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_new__trp__GetReplayUri(struct soap *soap, int n)
{
	struct _trp__GetReplayUri *p;
	struct _trp__GetReplayUri *a = (struct _trp__GetReplayUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetReplayUri));
	for (p = a; p && n--; p++)
		soap_default__trp__GetReplayUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayUri(struct soap *soap, const struct _trp__GetReplayUri *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetReplayUri(soap, tag ? tag : "trp:GetReplayUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_get__trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trp__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrp__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trp:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "trp:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotrp__Capabilities(soap, "trp:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrp__Capabilities(soap, "trp:Capabilities", &a->Capabilities, "trp:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trp:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trp__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trp__GetServiceCapabilitiesResponse *p;
	struct _trp__GetServiceCapabilitiesResponse *a = (struct _trp__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trp__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trp__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetServiceCapabilitiesResponse(soap, tag ? tag : "trp:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetServiceCapabilities(struct soap *soap, const struct _trp__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trp__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_in__trp__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilities, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_new__trp__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trp__GetServiceCapabilities *p;
	struct _trp__GetServiceCapabilities *a = (struct _trp__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trp__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trp__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetServiceCapabilities(struct soap *soap, const struct _trp__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trp__GetServiceCapabilities(soap, tag ? tag : "trp:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_get__trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trp__Capabilities(struct soap *soap, struct trp__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->ReversePlayback);
	soap_default_tt__FloatAttrList(soap, &a->SessionTimeoutRange);
	a->RTP_USCORERTSP_USCORETCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trp__Capabilities(struct soap *soap, const struct trp__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trp__Capabilities(struct soap *soap, const char *tag, int id, const struct trp__Capabilities *a, const char *type)
{
	soap_set_attr(soap, "ReversePlayback", soap_xsd__boolean2s(soap, a->ReversePlayback), 1);
	if (a->SessionTimeoutRange)
		soap_set_attr(soap, "SessionTimeoutRange", soap_tt__FloatAttrList2s(soap, a->SessionTimeoutRange), 1);
	if (a->RTP_USCORERTSP_USCORETCP)
		soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trp__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_in_trp__Capabilities(struct soap *soap, const char *tag, struct trp__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trp__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trp__Capabilities(soap, a);
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "ReversePlayback", 0), &a->ReversePlayback))
		return NULL;
	if (soap_s2tt__FloatAttrList(soap, soap_attr_value(soap, "SessionTimeoutRange", 0), &a->SessionTimeoutRange))
		return NULL;
	{	const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trp__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trp__Capabilities, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_new_trp__Capabilities(struct soap *soap, int n)
{
	struct trp__Capabilities *p;
	struct trp__Capabilities *a = (struct trp__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trp__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trp__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trp__Capabilities(struct soap *soap, const struct trp__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trp__Capabilities(soap, tag ? tag : "trp:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_get_trp__Capabilities(struct soap *soap, struct trp__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trp__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetExportRecordedDataStateResponse(struct soap *soap, struct _trc__GetExportRecordedDataStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Progress);
	a->FileProgressStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetExportRecordedDataStateResponse(struct soap *soap, const struct _trc__GetExportRecordedDataStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Progress, SOAP_TYPE_float);
	soap_serialize_PointerTott__ArrayOfFileProgress(soap, &a->FileProgressStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetExportRecordedDataStateResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetExportRecordedDataStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetExportRecordedDataStateResponse), type))
		return soap->error;
	soap_element_result(soap, "trc:Progress");
	if (soap_out_float(soap, "trc:Progress", -1, &a->Progress, ""))
		return soap->error;
	if (!a->FileProgressStatus)
	{	if (soap_element_nil(soap, "trc:FileProgressStatus"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", -1, &a->FileProgressStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataStateResponse * SOAP_FMAC4 soap_in__trc__GetExportRecordedDataStateResponse(struct soap *soap, const char *tag, struct _trc__GetExportRecordedDataStateResponse *a, const char *type)
{
	size_t soap_flag_Progress = 1;
	size_t soap_flag_FileProgressStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetExportRecordedDataStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetExportRecordedDataStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "trc:Progress", &a->Progress, "xsd:float"))
				{	soap_flag_Progress--;
					continue;
				}
			if (soap_flag_FileProgressStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", &a->FileProgressStatus, "tt:ArrayOfFileProgress"))
				{	soap_flag_FileProgressStatus--;
					continue;
				}
			soap_check_result(soap, "trc:Progress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Progress > 0 || soap_flag_FileProgressStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetExportRecordedDataStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, SOAP_TYPE__trc__GetExportRecordedDataStateResponse, sizeof(struct _trc__GetExportRecordedDataStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataStateResponse * SOAP_FMAC4 soap_new__trc__GetExportRecordedDataStateResponse(struct soap *soap, int n)
{
	struct _trc__GetExportRecordedDataStateResponse *p;
	struct _trc__GetExportRecordedDataStateResponse *a = (struct _trc__GetExportRecordedDataStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetExportRecordedDataStateResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetExportRecordedDataStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetExportRecordedDataStateResponse(struct soap *soap, const struct _trc__GetExportRecordedDataStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetExportRecordedDataStateResponse(soap, tag ? tag : "trc:GetExportRecordedDataStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataStateResponse * SOAP_FMAC4 soap_get__trc__GetExportRecordedDataStateResponse(struct soap *soap, struct _trc__GetExportRecordedDataStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetExportRecordedDataStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetExportRecordedDataState(struct soap *soap, struct _trc__GetExportRecordedDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OperationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetExportRecordedDataState(struct soap *soap, const struct _trc__GetExportRecordedDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OperationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetExportRecordedDataState(struct soap *soap, const char *tag, int id, const struct _trc__GetExportRecordedDataState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetExportRecordedDataState), type))
		return soap->error;
	if (!a->OperationToken)
	{	if (soap_element_nil(soap, "trc:OperationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trc:OperationToken", -1, (char*const*)&a->OperationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataState * SOAP_FMAC4 soap_in__trc__GetExportRecordedDataState(struct soap *soap, const char *tag, struct _trc__GetExportRecordedDataState *a, const char *type)
{
	size_t soap_flag_OperationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetExportRecordedDataState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetExportRecordedDataState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trc:OperationToken", (char**)&a->OperationToken, "tt:ReferenceToken"))
				{	soap_flag_OperationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OperationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetExportRecordedDataState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetExportRecordedDataState, SOAP_TYPE__trc__GetExportRecordedDataState, sizeof(struct _trc__GetExportRecordedDataState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataState * SOAP_FMAC4 soap_new__trc__GetExportRecordedDataState(struct soap *soap, int n)
{
	struct _trc__GetExportRecordedDataState *p;
	struct _trc__GetExportRecordedDataState *a = (struct _trc__GetExportRecordedDataState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetExportRecordedDataState));
	for (p = a; p && n--; p++)
		soap_default__trc__GetExportRecordedDataState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetExportRecordedDataState(struct soap *soap, const struct _trc__GetExportRecordedDataState *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetExportRecordedDataState(soap, tag ? tag : "trc:GetExportRecordedDataState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetExportRecordedDataState * SOAP_FMAC4 soap_get__trc__GetExportRecordedDataState(struct soap *soap, struct _trc__GetExportRecordedDataState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetExportRecordedDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__StopExportRecordedDataResponse(struct soap *soap, struct _trc__StopExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Progress);
	a->FileProgressStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__StopExportRecordedDataResponse(struct soap *soap, const struct _trc__StopExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Progress, SOAP_TYPE_float);
	soap_serialize_PointerTott__ArrayOfFileProgress(soap, &a->FileProgressStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__StopExportRecordedDataResponse(struct soap *soap, const char *tag, int id, const struct _trc__StopExportRecordedDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__StopExportRecordedDataResponse), type))
		return soap->error;
	soap_element_result(soap, "trc:Progress");
	if (soap_out_float(soap, "trc:Progress", -1, &a->Progress, ""))
		return soap->error;
	if (!a->FileProgressStatus)
	{	if (soap_element_nil(soap, "trc:FileProgressStatus"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", -1, &a->FileProgressStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__StopExportRecordedDataResponse * SOAP_FMAC4 soap_in__trc__StopExportRecordedDataResponse(struct soap *soap, const char *tag, struct _trc__StopExportRecordedDataResponse *a, const char *type)
{
	size_t soap_flag_Progress = 1;
	size_t soap_flag_FileProgressStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__StopExportRecordedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__StopExportRecordedDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "trc:Progress", &a->Progress, "xsd:float"))
				{	soap_flag_Progress--;
					continue;
				}
			if (soap_flag_FileProgressStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ArrayOfFileProgress(soap, "trc:FileProgressStatus", &a->FileProgressStatus, "tt:ArrayOfFileProgress"))
				{	soap_flag_FileProgressStatus--;
					continue;
				}
			soap_check_result(soap, "trc:Progress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Progress > 0 || soap_flag_FileProgressStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__StopExportRecordedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__StopExportRecordedDataResponse, SOAP_TYPE__trc__StopExportRecordedDataResponse, sizeof(struct _trc__StopExportRecordedDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__StopExportRecordedDataResponse * SOAP_FMAC4 soap_new__trc__StopExportRecordedDataResponse(struct soap *soap, int n)
{
	struct _trc__StopExportRecordedDataResponse *p;
	struct _trc__StopExportRecordedDataResponse *a = (struct _trc__StopExportRecordedDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__StopExportRecordedDataResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__StopExportRecordedDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__StopExportRecordedDataResponse(struct soap *soap, const struct _trc__StopExportRecordedDataResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__StopExportRecordedDataResponse(soap, tag ? tag : "trc:StopExportRecordedDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__StopExportRecordedDataResponse * SOAP_FMAC4 soap_get__trc__StopExportRecordedDataResponse(struct soap *soap, struct _trc__StopExportRecordedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__StopExportRecordedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__StopExportRecordedData(struct soap *soap, struct _trc__StopExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OperationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__StopExportRecordedData(struct soap *soap, const struct _trc__StopExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OperationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__StopExportRecordedData(struct soap *soap, const char *tag, int id, const struct _trc__StopExportRecordedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__StopExportRecordedData), type))
		return soap->error;
	if (!a->OperationToken)
	{	if (soap_element_nil(soap, "trc:OperationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trc:OperationToken", -1, (char*const*)&a->OperationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__StopExportRecordedData * SOAP_FMAC4 soap_in__trc__StopExportRecordedData(struct soap *soap, const char *tag, struct _trc__StopExportRecordedData *a, const char *type)
{
	size_t soap_flag_OperationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__StopExportRecordedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__StopExportRecordedData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trc:OperationToken", (char**)&a->OperationToken, "tt:ReferenceToken"))
				{	soap_flag_OperationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OperationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__StopExportRecordedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__StopExportRecordedData, SOAP_TYPE__trc__StopExportRecordedData, sizeof(struct _trc__StopExportRecordedData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__StopExportRecordedData * SOAP_FMAC4 soap_new__trc__StopExportRecordedData(struct soap *soap, int n)
{
	struct _trc__StopExportRecordedData *p;
	struct _trc__StopExportRecordedData *a = (struct _trc__StopExportRecordedData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__StopExportRecordedData));
	for (p = a; p && n--; p++)
		soap_default__trc__StopExportRecordedData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__StopExportRecordedData(struct soap *soap, const struct _trc__StopExportRecordedData *a, const char *tag, const char *type)
{
	if (soap_out__trc__StopExportRecordedData(soap, tag ? tag : "trc:StopExportRecordedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__StopExportRecordedData * SOAP_FMAC4 soap_get__trc__StopExportRecordedData(struct soap *soap, struct _trc__StopExportRecordedData *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__StopExportRecordedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const struct _trc__ExportRecordedDataResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const char *tag, int id, const struct _trc__ExportRecordedDataResponse_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension * SOAP_FMAC4 soap_in__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const char *tag, struct _trc__ExportRecordedDataResponse_Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__ExportRecordedDataResponse_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__ExportRecordedDataResponse_Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedDataResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, SOAP_TYPE__trc__ExportRecordedDataResponse_Extension, sizeof(struct _trc__ExportRecordedDataResponse_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension * SOAP_FMAC4 soap_new__trc__ExportRecordedDataResponse_Extension(struct soap *soap, int n)
{
	struct _trc__ExportRecordedDataResponse_Extension *p;
	struct _trc__ExportRecordedDataResponse_Extension *a = (struct _trc__ExportRecordedDataResponse_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__ExportRecordedDataResponse_Extension));
	for (p = a; p && n--; p++)
		soap_default__trc__ExportRecordedDataResponse_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__ExportRecordedDataResponse_Extension(struct soap *soap, const struct _trc__ExportRecordedDataResponse_Extension *a, const char *tag, const char *type)
{
	if (soap_out__trc__ExportRecordedDataResponse_Extension(soap, tag ? tag : "trc:ExportRecordedDataResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse_Extension * SOAP_FMAC4 soap_get__trc__ExportRecordedDataResponse_Extension(struct soap *soap, struct _trc__ExportRecordedDataResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__ExportRecordedDataResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__ExportRecordedDataResponse(struct soap *soap, struct _trc__ExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OperationToken);
	a->__sizeFileNames = 0;
	a->FileNames = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__ExportRecordedDataResponse(struct soap *soap, const struct _trc__ExportRecordedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OperationToken);
	if (a->FileNames)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileNames; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->FileNames + i));
		}
	}
	soap_serialize_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__ExportRecordedDataResponse(struct soap *soap, const char *tag, int id, const struct _trc__ExportRecordedDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__ExportRecordedDataResponse), type))
		return soap->error;
	if (a->OperationToken)
		soap_element_result(soap, "trc:OperationToken");
	if (!a->OperationToken)
	{	if (soap_element_nil(soap, "trc:OperationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trc:OperationToken", -1, (char*const*)&a->OperationToken, ""))
		return soap->error;
	if (a->FileNames)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileNames; i++)
			soap_out_string(soap, "trc:FileNames", -1, (char*const*)(a->FileNames + i), "");
	}
	if (soap_out_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, "trc:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse * SOAP_FMAC4 soap_in__trc__ExportRecordedDataResponse(struct soap *soap, const char *tag, struct _trc__ExportRecordedDataResponse *a, const char *type)
{
	size_t soap_flag_OperationToken = 1;
	struct soap_blist *soap_blist_FileNames = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__ExportRecordedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__ExportRecordedDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trc:OperationToken", (char**)&a->OperationToken, "tt:ReferenceToken"))
				{	soap_flag_OperationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:FileNames", 1, NULL))
			{	if (a->FileNames == NULL)
				{	if (soap_blist_FileNames == NULL)
						soap_blist_FileNames = soap_alloc_block(soap);
					a->FileNames = (char **)soap_push_block_max(soap, soap_blist_FileNames, sizeof(char *));
					if (a->FileNames == NULL)
						return NULL;
					*a->FileNames = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "trc:FileNames", (char**)a->FileNames, "xsd:string"))
				{	a->__sizeFileNames++;
					a->FileNames = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trc__ExportRecordedDataResponse_Extension(soap, "trc:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			soap_check_result(soap, "trc:OperationToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->FileNames)
			soap_pop_block(soap, soap_blist_FileNames);
		if (a->__sizeFileNames)
		{	a->FileNames = (char **)soap_save_block(soap, soap_blist_FileNames, NULL, 1);
		}
		else
		{	a->FileNames = NULL;
			if (soap_blist_FileNames)
				soap_end_block(soap, soap_blist_FileNames);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OperationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedDataResponse, SOAP_TYPE__trc__ExportRecordedDataResponse, sizeof(struct _trc__ExportRecordedDataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse * SOAP_FMAC4 soap_new__trc__ExportRecordedDataResponse(struct soap *soap, int n)
{
	struct _trc__ExportRecordedDataResponse *p;
	struct _trc__ExportRecordedDataResponse *a = (struct _trc__ExportRecordedDataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__ExportRecordedDataResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__ExportRecordedDataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__ExportRecordedDataResponse(struct soap *soap, const struct _trc__ExportRecordedDataResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__ExportRecordedDataResponse(soap, tag ? tag : "trc:ExportRecordedDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedDataResponse * SOAP_FMAC4 soap_get__trc__ExportRecordedDataResponse(struct soap *soap, struct _trc__ExportRecordedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__ExportRecordedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__ExportRecordedData(struct soap *soap, struct _trc__ExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SearchScope = NULL;
	soap_default_string(soap, &a->FileFormat);
	a->StorageDestination = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__ExportRecordedData(struct soap *soap, const struct _trc__ExportRecordedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SearchScope(soap, &a->SearchScope);
	soap_serialize_string(soap, (char*const*)&a->FileFormat);
	soap_serialize_PointerTott__StorageReferencePath(soap, &a->StorageDestination);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__ExportRecordedData(struct soap *soap, const char *tag, int id, const struct _trc__ExportRecordedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__ExportRecordedData), type))
		return soap->error;
	if (!a->SearchScope)
	{	if (soap_element_nil(soap, "trc:SearchScope"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SearchScope(soap, "trc:SearchScope", -1, &a->SearchScope, ""))
		return soap->error;
	if (!a->FileFormat)
	{	if (soap_element_nil(soap, "trc:FileFormat"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "trc:FileFormat", -1, (char*const*)&a->FileFormat, ""))
		return soap->error;
	if (!a->StorageDestination)
	{	if (soap_element_nil(soap, "trc:StorageDestination"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__StorageReferencePath(soap, "trc:StorageDestination", -1, &a->StorageDestination, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__ExportRecordedData * SOAP_FMAC4 soap_in__trc__ExportRecordedData(struct soap *soap, const char *tag, struct _trc__ExportRecordedData *a, const char *type)
{
	size_t soap_flag_SearchScope = 1;
	size_t soap_flag_FileFormat = 1;
	size_t soap_flag_StorageDestination = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__ExportRecordedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__ExportRecordedData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchScope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "trc:SearchScope", &a->SearchScope, "tt:SearchScope"))
				{	soap_flag_SearchScope--;
					continue;
				}
			if (soap_flag_FileFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "trc:FileFormat", (char**)&a->FileFormat, "xsd:string"))
				{	soap_flag_FileFormat--;
					continue;
				}
			if (soap_flag_StorageDestination && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StorageReferencePath(soap, "trc:StorageDestination", &a->StorageDestination, "tt:StorageReferencePath"))
				{	soap_flag_StorageDestination--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchScope > 0 || soap_flag_FileFormat > 0 || soap_flag_StorageDestination > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__ExportRecordedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__ExportRecordedData, SOAP_TYPE__trc__ExportRecordedData, sizeof(struct _trc__ExportRecordedData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__ExportRecordedData * SOAP_FMAC4 soap_new__trc__ExportRecordedData(struct soap *soap, int n)
{
	struct _trc__ExportRecordedData *p;
	struct _trc__ExportRecordedData *a = (struct _trc__ExportRecordedData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__ExportRecordedData));
	for (p = a; p && n--; p++)
		soap_default__trc__ExportRecordedData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__ExportRecordedData(struct soap *soap, const struct _trc__ExportRecordedData *a, const char *tag, const char *type)
{
	if (soap_out__trc__ExportRecordedData(soap, tag ? tag : "trc:ExportRecordedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__ExportRecordedData * SOAP_FMAC4 soap_get__trc__ExportRecordedData(struct soap *soap, struct _trc__ExportRecordedData *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__ExportRecordedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingOptionsResponse(struct soap *soap, const struct _trc__GetRecordingOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrc__RecordingOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trc:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trc:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotrc__RecordingOptions(soap, "trc:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__RecordingOptions(soap, "trc:Options", &a->Options, "trc:RecordingOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trc:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptionsResponse, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_new__trc__GetRecordingOptionsResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingOptionsResponse *p;
	struct _trc__GetRecordingOptionsResponse *a = (struct _trc__GetRecordingOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingOptionsResponse(struct soap *soap, const struct _trc__GetRecordingOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingOptionsResponse(soap, tag ? tag : "trc:GetRecordingOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingOptions(struct soap *soap, const struct _trc__GetRecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingOptions(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingOptions), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_in__trc__GetRecordingOptions(struct soap *soap, const char *tag, struct _trc__GetRecordingOptions *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptions, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_new__trc__GetRecordingOptions(struct soap *soap, int n)
{
	struct _trc__GetRecordingOptions *p;
	struct _trc__GetRecordingOptions *a = (struct _trc__GetRecordingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingOptions));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingOptions(struct soap *soap, const struct _trc__GetRecordingOptions *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingOptions(soap, tag ? tag : "trc:GetRecordingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_get__trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobStateResponse(struct soap *soap, const struct _trc__GetRecordingJobStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobStateInformation(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse), type))
		return soap->error;
	if (a->State)
		soap_element_result(soap, "trc:State");
	if (!a->State)
	{	if (soap_element_nil(soap, "trc:State"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobStateInformation(soap, "trc:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobStateInformation(soap, "trc:State", &a->State, "tt:RecordingJobStateInformation"))
				{	soap_flag_State--;
					continue;
				}
			soap_check_result(soap, "trc:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobStateResponse, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_new__trc__GetRecordingJobStateResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobStateResponse *p;
	struct _trc__GetRecordingJobStateResponse *a = (struct _trc__GetRecordingJobStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobStateResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobStateResponse(struct soap *soap, const struct _trc__GetRecordingJobStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobStateResponse(soap, tag ? tag : "trc:GetRecordingJobStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobState(struct soap *soap, const struct _trc__GetRecordingJobState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobState(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobState), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "trc:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_in__trc__GetRecordingJobState(struct soap *soap, const char *tag, struct _trc__GetRecordingJobState *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobState, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_new__trc__GetRecordingJobState(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobState *p;
	struct _trc__GetRecordingJobState *a = (struct _trc__GetRecordingJobState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobState));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobState(struct soap *soap, const struct _trc__GetRecordingJobState *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobState(soap, tag ? tag : "trc:GetRecordingJobState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_get__trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobModeResponse(struct soap *soap, const struct _trc__SetRecordingJobModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_in__trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobModeResponse, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_new__trc__SetRecordingJobModeResponse(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobModeResponse *p;
	struct _trc__SetRecordingJobModeResponse *a = (struct _trc__SetRecordingJobModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobModeResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobModeResponse(struct soap *soap, const struct _trc__SetRecordingJobModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobModeResponse(soap, tag ? tag : "trc:SetRecordingJobModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_get__trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	soap_default_tt__RecordingJobMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobMode(struct soap *soap, const struct _trc__SetRecordingJobMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_tt__RecordingJobMode(soap, (char*const*)&a->Mode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobMode(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobMode), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "trc:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->Mode)
	{	if (soap_element_nil(soap, "trc:Mode"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobMode(soap, "trc:Mode", -1, (char*const*)&a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_in__trc__SetRecordingJobMode(struct soap *soap, const char *tag, struct _trc__SetRecordingJobMode *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobMode(soap, "trc:Mode", (char**)&a->Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobMode, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_new__trc__SetRecordingJobMode(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobMode *p;
	struct _trc__SetRecordingJobMode *a = (struct _trc__SetRecordingJobMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobMode));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobMode(struct soap *soap, const struct _trc__SetRecordingJobMode *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobMode(soap, tag ? tag : "trc:SetRecordingJobMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_get__trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse), type))
		return soap->error;
	if (a->JobConfiguration)
		soap_element_result(soap, "trc:JobConfiguration");
	if (!a->JobConfiguration)
	{	if (soap_element_nil(soap, "trc:JobConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfigurationResponse *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:JobConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_new__trc__GetRecordingJobConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobConfigurationResponse *p;
	struct _trc__GetRecordingJobConfigurationResponse *a = (struct _trc__GetRecordingJobConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingJobConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobConfigurationResponse(soap, tag ? tag : "trc:GetRecordingJobConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobConfiguration(struct soap *soap, const struct _trc__GetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "trc:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_in__trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfiguration, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_new__trc__GetRecordingJobConfiguration(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobConfiguration *p;
	struct _trc__GetRecordingJobConfiguration *a = (struct _trc__GetRecordingJobConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobConfiguration(struct soap *soap, const struct _trc__GetRecordingJobConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobConfiguration(soap, tag ? tag : "trc:GetRecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_get__trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse), type))
		return soap->error;
	if (a->JobConfiguration)
		soap_element_result(soap, "trc:JobConfiguration");
	if (!a->JobConfiguration)
	{	if (soap_element_nil(soap, "trc:JobConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfigurationResponse *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:JobConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_new__trc__SetRecordingJobConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobConfigurationResponse *p;
	struct _trc__SetRecordingJobConfigurationResponse *a = (struct _trc__SetRecordingJobConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingJobConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobConfigurationResponse(soap, tag ? tag : "trc:SetRecordingJobConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobConfiguration(struct soap *soap, const struct _trc__SetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "trc:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_nil(soap, "trc:JobConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_in__trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_JobConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfiguration, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_new__trc__SetRecordingJobConfiguration(struct soap *soap, int n)
{
	struct _trc__SetRecordingJobConfiguration *p;
	struct _trc__SetRecordingJobConfiguration *a = (struct _trc__SetRecordingJobConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingJobConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingJobConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobConfiguration(struct soap *soap, const struct _trc__SetRecordingJobConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingJobConfiguration(soap, tag ? tag : "trc:SetRecordingJobConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_get__trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeJobItem = 0;
	a->JobItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobsResponse(struct soap *soap, const struct _trc__GetRecordingJobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->JobItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeJobItem; i++)
		{
			soap_embedded(soap, a->JobItem + i, SOAP_TYPE_tt__GetRecordingJobsResponseItem);
			soap_serialize_tt__GetRecordingJobsResponseItem(soap, a->JobItem + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeJobItem");
	if (a->JobItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeJobItem; i++)
			if (soap_out_tt__GetRecordingJobsResponseItem(soap, "trc:JobItem", -1, a->JobItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_JobItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:JobItem", 1, NULL))
			{	if (a->JobItem == NULL)
				{	if (soap_blist_JobItem == NULL)
						soap_blist_JobItem = soap_alloc_block(soap);
					a->JobItem = (struct tt__GetRecordingJobsResponseItem *)soap_push_block_max(soap, soap_blist_JobItem, sizeof(struct tt__GetRecordingJobsResponseItem));
					if (a->JobItem == NULL)
						return NULL;
					soap_default_tt__GetRecordingJobsResponseItem(soap, a->JobItem);
				}
				soap_revert(soap);
				if (soap_in_tt__GetRecordingJobsResponseItem(soap, "trc:JobItem", a->JobItem, "tt:GetRecordingJobsResponseItem"))
				{	a->__sizeJobItem++;
					a->JobItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeJobItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->JobItem)
			soap_pop_block(soap, soap_blist_JobItem);
		if (a->__sizeJobItem)
		{	a->JobItem = (struct tt__GetRecordingJobsResponseItem *)soap_save_block(soap, soap_blist_JobItem, NULL, 1);
		}
		else
		{	a->JobItem = NULL;
			if (soap_blist_JobItem)
				soap_end_block(soap, soap_blist_JobItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobsResponse, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_new__trc__GetRecordingJobsResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobsResponse *p;
	struct _trc__GetRecordingJobsResponse *a = (struct _trc__GetRecordingJobsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobsResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobsResponse(struct soap *soap, const struct _trc__GetRecordingJobsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobsResponse(soap, tag ? tag : "trc:GetRecordingJobsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobs(struct soap *soap, const struct _trc__GetRecordingJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobs(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_in__trc__GetRecordingJobs(struct soap *soap, const char *tag, struct _trc__GetRecordingJobs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobs, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_new__trc__GetRecordingJobs(struct soap *soap, int n)
{
	struct _trc__GetRecordingJobs *p;
	struct _trc__GetRecordingJobs *a = (struct _trc__GetRecordingJobs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingJobs));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingJobs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobs(struct soap *soap, const struct _trc__GetRecordingJobs *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingJobs(soap, tag ? tag : "trc:GetRecordingJobs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_get__trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingJobResponse(struct soap *soap, const struct _trc__DeleteRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_in__trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingJobResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJobResponse, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_new__trc__DeleteRecordingJobResponse(struct soap *soap, int n)
{
	struct _trc__DeleteRecordingJobResponse *p;
	struct _trc__DeleteRecordingJobResponse *a = (struct _trc__DeleteRecordingJobResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecordingJobResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecordingJobResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingJobResponse(struct soap *soap, const struct _trc__DeleteRecordingJobResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecordingJobResponse(soap, tag ? tag : "trc:DeleteRecordingJobResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_get__trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingJob(struct soap *soap, const struct _trc__DeleteRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingJob(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingJob), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "trc:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_in__trc__DeleteRecordingJob(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJob *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecordingJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingJob(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJob, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_new__trc__DeleteRecordingJob(struct soap *soap, int n)
{
	struct _trc__DeleteRecordingJob *p;
	struct _trc__DeleteRecordingJob *a = (struct _trc__DeleteRecordingJob*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecordingJob));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecordingJob(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingJob(struct soap *soap, const struct _trc__DeleteRecordingJob *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecordingJob(soap, tag ? tag : "trc:DeleteRecordingJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_get__trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingJobResponse(struct soap *soap, const struct _trc__CreateRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingJobResponse), type))
		return soap->error;
	if (a->JobToken)
		soap_element_result(soap, "trc:JobToken");
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "trc:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_nil(soap, "trc:JobConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_in__trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingJobResponse *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecordingJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingJobResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:JobToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_JobConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJobResponse, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_new__trc__CreateRecordingJobResponse(struct soap *soap, int n)
{
	struct _trc__CreateRecordingJobResponse *p;
	struct _trc__CreateRecordingJobResponse *a = (struct _trc__CreateRecordingJobResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecordingJobResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecordingJobResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingJobResponse(struct soap *soap, const struct _trc__CreateRecordingJobResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecordingJobResponse(soap, tag ? tag : "trc:CreateRecordingJobResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_get__trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingJob(struct soap *soap, const struct _trc__CreateRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingJob(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingJob), type))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_nil(soap, "trc:JobConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_in__trc__CreateRecordingJob(struct soap *soap, const char *tag, struct _trc__CreateRecordingJob *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecordingJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingJob(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJob, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_new__trc__CreateRecordingJob(struct soap *soap, int n)
{
	struct _trc__CreateRecordingJob *p;
	struct _trc__CreateRecordingJob *a = (struct _trc__CreateRecordingJob*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecordingJob));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecordingJob(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingJob(struct soap *soap, const struct _trc__CreateRecordingJob *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecordingJob(soap, tag ? tag : "trc:CreateRecordingJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_get__trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetTrackConfigurationResponse(struct soap *soap, const struct _trc__SetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetTrackConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetTrackConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetTrackConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfigurationResponse, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_new__trc__SetTrackConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__SetTrackConfigurationResponse *p;
	struct _trc__SetTrackConfigurationResponse *a = (struct _trc__SetTrackConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetTrackConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetTrackConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetTrackConfigurationResponse(struct soap *soap, const struct _trc__SetTrackConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetTrackConfigurationResponse(soap, tag ? tag : "trc:SetTrackConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetTrackConfiguration(struct soap *soap, const struct _trc__SetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetTrackConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetTrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetTrackConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "trc:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	if (!a->TrackConfiguration)
	{	if (soap_element_nil(soap, "trc:TrackConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_in__trc__SetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__SetTrackConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetTrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetTrackConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_TrackConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfiguration, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_new__trc__SetTrackConfiguration(struct soap *soap, int n)
{
	struct _trc__SetTrackConfiguration *p;
	struct _trc__SetTrackConfiguration *a = (struct _trc__SetTrackConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetTrackConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__SetTrackConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetTrackConfiguration(struct soap *soap, const struct _trc__SetTrackConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetTrackConfiguration(soap, tag ? tag : "trc:SetTrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_get__trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetTrackConfigurationResponse(struct soap *soap, const struct _trc__GetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetTrackConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse), type))
		return soap->error;
	if (a->TrackConfiguration)
		soap_element_result(soap, "trc:TrackConfiguration");
	if (!a->TrackConfiguration)
	{	if (soap_element_nil(soap, "trc:TrackConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetTrackConfigurationResponse *a, const char *type)
{
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetTrackConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:TrackConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfigurationResponse, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_new__trc__GetTrackConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__GetTrackConfigurationResponse *p;
	struct _trc__GetTrackConfigurationResponse *a = (struct _trc__GetTrackConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetTrackConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetTrackConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetTrackConfigurationResponse(struct soap *soap, const struct _trc__GetTrackConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetTrackConfigurationResponse(soap, tag ? tag : "trc:GetTrackConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetTrackConfiguration(struct soap *soap, const struct _trc__GetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetTrackConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetTrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetTrackConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "trc:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_in__trc__GetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__GetTrackConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetTrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetTrackConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfiguration, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_new__trc__GetTrackConfiguration(struct soap *soap, int n)
{
	struct _trc__GetTrackConfiguration *p;
	struct _trc__GetTrackConfiguration *a = (struct _trc__GetTrackConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetTrackConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__GetTrackConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetTrackConfiguration(struct soap *soap, const struct _trc__GetTrackConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetTrackConfiguration(soap, tag ? tag : "trc:GetTrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_get__trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteTrackResponse(struct soap *soap, const struct _trc__DeleteTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteTrackResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteTrackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteTrackResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_in__trc__DeleteTrackResponse(struct soap *soap, const char *tag, struct _trc__DeleteTrackResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteTrackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteTrackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrackResponse, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_new__trc__DeleteTrackResponse(struct soap *soap, int n)
{
	struct _trc__DeleteTrackResponse *p;
	struct _trc__DeleteTrackResponse *a = (struct _trc__DeleteTrackResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteTrackResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteTrackResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteTrackResponse(struct soap *soap, const struct _trc__DeleteTrackResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteTrackResponse(soap, tag ? tag : "trc:DeleteTrackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_get__trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteTrack(struct soap *soap, const struct _trc__DeleteTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteTrack(struct soap *soap, const char *tag, int id, const struct _trc__DeleteTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteTrack), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "trc:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_in__trc__DeleteTrack(struct soap *soap, const char *tag, struct _trc__DeleteTrack *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteTrack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrack, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_new__trc__DeleteTrack(struct soap *soap, int n)
{
	struct _trc__DeleteTrack *p;
	struct _trc__DeleteTrack *a = (struct _trc__DeleteTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteTrack));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteTrack(struct soap *soap, const struct _trc__DeleteTrack *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteTrack(soap, tag ? tag : "trc:DeleteTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_get__trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateTrackResponse(struct soap *soap, const struct _trc__CreateTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateTrackResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateTrackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateTrackResponse), type))
		return soap->error;
	if (a->TrackToken)
		soap_element_result(soap, "trc:TrackToken");
	if (!a->TrackToken)
	{	if (soap_element_nil(soap, "trc:TrackToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, (char*const*)&a->TrackToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_in__trc__CreateTrackResponse(struct soap *soap, const char *tag, struct _trc__CreateTrackResponse *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateTrackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateTrackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", (char**)&a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			soap_check_result(soap, "trc:TrackToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrackResponse, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_new__trc__CreateTrackResponse(struct soap *soap, int n)
{
	struct _trc__CreateTrackResponse *p;
	struct _trc__CreateTrackResponse *a = (struct _trc__CreateTrackResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateTrackResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateTrackResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateTrackResponse(struct soap *soap, const struct _trc__CreateTrackResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateTrackResponse(soap, tag ? tag : "trc:CreateTrackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_get__trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateTrack(struct soap *soap, const struct _trc__CreateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateTrack(struct soap *soap, const char *tag, int id, const struct _trc__CreateTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateTrack), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->TrackConfiguration)
	{	if (soap_element_nil(soap, "trc:TrackConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_in__trc__CreateTrack(struct soap *soap, const char *tag, struct _trc__CreateTrack *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateTrack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrack, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_new__trc__CreateTrack(struct soap *soap, int n)
{
	struct _trc__CreateTrack *p;
	struct _trc__CreateTrack *a = (struct _trc__CreateTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateTrack));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateTrack(struct soap *soap, const struct _trc__CreateTrack *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateTrack(soap, tag ? tag : "trc:CreateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_get__trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse), type))
		return soap->error;
	if (a->RecordingConfiguration)
		soap_element_result(soap, "trc:RecordingConfiguration");
	if (!a->RecordingConfiguration)
	{	if (soap_element_nil(soap, "trc:RecordingConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingConfigurationResponse *a, const char *type)
{
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:RecordingConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfigurationResponse, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_new__trc__GetRecordingConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingConfigurationResponse *p;
	struct _trc__GetRecordingConfigurationResponse *a = (struct _trc__GetRecordingConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingConfigurationResponse(soap, tag ? tag : "trc:GetRecordingConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingConfiguration(struct soap *soap, const struct _trc__GetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_in__trc__GetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfiguration, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_new__trc__GetRecordingConfiguration(struct soap *soap, int n)
{
	struct _trc__GetRecordingConfiguration *p;
	struct _trc__GetRecordingConfiguration *a = (struct _trc__GetRecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingConfiguration(struct soap *soap, const struct _trc__GetRecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingConfiguration(soap, tag ? tag : "trc:GetRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_get__trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfigurationResponse, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_new__trc__SetRecordingConfigurationResponse(struct soap *soap, int n)
{
	struct _trc__SetRecordingConfigurationResponse *p;
	struct _trc__SetRecordingConfigurationResponse *a = (struct _trc__SetRecordingConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingConfigurationResponse(soap, tag ? tag : "trc:SetRecordingConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingConfiguration(struct soap *soap, const struct _trc__SetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingConfiguration), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->RecordingConfiguration)
	{	if (soap_element_nil(soap, "trc:RecordingConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_in__trc__SetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_RecordingConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfiguration, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_new__trc__SetRecordingConfiguration(struct soap *soap, int n)
{
	struct _trc__SetRecordingConfiguration *p;
	struct _trc__SetRecordingConfiguration *a = (struct _trc__SetRecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__SetRecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trc__SetRecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingConfiguration(struct soap *soap, const struct _trc__SetRecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trc__SetRecordingConfiguration(soap, tag ? tag : "trc:SetRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_get__trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRecordingItem = 0;
	a->RecordingItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingsResponse(struct soap *soap, const struct _trc__GetRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RecordingItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingItem; i++)
		{
			soap_embedded(soap, a->RecordingItem + i, SOAP_TYPE_tt__GetRecordingsResponseItem);
			soap_serialize_tt__GetRecordingsResponseItem(soap, a->RecordingItem + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRecordingItem");
	if (a->RecordingItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingItem; i++)
			if (soap_out_tt__GetRecordingsResponseItem(soap, "trc:RecordingItem", -1, a->RecordingItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RecordingItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:RecordingItem", 1, NULL))
			{	if (a->RecordingItem == NULL)
				{	if (soap_blist_RecordingItem == NULL)
						soap_blist_RecordingItem = soap_alloc_block(soap);
					a->RecordingItem = (struct tt__GetRecordingsResponseItem *)soap_push_block_max(soap, soap_blist_RecordingItem, sizeof(struct tt__GetRecordingsResponseItem));
					if (a->RecordingItem == NULL)
						return NULL;
					soap_default_tt__GetRecordingsResponseItem(soap, a->RecordingItem);
				}
				soap_revert(soap);
				if (soap_in_tt__GetRecordingsResponseItem(soap, "trc:RecordingItem", a->RecordingItem, "tt:GetRecordingsResponseItem"))
				{	a->__sizeRecordingItem++;
					a->RecordingItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRecordingItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingItem)
			soap_pop_block(soap, soap_blist_RecordingItem);
		if (a->__sizeRecordingItem)
		{	a->RecordingItem = (struct tt__GetRecordingsResponseItem *)soap_save_block(soap, soap_blist_RecordingItem, NULL, 1);
		}
		else
		{	a->RecordingItem = NULL;
			if (soap_blist_RecordingItem)
				soap_end_block(soap, soap_blist_RecordingItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingsResponse, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_new__trc__GetRecordingsResponse(struct soap *soap, int n)
{
	struct _trc__GetRecordingsResponse *p;
	struct _trc__GetRecordingsResponse *a = (struct _trc__GetRecordingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordingsResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingsResponse(struct soap *soap, const struct _trc__GetRecordingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordingsResponse(soap, tag ? tag : "trc:GetRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
