/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->StreamingCapabilities = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &a->StreamingCapabilities);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (!a->StreamingCapabilities)
	{	if (soap_element_nil(soap, "tt:StreamingCapabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_StreamingCapabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_new_tt__MediaCapabilities(struct soap *soap, int n)
{
	struct tt__MediaCapabilities *p;
	struct tt__MediaCapabilities *a = (struct tt__MediaCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingCapabilities(struct soap *soap, const struct tt__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ImagingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, struct tt__ImagingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_new_tt__ImagingCapabilities(struct soap *soap, int n)
{
	struct tt__ImagingCapabilities *p;
	struct tt__ImagingCapabilities *a = (struct tt__ImagingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingCapabilities(struct soap *soap, const struct tt__ImagingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->WSSubscriptionPolicySupport);
	soap_default_xsd__boolean(soap, &a->WSPullPointSupport);
	soap_default_xsd__boolean(soap, &a->WSPausableSubscriptionManagerInterfaceSupport);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->WSSubscriptionPolicySupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WSPullPointSupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const struct tt__EventCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WSSubscriptionPolicySupport", -1, &a->WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WSPullPointSupport", -1, &a->WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_WSSubscriptionPolicySupport = 1;
	size_t soap_flag_WSPullPointSupport = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_WSSubscriptionPolicySupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:WSSubscriptionPolicySupport", &a->WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport--;
					continue;
				}
			if (soap_flag_WSPullPointSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:WSPullPointSupport", &a->WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport--;
					continue;
				}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_WSSubscriptionPolicySupport > 0 || soap_flag_WSPullPointSupport > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_new_tt__EventCapabilities(struct soap *soap, int n)
{
	struct tt__EventCapabilities *p;
	struct tt__EventCapabilities *a = (struct tt__EventCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__EventCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->Network = NULL;
	a->System = NULL;
	a->IO = NULL;
	a->Security = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &a->System);
	soap_serialize_PointerTott__IOCapabilities(soap, &a->IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &a->Network, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->System, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &a->IO, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &a->Security, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Network = 1;
	size_t soap_flag_System = 1;
	size_t soap_flag_IO = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &a->Network, "tt:NetworkCapabilities"))
				{	soap_flag_Network--;
					continue;
				}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->System, "tt:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			if (soap_flag_IO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &a->IO, "tt:IOCapabilities"))
				{	soap_flag_IO--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &a->Security, "tt:SecurityCapabilities"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_new_tt__DeviceCapabilities(struct soap *soap, int n)
{
	struct tt__DeviceCapabilities *p;
	struct tt__DeviceCapabilities *a = (struct tt__DeviceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DeviceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__DeviceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->RuleSupport);
	soap_default_xsd__boolean(soap, &a->AnalyticsModuleSupport);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsCapabilities(struct soap *soap, const struct tt__AnalyticsCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->RuleSupport, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->AnalyticsModuleSupport, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:RuleSupport", -1, &a->RuleSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AnalyticsModuleSupport", -1, &a->AnalyticsModuleSupport, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RuleSupport = 1;
	size_t soap_flag_AnalyticsModuleSupport = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RuleSupport", &a->RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport--;
					continue;
				}
			if (soap_flag_AnalyticsModuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AnalyticsModuleSupport", &a->AnalyticsModuleSupport, "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_RuleSupport > 0 || soap_flag_AnalyticsModuleSupport > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities * SOAP_FMAC4 soap_new_tt__AnalyticsCapabilities(struct soap *soap, int n)
{
	struct tt__AnalyticsCapabilities *p;
	struct tt__AnalyticsCapabilities *a = (struct tt__AnalyticsCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsCapabilities(struct soap *soap, const struct tt__AnalyticsCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Capabilities(struct soap *soap, struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Analytics = NULL;
	a->Device = NULL;
	a->Events = NULL;
	a->Imaging = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &a->Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &a->Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &a->PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities *a, const char *type)
{
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device--;
					continue;
				}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->Events, "tt:EventCapabilities"))
				{	soap_flag_Events--;
					continue;
				}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->Media, "tt:MediaCapabilities"))
				{	soap_flag_Media--;
					continue;
				}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_new_tt__Capabilities(struct soap *soap, int n)
{
	struct tt__Capabilities *p;
	struct tt__Capabilities *a = (struct tt__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, struct tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11AvailableNetworksExtension(struct soap *soap, const struct tt__Dot11AvailableNetworksExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11AvailableNetworksExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11AvailableNetworksExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworksExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_new_tt__Dot11AvailableNetworksExtension(struct soap *soap, int n)
{
	struct tt__Dot11AvailableNetworksExtension *p;
	struct tt__Dot11AvailableNetworksExtension *a = (struct tt__Dot11AvailableNetworksExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11AvailableNetworksExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11AvailableNetworksExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AvailableNetworksExtension(struct soap *soap, const struct tt__Dot11AvailableNetworksExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_string(soap, &a->BSSID);
	a->__sizeAuthAndMangementSuite = 0;
	a->AuthAndMangementSuite = NULL;
	a->__sizePairCipher = 0;
	a->PairCipher = NULL;
	a->__sizeGroupCipher = 0;
	a->GroupCipher = NULL;
	a->SignalStrength = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11AvailableNetworks(struct soap *soap, const struct tt__Dot11AvailableNetworks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_string(soap, (char*const*)&a->BSSID);
	if (a->AuthAndMangementSuite)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthAndMangementSuite; i++)
		{
			soap_embedded(soap, a->AuthAndMangementSuite + i, SOAP_TYPE_tt__Dot11AuthAndMangementSuite);
		}
	}
	if (a->PairCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizePairCipher; i++)
		{
			soap_embedded(soap, a->PairCipher + i, SOAP_TYPE_tt__Dot11Cipher);
		}
	}
	if (a->GroupCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizeGroupCipher; i++)
		{
			soap_embedded(soap, a->GroupCipher + i, SOAP_TYPE_tt__Dot11Cipher);
		}
	}
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &a->SignalStrength);
	soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const struct tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworks), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:BSSID", -1, (char*const*)&a->BSSID, ""))
		return soap->error;
	if (a->AuthAndMangementSuite)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthAndMangementSuite; i++)
			if (soap_out_tt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", -1, a->AuthAndMangementSuite + i, ""))
				return soap->error;
	}
	if (a->PairCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizePairCipher; i++)
			if (soap_out_tt__Dot11Cipher(soap, "tt:PairCipher", -1, a->PairCipher + i, ""))
				return soap->error;
	}
	if (a->GroupCipher)
	{	int i;
		for (i = 0; i < (int)a->__sizeGroupCipher; i++)
			if (soap_out_tt__Dot11Cipher(soap, "tt:GroupCipher", -1, a->GroupCipher + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->SignalStrength, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_BSSID = 1;
	struct soap_blist *soap_blist_AuthAndMangementSuite = NULL;
	struct soap_blist *soap_blist_PairCipher = NULL;
	struct soap_blist *soap_blist_GroupCipher = NULL;
	size_t soap_flag_SignalStrength = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11AvailableNetworks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11AvailableNetworks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:BSSID", (char**)&a->BSSID, "xsd:string"))
				{	soap_flag_BSSID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuthAndMangementSuite", 1, NULL))
			{	if (a->AuthAndMangementSuite == NULL)
				{	if (soap_blist_AuthAndMangementSuite == NULL)
						soap_blist_AuthAndMangementSuite = soap_alloc_block(soap);
					a->AuthAndMangementSuite = (enum tt__Dot11AuthAndMangementSuite *)soap_push_block_max(soap, soap_blist_AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite));
					if (a->AuthAndMangementSuite == NULL)
						return NULL;
					soap_default_tt__Dot11AuthAndMangementSuite(soap, a->AuthAndMangementSuite);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", a->AuthAndMangementSuite, "tt:Dot11AuthAndMangementSuite"))
				{	a->__sizeAuthAndMangementSuite++;
					a->AuthAndMangementSuite = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PairCipher", 1, NULL))
			{	if (a->PairCipher == NULL)
				{	if (soap_blist_PairCipher == NULL)
						soap_blist_PairCipher = soap_alloc_block(soap);
					a->PairCipher = (enum tt__Dot11Cipher *)soap_push_block_max(soap, soap_blist_PairCipher, sizeof(enum tt__Dot11Cipher));
					if (a->PairCipher == NULL)
						return NULL;
					soap_default_tt__Dot11Cipher(soap, a->PairCipher);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Cipher(soap, "tt:PairCipher", a->PairCipher, "tt:Dot11Cipher"))
				{	a->__sizePairCipher++;
					a->PairCipher = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:GroupCipher", 1, NULL))
			{	if (a->GroupCipher == NULL)
				{	if (soap_blist_GroupCipher == NULL)
						soap_blist_GroupCipher = soap_alloc_block(soap);
					a->GroupCipher = (enum tt__Dot11Cipher *)soap_push_block_max(soap, soap_blist_GroupCipher, sizeof(enum tt__Dot11Cipher));
					if (a->GroupCipher == NULL)
						return NULL;
					soap_default_tt__Dot11Cipher(soap, a->GroupCipher);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Cipher(soap, "tt:GroupCipher", a->GroupCipher, "tt:Dot11Cipher"))
				{	a->__sizeGroupCipher++;
					a->GroupCipher = NULL;
					continue;
				}
			}
			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11AvailableNetworksExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuthAndMangementSuite)
			soap_pop_block(soap, soap_blist_AuthAndMangementSuite);
		if (a->__sizeAuthAndMangementSuite)
		{	a->AuthAndMangementSuite = (enum tt__Dot11AuthAndMangementSuite *)soap_save_block(soap, soap_blist_AuthAndMangementSuite, NULL, 1);
		}
		else
		{	a->AuthAndMangementSuite = NULL;
			if (soap_blist_AuthAndMangementSuite)
				soap_end_block(soap, soap_blist_AuthAndMangementSuite);
		}
		if (a->PairCipher)
			soap_pop_block(soap, soap_blist_PairCipher);
		if (a->__sizePairCipher)
		{	a->PairCipher = (enum tt__Dot11Cipher *)soap_save_block(soap, soap_blist_PairCipher, NULL, 1);
		}
		else
		{	a->PairCipher = NULL;
			if (soap_blist_PairCipher)
				soap_end_block(soap, soap_blist_PairCipher);
		}
		if (a->GroupCipher)
			soap_pop_block(soap, soap_blist_GroupCipher);
		if (a->__sizeGroupCipher)
		{	a->GroupCipher = (enum tt__Dot11Cipher *)soap_save_block(soap, soap_blist_GroupCipher, NULL, 1);
		}
		else
		{	a->GroupCipher = NULL;
			if (soap_blist_GroupCipher)
				soap_end_block(soap, soap_blist_GroupCipher);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_new_tt__Dot11AvailableNetworks(struct soap *soap, int n)
{
	struct tt__Dot11AvailableNetworks *p;
	struct tt__Dot11AvailableNetworks *a = (struct tt__Dot11AvailableNetworks*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11AvailableNetworks));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11AvailableNetworks(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AvailableNetworks(struct soap *soap, const struct tt__Dot11AvailableNetworks *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Status(struct soap *soap, struct tt__Dot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_string(soap, &a->BSSID);
	a->PairCipher = NULL;
	a->GroupCipher = NULL;
	a->SignalStrength = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ActiveConfigAlias);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Status(struct soap *soap, const struct tt__Dot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_string(soap, (char*const*)&a->BSSID);
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->PairCipher);
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &a->SignalStrength);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ActiveConfigAlias);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Status(struct soap *soap, const char *tag, int id, const struct tt__Dot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Status), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:BSSID", -1, (char*const*)&a->BSSID, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:PairCipher", -1, &a->PairCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->SignalStrength, ""))
		return soap->error;
	if (!a->ActiveConfigAlias)
	{	if (soap_element_nil(soap, "tt:ActiveConfigAlias"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", -1, (char*const*)&a->ActiveConfigAlias, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_in_tt__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_BSSID = 1;
	size_t soap_flag_PairCipher = 1;
	size_t soap_flag_GroupCipher = 1;
	size_t soap_flag_SignalStrength = 1;
	size_t soap_flag_ActiveConfigAlias = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:BSSID", (char**)&a->BSSID, "xsd:string"))
				{	soap_flag_BSSID--;
					continue;
				}
			if (soap_flag_PairCipher && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Cipher(soap, "tt:PairCipher", &a->PairCipher, "tt:Dot11Cipher"))
				{	soap_flag_PairCipher--;
					continue;
				}
			if (soap_flag_GroupCipher && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", &a->GroupCipher, "tt:Dot11Cipher"))
				{	soap_flag_GroupCipher--;
					continue;
				}
			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength--;
					continue;
				}
			if (soap_flag_ActiveConfigAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", (char**)&a->ActiveConfigAlias, "tt:ReferenceToken"))
				{	soap_flag_ActiveConfigAlias--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || soap_flag_ActiveConfigAlias > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_new_tt__Dot11Status(struct soap *soap, int n)
{
	struct tt__Dot11Status *p;
	struct tt__Dot11Status *a = (struct tt__Dot11Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11Status));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Status(struct soap *soap, const struct tt__Dot11Status *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_get_tt__Dot11Status(struct soap *soap, struct tt__Dot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TKIP);
	soap_default_xsd__boolean(soap, &a->ScanAvailableNetworks);
	soap_default_xsd__boolean(soap, &a->MultipleConfiguration);
	soap_default_xsd__boolean(soap, &a->AdHocStationMode);
	soap_default_xsd__boolean(soap, &a->WEP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Capabilities(struct soap *soap, const struct tt__Dot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TKIP, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->ScanAvailableNetworks, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->MultipleConfiguration, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->AdHocStationMode, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->WEP, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Dot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Capabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:TKIP", -1, &a->TKIP, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:ScanAvailableNetworks", -1, &a->ScanAvailableNetworks, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:MultipleConfiguration", -1, &a->MultipleConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AdHocStationMode", -1, &a->AdHocStationMode, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:WEP", -1, &a->WEP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_in_tt__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities *a, const char *type)
{
	size_t soap_flag_TKIP = 1;
	size_t soap_flag_ScanAvailableNetworks = 1;
	size_t soap_flag_MultipleConfiguration = 1;
	size_t soap_flag_AdHocStationMode = 1;
	size_t soap_flag_WEP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TKIP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:TKIP", &a->TKIP, "xsd:boolean"))
				{	soap_flag_TKIP--;
					continue;
				}
			if (soap_flag_ScanAvailableNetworks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:ScanAvailableNetworks", &a->ScanAvailableNetworks, "xsd:boolean"))
				{	soap_flag_ScanAvailableNetworks--;
					continue;
				}
			if (soap_flag_MultipleConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:MultipleConfiguration", &a->MultipleConfiguration, "xsd:boolean"))
				{	soap_flag_MultipleConfiguration--;
					continue;
				}
			if (soap_flag_AdHocStationMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AdHocStationMode", &a->AdHocStationMode, "xsd:boolean"))
				{	soap_flag_AdHocStationMode--;
					continue;
				}
			if (soap_flag_WEP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:WEP", &a->WEP, "xsd:boolean"))
				{	soap_flag_WEP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TKIP > 0 || soap_flag_ScanAvailableNetworks > 0 || soap_flag_MultipleConfiguration > 0 || soap_flag_AdHocStationMode > 0 || soap_flag_WEP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_new_tt__Dot11Capabilities(struct soap *soap, int n)
{
	struct tt__Dot11Capabilities *p;
	struct tt__Dot11Capabilities *a = (struct tt__Dot11Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Capabilities(struct soap *soap, const struct tt__Dot11Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_get_tt__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKSetExtension(struct soap *soap, const struct tt__Dot11PSKSetExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSetExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_in_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, struct tt__Dot11PSKSetExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11PSKSetExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSKSetExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSetExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSetExtension, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_new_tt__Dot11PSKSetExtension(struct soap *soap, int n)
{
	struct tt__Dot11PSKSetExtension *p;
	struct tt__Dot11PSKSetExtension *a = (struct tt__Dot11PSKSetExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11PSKSetExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11PSKSetExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKSetExtension(struct soap *soap, const struct tt__Dot11PSKSetExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_get_tt__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const struct tt__Dot11SecurityConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SecurityConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_new_tt__Dot11SecurityConfigurationExtension(struct soap *soap, int n)
{
	struct tt__Dot11SecurityConfigurationExtension *p;
	struct tt__Dot11SecurityConfigurationExtension *a = (struct tt__Dot11SecurityConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11SecurityConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11SecurityConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const struct tt__Dot11SecurityConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11PSK(soap, &a->Key);
	soap_default_tt__Dot11PSKPassphrase(soap, &a->Passphrase);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKSet(struct soap *soap, const struct tt__Dot11PSKSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11PSK(soap, &a->Key);
	soap_serialize_tt__Dot11PSKPassphrase(soap, (char*const*)&a->Passphrase);
	soap_serialize_PointerTott__Dot11PSKSetExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSet(struct soap *soap, const char *tag, int id, const struct tt__Dot11PSKSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSet), type))
		return soap->error;
	if (soap_out_tt__Dot11PSK(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_tt__Dot11PSKPassphrase(soap, "tt:Passphrase", -1, (char*const*)&a->Passphrase, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_in_tt__Dot11PSKSet(struct soap *soap, const char *tag, struct tt__Dot11PSKSet *a, const char *type)
{
	size_t soap_flag_Key = 1;
	size_t soap_flag_Passphrase = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11PSKSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSKSet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11PSK(soap, "tt:Key", &a->Key, "tt:Dot11PSK"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Passphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Dot11PSKPassphrase(soap, "tt:Passphrase", (char**)&a->Passphrase, "tt:Dot11PSKPassphrase"))
				{	soap_flag_Passphrase--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11PSKSetExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_new_tt__Dot11PSKSet(struct soap *soap, int n)
{
	struct tt__Dot11PSKSet *p;
	struct tt__Dot11PSKSet *a = (struct tt__Dot11PSKSet*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11PSKSet));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11PSKSet(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKSet(struct soap *soap, const struct tt__Dot11PSKSet *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_get_tt__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SecurityMode(soap, &a->Mode);
	a->Algorithm = NULL;
	a->PSK = NULL;
	soap_default_tt__ReferenceToken(soap, &a->Dot1X);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SecurityConfiguration(struct soap *soap, const struct tt__Dot11SecurityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->Algorithm);
	soap_serialize_PointerTott__Dot11PSKSet(soap, &a->PSK);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Dot1X);
	soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, const struct tt__Dot11SecurityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration), type))
		return soap->error;
	if (soap_out_tt__Dot11SecurityMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:Algorithm", -1, &a->Algorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSet(soap, "tt:PSK", -1, &a->PSK, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1X", -1, (char*const*)&a->Dot1X, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfiguration *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Algorithm = 1;
	size_t soap_flag_PSK = 1;
	size_t soap_flag_Dot1X = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11SecurityConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SecurityConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SecurityMode(soap, "tt:Mode", &a->Mode, "tt:Dot11SecurityMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Algorithm && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Cipher(soap, "tt:Algorithm", &a->Algorithm, "tt:Dot11Cipher"))
				{	soap_flag_Algorithm--;
					continue;
				}
			if (soap_flag_PSK && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11PSKSet(soap, "tt:PSK", &a->PSK, "tt:Dot11PSKSet"))
				{	soap_flag_PSK--;
					continue;
				}
			if (soap_flag_Dot1X && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Dot1X", (char**)&a->Dot1X, "tt:ReferenceToken"))
				{	soap_flag_Dot1X--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11SecurityConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_new_tt__Dot11SecurityConfiguration(struct soap *soap, int n)
{
	struct tt__Dot11SecurityConfiguration *p;
	struct tt__Dot11SecurityConfiguration *a = (struct tt__Dot11SecurityConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11SecurityConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11SecurityConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityConfiguration(struct soap *soap, const struct tt__Dot11SecurityConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilterExtension(struct soap *soap, const struct tt__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilterExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, struct tt__IPAddressFilterExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddressFilterExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddressFilterExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_new_tt__IPAddressFilterExtension(struct soap *soap, int n)
{
	struct tt__IPAddressFilterExtension *p;
	struct tt__IPAddressFilterExtension *a = (struct tt__IPAddressFilterExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPAddressFilterExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddressFilterExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterExtension(struct soap *soap, const struct tt__IPAddressFilterExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPAddressFilterType(soap, &a->Type);
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
		{
			soap_embedded(soap, a->IPv4Address + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
		{
			soap_embedded(soap, a->IPv6Address + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->IPv6Address + i);
		}
	}
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter *a, const char *type)
{
	size_t soap_flag_Type = 1;
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_alloc_block(soap);
					a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_push_block_max(soap, soap_blist_IPv4Address, sizeof(struct tt__PrefixedIPv4Address));
					if (a->IPv4Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->IPv4Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", a->IPv4Address, "tt:PrefixedIPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_alloc_block(soap);
					a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_IPv6Address, sizeof(struct tt__PrefixedIPv6Address));
					if (a->IPv6Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->IPv6Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", a->IPv6Address, "tt:PrefixedIPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->Extension, "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
		{	a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		}
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
		{	a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		}
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_new_tt__IPAddressFilter(struct soap *soap, int n)
{
	struct tt__IPAddressFilter *p;
	struct tt__IPAddressFilter *a = (struct tt__IPAddressFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPAddressFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddressFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkZeroConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_new_tt__NetworkZeroConfigurationExtension2(struct soap *soap, int n)
{
	struct tt__NetworkZeroConfigurationExtension2 *p;
	struct tt__NetworkZeroConfigurationExtension2 *a = (struct tt__NetworkZeroConfigurationExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkZeroConfigurationExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkZeroConfigurationExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAdditional = 0;
	a->Additional = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfigurationExtension(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Additional)
	{	int i;
		for (i = 0; i < (int)a->__sizeAdditional; i++)
		{
			soap_embedded(soap, a->Additional + i, SOAP_TYPE_tt__NetworkZeroConfiguration);
			soap_serialize_tt__NetworkZeroConfiguration(soap, a->Additional + i);
		}
	}
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension), type))
		return soap->error;
	if (a->Additional)
	{	int i;
		for (i = 0; i < (int)a->__sizeAdditional; i++)
			if (soap_out_tt__NetworkZeroConfiguration(soap, "tt:Additional", -1, a->Additional + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist_Additional = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkZeroConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Additional", 1, NULL))
			{	if (a->Additional == NULL)
				{	if (soap_blist_Additional == NULL)
						soap_blist_Additional = soap_alloc_block(soap);
					a->Additional = (struct tt__NetworkZeroConfiguration *)soap_push_block_max(soap, soap_blist_Additional, sizeof(struct tt__NetworkZeroConfiguration));
					if (a->Additional == NULL)
						return NULL;
					soap_default_tt__NetworkZeroConfiguration(soap, a->Additional);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkZeroConfiguration(soap, "tt:Additional", a->Additional, "tt:NetworkZeroConfiguration"))
				{	a->__sizeAdditional++;
					a->Additional = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkZeroConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Additional)
			soap_pop_block(soap, soap_blist_Additional);
		if (a->__sizeAdditional)
		{	a->Additional = (struct tt__NetworkZeroConfiguration *)soap_save_block(soap, soap_blist_Additional, NULL, 1);
		}
		else
		{	a->Additional = NULL;
			if (soap_blist_Additional)
				soap_end_block(soap, soap_blist_Additional);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_new_tt__NetworkZeroConfigurationExtension(struct soap *soap, int n)
{
	struct tt__NetworkZeroConfigurationExtension *p;
	struct tt__NetworkZeroConfigurationExtension *a = (struct tt__NetworkZeroConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkZeroConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkZeroConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfigurationExtension(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->__sizeAddresses = 0;
	a->Addresses = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfiguration(struct soap *soap, const struct tt__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	if (a->Addresses)
	{	int i;
		for (i = 0; i < (int)a->__sizeAddresses; i++)
		{
			soap_serialize_tt__IPv4Address(soap, (char*const*)(a->Addresses + i));
		}
	}
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_nil(soap, "tt:InterfaceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Addresses)
	{	int i;
		for (i = 0; i < (int)a->__sizeAddresses; i++)
			soap_out_string(soap, "tt:Addresses", -1, (char*const*)(a->Addresses + i), "");
	}
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct tt__NetworkZeroConfiguration *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Addresses = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Addresses", 1, NULL))
			{	if (a->Addresses == NULL)
				{	if (soap_blist_Addresses == NULL)
						soap_blist_Addresses = soap_alloc_block(soap);
					a->Addresses = (char **)soap_push_block_max(soap, soap_blist_Addresses, sizeof(char *));
					if (a->Addresses == NULL)
						return NULL;
					*a->Addresses = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:Addresses", (char**)a->Addresses, "tt:IPv4Address"))
				{	a->__sizeAddresses++;
					a->Addresses = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Addresses)
			soap_pop_block(soap, soap_blist_Addresses);
		if (a->__sizeAddresses)
		{	a->Addresses = (char **)soap_save_block(soap, soap_blist_Addresses, NULL, 1);
		}
		else
		{	a->Addresses = NULL;
			if (soap_blist_Addresses)
				soap_end_block(soap, soap_blist_Addresses);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_new_tt__NetworkZeroConfiguration(struct soap *soap, int n)
{
	struct tt__NetworkZeroConfiguration *p;
	struct tt__NetworkZeroConfiguration *a = (struct tt__NetworkZeroConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkZeroConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkZeroConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfiguration(struct soap *soap, const struct tt__NetworkZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, (char*const*)(a->IPv4Address + i));
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, (char*const*)(a->IPv6Address + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const struct tt__NetworkGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
			soap_out_string(soap, "tt:IPv4Address", -1, (char*const*)(a->IPv4Address + i), "");
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
			soap_out_string(soap, "tt:IPv6Address", -1, (char*const*)(a->IPv6Address + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_alloc_block(soap);
					a->IPv4Address = (char **)soap_push_block_max(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)a->IPv4Address, "tt:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_alloc_block(soap);
					a->IPv6Address = (char **)soap_push_block_max(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)a->IPv6Address, "tt:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
		{	a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		}
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
		{	a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		}
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_new_tt__NetworkGateway(struct soap *soap, int n)
{
	struct tt__NetworkGateway *p;
	struct tt__NetworkGateway *a = (struct tt__NetworkGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkGateway));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_new_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceSetConfigurationExtension2 *p;
	struct tt__NetworkInterfaceSetConfigurationExtension2 *a = (struct tt__NetworkInterfaceSetConfigurationExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceSetConfigurationExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot3 = 0;
	a->Dot3 = NULL;
	a->__sizeDot11 = 0;
	a->Dot11 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Dot3)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot3; i++)
		{
			soap_embedded(soap, a->Dot3 + i, SOAP_TYPE_tt__Dot3Configuration);
			soap_serialize_tt__Dot3Configuration(soap, a->Dot3 + i);
		}
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot11; i++)
		{
			soap_embedded(soap, a->Dot11 + i, SOAP_TYPE_tt__Dot11Configuration);
			soap_serialize_tt__Dot11Configuration(soap, a->Dot11 + i);
		}
	}
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (a->Dot3)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot3; i++)
			if (soap_out_tt__Dot3Configuration(soap, "tt:Dot3", -1, a->Dot3 + i, ""))
				return soap->error;
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot11; i++)
			if (soap_out_tt__Dot11Configuration(soap, "tt:Dot11", -1, a->Dot11 + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist_Dot3 = NULL;
	struct soap_blist *soap_blist_Dot11 = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
			{	if (a->Dot3 == NULL)
				{	if (soap_blist_Dot3 == NULL)
						soap_blist_Dot3 = soap_alloc_block(soap);
					a->Dot3 = (struct tt__Dot3Configuration *)soap_push_block_max(soap, soap_blist_Dot3, sizeof(struct tt__Dot3Configuration));
					if (a->Dot3 == NULL)
						return NULL;
					soap_default_tt__Dot3Configuration(soap, a->Dot3);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot3Configuration(soap, "tt:Dot3", a->Dot3, "tt:Dot3Configuration"))
				{	a->__sizeDot3++;
					a->Dot3 = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
			{	if (a->Dot11 == NULL)
				{	if (soap_blist_Dot11 == NULL)
						soap_blist_Dot11 = soap_alloc_block(soap);
					a->Dot11 = (struct tt__Dot11Configuration *)soap_push_block_max(soap, soap_blist_Dot11, sizeof(struct tt__Dot11Configuration));
					if (a->Dot11 == NULL)
						return NULL;
					soap_default_tt__Dot11Configuration(soap, a->Dot11);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Configuration(soap, "tt:Dot11", a->Dot11, "tt:Dot11Configuration"))
				{	a->__sizeDot11++;
					a->Dot11 = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot3)
			soap_pop_block(soap, soap_blist_Dot3);
		if (a->__sizeDot3)
		{	a->Dot3 = (struct tt__Dot3Configuration *)soap_save_block(soap, soap_blist_Dot3, NULL, 1);
		}
		else
		{	a->Dot3 = NULL;
			if (soap_blist_Dot3)
				soap_end_block(soap, soap_blist_Dot3);
		}
		if (a->Dot11)
			soap_pop_block(soap, soap_blist_Dot11);
		if (a->__sizeDot11)
		{	a->Dot11 = (struct tt__Dot11Configuration *)soap_save_block(soap, soap_blist_Dot11, NULL, 1);
		}
		else
		{	a->Dot11 = NULL;
			if (soap_blist_Dot11)
				soap_end_block(soap, soap_blist_Dot11);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_new_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceSetConfigurationExtension *p;
	struct tt__NetworkInterfaceSetConfigurationExtension *a = (struct tt__NetworkInterfaceSetConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceSetConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceSetConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->AcceptRouterAdvert = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean(soap, &a->AcceptRouterAdvert);
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &a->DHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_AcceptRouterAdvert = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_alloc_block(soap);
					a->Manual = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv6Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv6Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
		{	a->Manual = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		}
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_new_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, int n)
{
	struct tt__IPv6NetworkInterfaceSetConfiguration *p;
	struct tt__IPv6NetworkInterfaceSetConfiguration *a = (struct tt__IPv6NetworkInterfaceSetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6NetworkInterfaceSetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->DHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_alloc_block(soap);
					a->Manual = (struct tt__PrefixedIPv4Address *)soap_push_block_max(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv4Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv4Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:DHCP", &a->DHCP, "xsd:boolean"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
		{	a->Manual = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		}
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_new_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, int n)
{
	struct tt__IPv4NetworkInterfaceSetConfiguration *p;
	struct tt__IPv4NetworkInterfaceSetConfiguration *a = (struct tt__IPv4NetworkInterfaceSetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv4NetworkInterfaceSetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->Link = NULL;
	a->MTU = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->Link);
	soap_serialize_PointerToint(soap, &a->MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_MTU = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link--;
					continue;
				}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv4--;
					continue;
				}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv6--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_new_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceSetConfiguration *p;
	struct tt__NetworkInterfaceSetConfiguration *a = (struct tt__NetworkInterfaceSetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceSetConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceSetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformationExtension(struct soap *soap, const struct tt__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct tt__DynamicDNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DynamicDNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DynamicDNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_new_tt__DynamicDNSInformationExtension(struct soap *soap, int n)
{
	struct tt__DynamicDNSInformationExtension *p;
	struct tt__DynamicDNSInformationExtension *a = (struct tt__DynamicDNSInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DynamicDNSInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__DynamicDNSInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformationExtension(struct soap *soap, const struct tt__DynamicDNSInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	soap_default_tt__DNSName(soap, &a->Name);
	a->TTL = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__DNSName(soap, (char*const*)&a->Name);
	soap_serialize_PointerToxsd__duration(soap, &a->TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DynamicDNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DynamicDNSInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->Type, "tt:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__DNSName(soap, "tt:Name", (char**)&a->Name, "tt:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tt:TTL", &a->TTL, "xsd:duration"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_new_tt__DynamicDNSInformation(struct soap *soap, int n)
{
	struct tt__DynamicDNSInformation *p;
	struct tt__DynamicDNSInformation *a = (struct tt__DynamicDNSInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DynamicDNSInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__DynamicDNSInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformationExtension(struct soap *soap, const struct tt__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__NTPInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, struct tt__NTPInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NTPInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NTPInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_new_tt__NTPInformationExtension(struct soap *soap, int n)
{
	struct tt__NTPInformationExtension *p;
	struct tt__NTPInformationExtension *a = (struct tt__NTPInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NTPInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NTPInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformationExtension(struct soap *soap, const struct tt__NTPInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeNTPFromDHCP = 0;
	a->NTPFromDHCP = NULL;
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPFromDHCP; i++)
		{
			soap_embedded(soap, a->NTPFromDHCP + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPFromDHCP + i);
		}
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
	soap_serialize_PointerTott__NTPInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const struct tt__NTPInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPFromDHCP; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPFromDHCP", -1, a->NTPFromDHCP + i, ""))
				return soap->error;
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPFromDHCP = NULL;
	struct soap_blist *soap_blist_NTPManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NTPInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NTPInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPFromDHCP", 1, NULL))
			{	if (a->NTPFromDHCP == NULL)
				{	if (soap_blist_NTPFromDHCP == NULL)
						soap_blist_NTPFromDHCP = soap_alloc_block(soap);
					a->NTPFromDHCP = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_NTPFromDHCP, sizeof(struct tt__NetworkHost));
					if (a->NTPFromDHCP == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tt:NTPFromDHCP", a->NTPFromDHCP, "tt:NetworkHost"))
				{	a->__sizeNTPFromDHCP++;
					a->NTPFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_alloc_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tt:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->Extension, "tt:NTPInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPFromDHCP)
			soap_pop_block(soap, soap_blist_NTPFromDHCP);
		if (a->__sizeNTPFromDHCP)
		{	a->NTPFromDHCP = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPFromDHCP, NULL, 1);
		}
		else
		{	a->NTPFromDHCP = NULL;
			if (soap_blist_NTPFromDHCP)
				soap_end_block(soap, soap_blist_NTPFromDHCP);
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
		{	a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		}
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_new_tt__NTPInformation(struct soap *soap, int n)
{
	struct tt__NTPInformation *p;
	struct tt__NTPInformation *a = (struct tt__NTPInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NTPInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__NTPInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformationExtension(struct soap *soap, const struct tt__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__DNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, struct tt__DNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_new_tt__DNSInformationExtension(struct soap *soap, int n)
{
	struct tt__DNSInformationExtension *p;
	struct tt__DNSInformationExtension *a = (struct tt__DNSInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DNSInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__DNSInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformationExtension(struct soap *soap, const struct tt__DNSInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSFromDHCP = 0;
	a->DNSFromDHCP = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->SearchDomain + i));
		}
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSFromDHCP; i++)
		{
			soap_embedded(soap, a->DNSFromDHCP + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSFromDHCP + i);
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
	soap_serialize_PointerTott__DNSInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
			soap_out_string(soap, "tt:SearchDomain", -1, (char*const*)(a->SearchDomain + i), "");
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSFromDHCP; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSFromDHCP", -1, a->DNSFromDHCP + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSFromDHCP = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DNSInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_alloc_block(soap);
					a->SearchDomain = (char **)soap_push_block_max(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tt:SearchDomain", (char**)a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSFromDHCP", 1, NULL))
			{	if (a->DNSFromDHCP == NULL)
				{	if (soap_blist_DNSFromDHCP == NULL)
						soap_blist_DNSFromDHCP = soap_alloc_block(soap);
					a->DNSFromDHCP = (struct tt__IPAddress *)soap_push_block_max(soap, soap_blist_DNSFromDHCP, sizeof(struct tt__IPAddress));
					if (a->DNSFromDHCP == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tt:DNSFromDHCP", a->DNSFromDHCP, "tt:IPAddress"))
				{	a->__sizeDNSFromDHCP++;
					a->DNSFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_alloc_block(soap);
					a->DNSManual = (struct tt__IPAddress *)soap_push_block_max(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tt:DNSManual", a->DNSManual, "tt:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
		{	a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		}
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSFromDHCP)
			soap_pop_block(soap, soap_blist_DNSFromDHCP);
		if (a->__sizeDNSFromDHCP)
		{	a->DNSFromDHCP = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSFromDHCP, NULL, 1);
		}
		else
		{	a->DNSFromDHCP = NULL;
			if (soap_blist_DNSFromDHCP)
				soap_end_block(soap, soap_blist_DNSFromDHCP);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
		{	a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		}
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_new_tt__DNSInformation(struct soap *soap, int n)
{
	struct tt__DNSInformation *p;
	struct tt__DNSInformation *a = (struct tt__DNSInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DNSInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__DNSInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformationExtension(struct soap *soap, const struct tt__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, struct tt__HostnameInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__HostnameInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__HostnameInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_new_tt__HostnameInformationExtension(struct soap *soap, int n)
{
	struct tt__HostnameInformationExtension *p;
	struct tt__HostnameInformationExtension *a = (struct tt__HostnameInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__HostnameInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__HostnameInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformationExtension(struct soap *soap, const struct tt__HostnameInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	soap_default_xsd__token(soap, &a->Name);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	soap_serialize_xsd__token(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__HostnameInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__HostnameInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:Name", (char**)&a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->Extension, "tt:HostnameInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_new_tt__HostnameInformation(struct soap *soap, int n)
{
	struct tt__HostnameInformation *p;
	struct tt__HostnameInformation *a = (struct tt__HostnameInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__HostnameInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__HostnameInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHostExtension(struct soap *soap, const struct tt__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkHostExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, struct tt__NetworkHostExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkHostExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkHostExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_new_tt__NetworkHostExtension(struct soap *soap, int n)
{
	struct tt__NetworkHostExtension *p;
	struct tt__NetworkHostExtension *a = (struct tt__NetworkHostExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkHostExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkHostExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostExtension(struct soap *soap, const struct tt__NetworkHostExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &a->Type);
	soap_default_tt__IPv4Address(soap, &a->IPv4Address);
	soap_default_tt__IPv6Address(soap, &a->IPv6Address);
	soap_default_tt__DNSName(soap, &a->DNSname);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->IPv4Address);
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->IPv6Address);
	soap_serialize_tt__DNSName(soap, (char*const*)&a->DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const struct tt__NetworkHost *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, (char*const*)&a->IPv4Address, ""))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, (char*const*)&a->IPv6Address, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tt:DNSname", -1, (char*const*)&a->DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_DNSname = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkHost *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkHost(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->Type, "tt:NetworkHostType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)&a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)&a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap_flag_DNSname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__DNSName(soap, "tt:DNSname", (char**)&a->DNSname, "tt:DNSName"))
				{	soap_flag_DNSname--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_new_tt__NetworkHost(struct soap *soap, int n)
{
	struct tt__NetworkHost *p;
	struct tt__NetworkHost *a = (struct tt__NetworkHost*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkHost));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkHost(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocolExtension(struct soap *soap, const struct tt__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocolExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, struct tt__NetworkProtocolExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkProtocolExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkProtocolExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_new_tt__NetworkProtocolExtension(struct soap *soap, int n)
{
	struct tt__NetworkProtocolExtension *p;
	struct tt__NetworkProtocolExtension *a = (struct tt__NetworkProtocolExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkProtocolExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkProtocolExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolExtension(struct soap *soap, const struct tt__NetworkProtocolExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkProtocolType(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->__sizePort = 0;
	a->Port = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	if (a->Port)
	{	int i;
		for (i = 0; i < (int)a->__sizePort; i++)
		{
			soap_embedded(soap, a->Port + i, SOAP_TYPE_int);
		}
	}
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Port)
	{	int i;
		for (i = 0; i < (int)a->__sizePort; i++)
			if (soap_out_int(soap, "tt:Port", -1, a->Port + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Port = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkProtocol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->Name, "tt:NetworkProtocolType"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Port", 1, NULL))
			{	if (a->Port == NULL)
				{	if (soap_blist_Port == NULL)
						soap_blist_Port = soap_alloc_block(soap);
					a->Port = (int *)soap_push_block_max(soap, soap_blist_Port, sizeof(int));
					if (a->Port == NULL)
						return NULL;
					soap_default_int(soap, a->Port);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Port", a->Port, "xsd:int"))
				{	a->__sizePort++;
					a->Port = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Port)
			soap_pop_block(soap, soap_blist_Port);
		if (a->__sizePort)
		{	a->Port = (int *)soap_save_block(soap, soap_blist_Port, NULL, 1);
		}
		else
		{	a->Port = NULL;
			if (soap_blist_Port)
				soap_end_block(soap, soap_blist_Port);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Enabled > 0 || a->__sizePort < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_new_tt__NetworkProtocol(struct soap *soap, int n)
{
	struct tt__NetworkProtocol *p;
	struct tt__NetworkProtocol *a = (struct tt__NetworkProtocol*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkProtocol));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkProtocol(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6ConfigurationExtension(struct soap *soap, const struct tt__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct tt__IPv6ConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6ConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6ConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_new_tt__IPv6ConfigurationExtension(struct soap *soap, int n)
{
	struct tt__IPv6ConfigurationExtension *p;
	struct tt__IPv6ConfigurationExtension *a = (struct tt__IPv6ConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv6ConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6ConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6ConfigurationExtension(struct soap *soap, const struct tt__IPv6ConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPv6Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PrefixedIPv6Address(struct soap *soap, const struct tt__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const struct tt__PrefixedIPv6Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_nil(soap, "tt:Address"))
			return soap->error;
	}
	else
	if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv6Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PrefixedIPv6Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PrefixedIPv6Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv6Address(soap, "tt:Address", (char**)&a->Address, "tt:IPv6Address"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:PrefixLength", &a->PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_new_tt__PrefixedIPv6Address(struct soap *soap, int n)
{
	struct tt__PrefixedIPv6Address *p;
	struct tt__PrefixedIPv6Address *a = (struct tt__PrefixedIPv6Address*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PrefixedIPv6Address));
	for (p = a; p && n--; p++)
		soap_default_tt__PrefixedIPv6Address(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PrefixedIPv6Address(struct soap *soap, const struct tt__PrefixedIPv6Address *a, const char *tag, const char *type)
{
	if (soap_out_tt__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPv4Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PrefixedIPv4Address(struct soap *soap, const struct tt__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const struct tt__PrefixedIPv4Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_nil(soap, "tt:Address"))
			return soap->error;
	}
	else
	if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv4Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PrefixedIPv4Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PrefixedIPv4Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv4Address(soap, "tt:Address", (char**)&a->Address, "tt:IPv4Address"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:PrefixLength", &a->PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_new_tt__PrefixedIPv4Address(struct soap *soap, int n)
{
	struct tt__PrefixedIPv4Address *p;
	struct tt__PrefixedIPv4Address *a = (struct tt__PrefixedIPv4Address*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PrefixedIPv4Address));
	for (p = a; p && n--; p++)
		soap_default_tt__PrefixedIPv4Address(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PrefixedIPv4Address(struct soap *soap, const struct tt__PrefixedIPv4Address *a, const char *tag, const char *type)
{
	if (soap_out_tt__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->LinkLocal = NULL;
	a->FromDHCP = NULL;
	soap_default_xsd__boolean(soap, &a->DHCP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4Configuration(struct soap *soap, const struct tt__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &a->LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &a->FromDHCP);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const struct tt__IPv4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &a->LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, struct tt__IPv4Configuration *a, const char *type)
{
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_LinkLocal = 1;
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_alloc_block(soap);
					a->Manual = (struct tt__PrefixedIPv4Address *)soap_push_block_max(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv4Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv4Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_LinkLocal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &a->LinkLocal, "tt:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal--;
					continue;
				}
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &a->FromDHCP, "tt:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:DHCP", &a->DHCP, "xsd:boolean"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
		{	a->Manual = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		}
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_new_tt__IPv4Configuration(struct soap *soap, int n)
{
	struct tt__IPv4Configuration *p;
	struct tt__IPv4Configuration *a = (struct tt__IPv4Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv4Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv4Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4Configuration(struct soap *soap, const struct tt__IPv4Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4NetworkInterface(struct soap *soap, const struct tt__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__IPv4Configuration(soap, &a->Config);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__IPv4NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (!a->Config)
	{	if (soap_element_nil(soap, "tt:Config"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &a->Config, "tt:IPv4Configuration"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0 || soap_flag_Config > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_new_tt__IPv4NetworkInterface(struct soap *soap, int n)
{
	struct tt__IPv4NetworkInterface *p;
	struct tt__IPv4NetworkInterface *a = (struct tt__IPv4NetworkInterface*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv4NetworkInterface));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv4NetworkInterface(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4NetworkInterface(struct soap *soap, const struct tt__IPv4NetworkInterface *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &a->DHCP);
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->__sizeLinkLocal = 0;
	a->LinkLocal = NULL;
	a->__sizeFromDHCP = 0;
	a->FromDHCP = NULL;
	a->__sizeFromRA = 0;
	a->FromRA = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6Configuration(struct soap *soap, const struct tt__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->AcceptRouterAdvert);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	if (a->LinkLocal)
	{	int i;
		for (i = 0; i < (int)a->__sizeLinkLocal; i++)
		{
			soap_embedded(soap, a->LinkLocal + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->LinkLocal + i);
		}
	}
	if (a->FromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeFromDHCP; i++)
		{
			soap_embedded(soap, a->FromDHCP + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->FromDHCP + i);
		}
	}
	if (a->FromRA)
	{	int i;
		for (i = 0; i < (int)a->__sizeFromRA; i++)
		{
			soap_embedded(soap, a->FromRA + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->FromRA + i);
		}
	}
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const struct tt__IPv6Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < (int)a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (a->LinkLocal)
	{	int i;
		for (i = 0; i < (int)a->__sizeLinkLocal; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, a->LinkLocal + i, ""))
				return soap->error;
	}
	if (a->FromDHCP)
	{	int i;
		for (i = 0; i < (int)a->__sizeFromDHCP; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, a->FromDHCP + i, ""))
				return soap->error;
	}
	if (a->FromRA)
	{	int i;
		for (i = 0; i < (int)a->__sizeFromRA; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:FromRA", -1, a->FromRA + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, struct tt__IPv6Configuration *a, const char *type)
{
	size_t soap_flag_AcceptRouterAdvert = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	struct soap_blist *soap_blist_LinkLocal = NULL;
	struct soap_blist *soap_blist_FromDHCP = NULL;
	struct soap_blist *soap_blist_FromRA = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert--;
					continue;
				}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_alloc_block(soap);
					a->Manual = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv6Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv6Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:LinkLocal", 1, NULL))
			{	if (a->LinkLocal == NULL)
				{	if (soap_blist_LinkLocal == NULL)
						soap_blist_LinkLocal = soap_alloc_block(soap);
					a->LinkLocal = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_LinkLocal, sizeof(struct tt__PrefixedIPv6Address));
					if (a->LinkLocal == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->LinkLocal);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:LinkLocal", a->LinkLocal, "tt:PrefixedIPv6Address"))
				{	a->__sizeLinkLocal++;
					a->LinkLocal = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromDHCP", 1, NULL))
			{	if (a->FromDHCP == NULL)
				{	if (soap_blist_FromDHCP == NULL)
						soap_blist_FromDHCP = soap_alloc_block(soap);
					a->FromDHCP = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_FromDHCP, sizeof(struct tt__PrefixedIPv6Address));
					if (a->FromDHCP == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->FromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:FromDHCP", a->FromDHCP, "tt:PrefixedIPv6Address"))
				{	a->__sizeFromDHCP++;
					a->FromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromRA", 1, NULL))
			{	if (a->FromRA == NULL)
				{	if (soap_blist_FromRA == NULL)
						soap_blist_FromRA = soap_alloc_block(soap);
					a->FromRA = (struct tt__PrefixedIPv6Address *)soap_push_block_max(soap, soap_blist_FromRA, sizeof(struct tt__PrefixedIPv6Address));
					if (a->FromRA == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->FromRA);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:FromRA", a->FromRA, "tt:PrefixedIPv6Address"))
				{	a->__sizeFromRA++;
					a->FromRA = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:IPv6ConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
		{	a->Manual = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		}
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (a->LinkLocal)
			soap_pop_block(soap, soap_blist_LinkLocal);
		if (a->__sizeLinkLocal)
		{	a->LinkLocal = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_LinkLocal, NULL, 1);
		}
		else
		{	a->LinkLocal = NULL;
			if (soap_blist_LinkLocal)
				soap_end_block(soap, soap_blist_LinkLocal);
		}
		if (a->FromDHCP)
			soap_pop_block(soap, soap_blist_FromDHCP);
		if (a->__sizeFromDHCP)
		{	a->FromDHCP = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromDHCP, NULL, 1);
		}
		else
		{	a->FromDHCP = NULL;
			if (soap_blist_FromDHCP)
				soap_end_block(soap, soap_blist_FromDHCP);
		}
		if (a->FromRA)
			soap_pop_block(soap, soap_blist_FromRA);
		if (a->__sizeFromRA)
		{	a->FromRA = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromRA, NULL, 1);
		}
		else
		{	a->FromRA = NULL;
			if (soap_blist_FromRA)
				soap_end_block(soap, soap_blist_FromRA);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_new_tt__IPv6Configuration(struct soap *soap, int n)
{
	struct tt__IPv6Configuration *p;
	struct tt__IPv6Configuration *a = (struct tt__IPv6Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv6Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6Configuration(struct soap *soap, const struct tt__IPv6Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6NetworkInterface(struct soap *soap, const struct tt__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__IPv6Configuration(soap, &a->Config);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__IPv6NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &a->Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &a->Config, "tt:IPv6Configuration"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_new_tt__IPv6NetworkInterface(struct soap *soap, int n)
{
	struct tt__IPv6NetworkInterface *p;
	struct tt__IPv6NetworkInterface *a = (struct tt__IPv6NetworkInterface*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPv6NetworkInterface));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6NetworkInterface(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6NetworkInterface(struct soap *soap, const struct tt__IPv6NetworkInterface *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_tt__HwAddress(soap, &a->HwAddress);
	a->MTU = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceInfo(struct soap *soap, const struct tt__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	soap_serialize_tt__HwAddress(soap, (char*const*)&a->HwAddress);
	soap_serialize_PointerToint(soap, &a->MTU);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->HwAddress)
	{	if (soap_element_nil(soap, "tt:HwAddress"))
			return soap->error;
	}
	else
	if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, (char*const*)&a->HwAddress, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_HwAddress = 1;
	size_t soap_flag_MTU = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_HwAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__HwAddress(soap, "tt:HwAddress", (char**)&a->HwAddress, "tt:HwAddress"))
				{	soap_flag_HwAddress--;
					continue;
				}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_new_tt__NetworkInterfaceInfo(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceInfo *p;
	struct tt__NetworkInterfaceInfo *a = (struct tt__NetworkInterfaceInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceInfo));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceInfo(struct soap *soap, const struct tt__NetworkInterfaceInfo *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->AutoNegotiation);
	soap_default_int(soap, &a->Speed);
	soap_default_tt__Duplex(soap, &a->Duplex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const struct tt__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->AutoNegotiation, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->Speed, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoNegotiation", -1, &a->AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &a->Duplex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	size_t soap_flag_AutoNegotiation = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_Duplex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceConnectionSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AutoNegotiation", &a->AutoNegotiation, "xsd:boolean"))
				{	soap_flag_AutoNegotiation--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Speed", &a->Speed, "xsd:int"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap_flag_Duplex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Duplex(soap, "tt:Duplex", &a->Duplex, "tt:Duplex"))
				{	soap_flag_Duplex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation > 0 || soap_flag_Speed > 0 || soap_flag_Duplex > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_new_tt__NetworkInterfaceConnectionSetting(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceConnectionSetting *p;
	struct tt__NetworkInterfaceConnectionSetting *a = (struct tt__NetworkInterfaceConnectionSetting*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceConnectionSetting));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceConnectionSetting(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const struct tt__NetworkInterfaceConnectionSetting *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AdminSettings = NULL;
	a->OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &a->InterfaceType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceLink(struct soap *soap, const struct tt__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->OperSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type))
		return soap->error;
	if (!a->AdminSettings)
	{	if (soap_element_nil(soap, "tt:AdminSettings"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->AdminSettings, ""))
		return soap->error;
	if (!a->OperSettings)
	{	if (soap_element_nil(soap, "tt:OperSettings"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->OperSettings, ""))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink *a, const char *type)
{
	size_t soap_flag_AdminSettings = 1;
	size_t soap_flag_OperSettings = 1;
	size_t soap_flag_InterfaceType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &a->AdminSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings--;
					continue;
				}
			if (soap_flag_OperSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &a->OperSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings--;
					continue;
				}
			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AdminSettings > 0 || soap_flag_OperSettings > 0 || soap_flag_InterfaceType > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_new_tt__NetworkInterfaceLink(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceLink *p;
	struct tt__NetworkInterfaceLink *a = (struct tt__NetworkInterfaceLink*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceLink));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceLink(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceLink(struct soap *soap, const struct tt__NetworkInterfaceLink *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceExtension2(struct soap *soap, const struct tt__NetworkInterfaceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension2, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_new_tt__NetworkInterfaceExtension2(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceExtension2 *p;
	struct tt__NetworkInterfaceExtension2 *a = (struct tt__NetworkInterfaceExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceExtension2(struct soap *soap, const struct tt__NetworkInterfaceExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_tt__Dot11StationMode(soap, &a->Mode);
	soap_default_tt__Name(soap, &a->Alias);
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &a->Priority);
	a->Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Configuration(struct soap *soap, const struct tt__Dot11Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_tt__Name(soap, (char*const*)&a->Alias);
	soap_serialize_tt__NetworkInterfaceConfigPriority(soap, (char*const*)&a->Priority);
	soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, &a->Security);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Configuration(struct soap *soap, const char *tag, int id, const struct tt__Dot11Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Configuration), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_tt__Dot11StationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (!a->Alias)
	{	if (soap_element_nil(soap, "tt:Alias"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Alias", -1, (char*const*)&a->Alias, ""))
		return soap->error;
	if (!a->Priority)
	{	if (soap_element_nil(soap, "tt:Priority"))
			return soap->error;
	}
	else
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", -1, (char*const*)&a->Priority, ""))
		return soap->error;
	if (!a->Security)
	{	if (soap_element_nil(soap, "tt:Security"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", -1, &a->Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_in_tt__Dot11Configuration(struct soap *soap, const char *tag, struct tt__Dot11Configuration *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Alias = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11StationMode(soap, "tt:Mode", &a->Mode, "tt:Dot11StationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Alias", (char**)&a->Alias, "tt:Name"))
				{	soap_flag_Alias--;
					continue;
				}
			if (soap_flag_Priority && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", (char**)&a->Priority, "tt:NetworkInterfaceConfigPriority"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", &a->Security, "tt:Dot11SecurityConfiguration"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || soap_flag_Mode > 0 || soap_flag_Alias > 0 || soap_flag_Priority > 0 || soap_flag_Security > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_new_tt__Dot11Configuration(struct soap *soap, int n)
{
	struct tt__Dot11Configuration *p;
	struct tt__Dot11Configuration *a = (struct tt__Dot11Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot11Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Configuration(struct soap *soap, const struct tt__Dot11Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_get_tt__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot3Configuration(struct soap *soap, const struct tt__Dot3Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot3Configuration(struct soap *soap, const char *tag, int id, const struct tt__Dot3Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot3Configuration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_in_tt__Dot3Configuration(struct soap *soap, const char *tag, struct tt__Dot3Configuration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot3Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot3Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot3Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_new_tt__Dot3Configuration(struct soap *soap, int n)
{
	struct tt__Dot3Configuration *p;
	struct tt__Dot3Configuration *a = (struct tt__Dot3Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot3Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot3Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot3Configuration(struct soap *soap, const struct tt__Dot3Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_get_tt__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
