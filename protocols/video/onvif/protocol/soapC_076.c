/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReferenceToken(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReferenceToken))
		soap_serialize_ns2__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReferenceToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReferenceToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons2__ReferenceToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReferenceToken, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReferenceToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ReferenceToken(soap, tag ? tag : "ns2:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons2__ReferenceToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessPointInfo(struct soap *soap, struct ns1__AccessPointInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessPointInfo))
		soap_serialize_ns1__AccessPointInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessPointInfo(struct soap *soap, const char *tag, int id, struct ns1__AccessPointInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccessPointInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AccessPointInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AccessPointInfo ** SOAP_FMAC4 soap_in_PointerTons1__AccessPointInfo(struct soap *soap, const char *tag, struct ns1__AccessPointInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AccessPointInfo **)soap_malloc(soap, sizeof(struct ns1__AccessPointInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AccessPointInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AccessPointInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccessPointInfo, sizeof(struct ns1__AccessPointInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessPointInfo(struct soap *soap, struct ns1__AccessPointInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AccessPointInfo(soap, tag ? tag : "ns1:AccessPointInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessPointInfo ** SOAP_FMAC4 soap_get_PointerTons1__AccessPointInfo(struct soap *soap, struct ns1__AccessPointInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ServiceCapabilities(struct soap *soap, struct ns1__ServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ServiceCapabilities))
		soap_serialize_ns1__ServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ServiceCapabilities(struct soap *soap, const char *tag, int id, struct ns1__ServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTons1__ServiceCapabilities(struct soap *soap, const char *tag, struct ns1__ServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ServiceCapabilities **)soap_malloc(soap, sizeof(struct ns1__ServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ServiceCapabilities, sizeof(struct ns1__ServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ServiceCapabilities(struct soap *soap, struct ns1__ServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ServiceCapabilities(soap, tag ? tag : "ns1:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTons1__ServiceCapabilities(struct soap *soap, struct ns1__ServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression, 1, 0, -1, "(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)(/([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__FullTopicExpression(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wstop__FullTopicExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__FullTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__FullTopicExpression, 1, 0, -1, "([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*(\\|([\\i-[:]][\\c-[:]]*:)?(//)?([\\i-[:]][\\c-[:]]*|\\*)((/|//)(([\\i-[:]][\\c-[:]]*:)?[\\i-[:]][\\c-[:]]*|\\*|[.]))*)*");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wstop__FullTopicExpression(soap, tag ? tag : "wstop:FullTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__AudioClassType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AudioClassType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AudioClassType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AudioClassType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassType(soap, tag ? tag : "tt:AudioClassType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AudioClassType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobState(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobState(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobState);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobState(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobState, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobState(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobState(soap, tag ? tag : "tt:RecordingJobState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobState(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobMode(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobMode(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobMode);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobMode(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobMode, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobMode(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobMode(soap, tag ? tag : "tt:RecordingJobMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobMode(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__XPathExpression(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__XPathExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__XPathExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__XPathExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__XPathExpression(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__XPathExpression, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__XPathExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__XPathExpression(soap, tag ? tag : "tt:XPathExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__XPathExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Description(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Description);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Description(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Description, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Description(soap, tag ? tag : "tt:Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AuxiliaryData);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AuxiliaryData, 1, 0, 128, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKPassphrase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase, 1, 0, -1, "[ -~]{8,63}");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Name, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceToken, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Description(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__Description);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__Description(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__Description, 1, 0, 1024, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns2__Description(soap, tag ? tag : "ns2:Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__Name(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__Name(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__Name, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns2__Name(soap, tag ? tag : "ns2:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ReferenceToken(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__ReferenceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns2__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns2__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns2__ReferenceToken, 1, 0, 64, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns2__ReferenceToken(soap, tag ? tag : "ns2:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns2__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__EncodingTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_trc__EncodingTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__EncodingTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_trc__EncodingTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_trc__EncodingTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_trc__EncodingTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__EncodingTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_trc__EncodingTypes(soap, tag ? tag : "trc:EncodingTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_trc__EncodingTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__EncodingTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__EncodingTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns6__EncodingTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncodingTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns6__EncodingTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns6__EncodingTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns6__EncodingTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EncodingTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns6__EncodingTypes(soap, tag ? tag : "ns6:EncodingTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns6__EncodingTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncodingTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__EncodingTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_trt__EncodingTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__EncodingTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_trt__EncodingTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_trt__EncodingTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_trt__EncodingTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__EncodingTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_trt__EncodingTypes(soap, tag ? tag : "trt:EncodingTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_trt__EncodingTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__EncodingTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__EAPMethodTypes(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tds__EAPMethodTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__EAPMethodTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tds__EAPMethodTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tds__EAPMethodTypes(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tds__EAPMethodTypes, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__EAPMethodTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tds__EAPMethodTypes(soap, tag ? tag : "tds:EAPMethodTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tds__EAPMethodTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__EAPMethodTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceTokenList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceTokenList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceTokenList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceTokenList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceTokenList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceTokenList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceTokenList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceTokenList(soap, tag ? tag : "tt:ReferenceTokenList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceTokenList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceTokenList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__FloatAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__FloatAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__FloatAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__FloatAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__FloatAttrList(soap, tag ? tag : "tt:FloatAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__FloatAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntAttrList(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IntAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IntAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IntAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IntAttrList, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_tt__IntAttrList(soap, tag ? tag : "tt:IntAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IntAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__time);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__time, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__time(soap, tag ? tag : "xsd:time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__positiveInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__positiveInteger(soap, tag ? tag : "xsd:positiveInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
