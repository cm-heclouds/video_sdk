/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ContinuousMoveResponse(struct soap *soap, const struct _tptz__ContinuousMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__ContinuousMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_in__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, struct _tptz__ContinuousMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ContinuousMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ContinuousMoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMoveResponse, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_new__tptz__ContinuousMoveResponse(struct soap *soap, int n)
{
	struct _tptz__ContinuousMoveResponse *p;
	struct _tptz__ContinuousMoveResponse *a = (struct _tptz__ContinuousMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ContinuousMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__ContinuousMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ContinuousMoveResponse(struct soap *soap, const struct _tptz__ContinuousMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ContinuousMoveResponse(soap, tag ? tag : "tptz:ContinuousMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_get__tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Velocity = NULL;
	a->Timeout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ContinuousMove(struct soap *soap, const struct _tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Velocity);
	soap_serialize_PointerToxsd__duration(soap, &a->Timeout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMove(struct soap *soap, const char *tag, int id, const struct _tptz__ContinuousMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Velocity)
	{	if (soap_element_nil(soap, "tptz:Velocity"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Velocity", -1, &a->Velocity, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tptz:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_in__tptz__ContinuousMove(struct soap *soap, const char *tag, struct _tptz__ContinuousMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Velocity = 1;
	size_t soap_flag_Timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ContinuousMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ContinuousMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Velocity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Velocity", &a->Velocity, "tt:PTZSpeed"))
				{	soap_flag_Velocity--;
					continue;
				}
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tptz:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_Velocity > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMove, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_new__tptz__ContinuousMove(struct soap *soap, int n)
{
	struct _tptz__ContinuousMove *p;
	struct _tptz__ContinuousMove *a = (struct _tptz__ContinuousMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ContinuousMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__ContinuousMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ContinuousMove(struct soap *soap, const struct _tptz__ContinuousMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ContinuousMove(soap, tag ? tag : "tptz:ContinuousMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_get__tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetHomePositionResponse(struct soap *soap, const struct _tptz__SetHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_in__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__SetHomePositionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetHomePositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetHomePositionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePositionResponse, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_new__tptz__SetHomePositionResponse(struct soap *soap, int n)
{
	struct _tptz__SetHomePositionResponse *p;
	struct _tptz__SetHomePositionResponse *a = (struct _tptz__SetHomePositionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetHomePositionResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetHomePositionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetHomePositionResponse(struct soap *soap, const struct _tptz__SetHomePositionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetHomePositionResponse(soap, tag ? tag : "tptz:SetHomePositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_get__tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetHomePosition(struct soap *soap, const struct _tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePosition(struct soap *soap, const char *tag, int id, const struct _tptz__SetHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePosition), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_in__tptz__SetHomePosition(struct soap *soap, const char *tag, struct _tptz__SetHomePosition *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetHomePosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetHomePosition(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePosition, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_new__tptz__SetHomePosition(struct soap *soap, int n)
{
	struct _tptz__SetHomePosition *p;
	struct _tptz__SetHomePosition *a = (struct _tptz__SetHomePosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetHomePosition));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetHomePosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetHomePosition(struct soap *soap, const struct _tptz__SetHomePosition *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetHomePosition(soap, tag ? tag : "tptz:SetHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_get__tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoHomePositionResponse(struct soap *soap, const struct _tptz__GotoHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GotoHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_in__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__GotoHomePositionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoHomePositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoHomePositionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePositionResponse, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_new__tptz__GotoHomePositionResponse(struct soap *soap, int n)
{
	struct _tptz__GotoHomePositionResponse *p;
	struct _tptz__GotoHomePositionResponse *a = (struct _tptz__GotoHomePositionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoHomePositionResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoHomePositionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoHomePositionResponse(struct soap *soap, const struct _tptz__GotoHomePositionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoHomePositionResponse(soap, tag ? tag : "tptz:GotoHomePositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_get__tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoHomePosition(struct soap *soap, const struct _tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, const struct _tptz__GotoHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePosition), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_in__tptz__GotoHomePosition(struct soap *soap, const char *tag, struct _tptz__GotoHomePosition *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoHomePosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoHomePosition(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePosition, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_new__tptz__GotoHomePosition(struct soap *soap, int n)
{
	struct _tptz__GotoHomePosition *p;
	struct _tptz__GotoHomePosition *a = (struct _tptz__GotoHomePosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoHomePosition));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoHomePosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoHomePosition(struct soap *soap, const struct _tptz__GotoHomePosition *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoHomePosition(soap, tag ? tag : "tptz:GotoHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_get__tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetStatusResponse(struct soap *soap, const struct _tptz__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatusResponse), type))
		return soap->error;
	if (a->PTZStatus)
		soap_element_result(soap, "tptz:PTZStatus");
	if (!a->PTZStatus)
	{	if (soap_element_nil(soap, "tptz:PTZStatus"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZStatus(soap, "tptz:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_in__tptz__GetStatusResponse(struct soap *soap, const char *tag, struct _tptz__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatus(soap, "tptz:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZStatus > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatusResponse, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_new__tptz__GetStatusResponse(struct soap *soap, int n)
{
	struct _tptz__GetStatusResponse *p;
	struct _tptz__GetStatusResponse *a = (struct _tptz__GetStatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetStatusResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetStatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetStatusResponse(struct soap *soap, const struct _tptz__GetStatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetStatusResponse(soap, tag ? tag : "tptz:GetStatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_get__tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetStatus(struct soap *soap, const struct _tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatus(struct soap *soap, const char *tag, int id, const struct _tptz__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatus), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_in__tptz__GetStatus(struct soap *soap, const char *tag, struct _tptz__GetStatus *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatus, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_new__tptz__GetStatus(struct soap *soap, int n)
{
	struct _tptz__GetStatus *p;
	struct _tptz__GetStatus *a = (struct _tptz__GetStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetStatus));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetStatus(struct soap *soap, const struct _tptz__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetStatus(soap, tag ? tag : "tptz:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_get__tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoPresetResponse(struct soap *soap, const struct _tptz__GotoPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GotoPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_in__tptz__GotoPresetResponse(struct soap *soap, const char *tag, struct _tptz__GotoPresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoPresetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPresetResponse, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_new__tptz__GotoPresetResponse(struct soap *soap, int n)
{
	struct _tptz__GotoPresetResponse *p;
	struct _tptz__GotoPresetResponse *a = (struct _tptz__GotoPresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoPresetResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoPresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoPresetResponse(struct soap *soap, const struct _tptz__GotoPresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoPresetResponse(soap, tag ? tag : "tptz:GotoPresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_get__tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoPreset(struct soap *soap, const struct _tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPreset(struct soap *soap, const char *tag, int id, const struct _tptz__GotoPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPreset), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetToken)
	{	if (soap_element_nil(soap, "tptz:PresetToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_in__tptz__GotoPreset(struct soap *soap, const char *tag, struct _tptz__GotoPreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoPreset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GotoPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPreset, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_new__tptz__GotoPreset(struct soap *soap, int n)
{
	struct _tptz__GotoPreset *p;
	struct _tptz__GotoPreset *a = (struct _tptz__GotoPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GotoPreset));
	for (p = a; p && n--; p++)
		soap_default__tptz__GotoPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoPreset(struct soap *soap, const struct _tptz__GotoPreset *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GotoPreset(soap, tag ? tag : "tptz:GotoPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_get__tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetResponse(struct soap *soap, const struct _tptz__RemovePresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetResponse, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_new__tptz__RemovePresetResponse(struct soap *soap, int n)
{
	struct _tptz__RemovePresetResponse *p;
	struct _tptz__RemovePresetResponse *a = (struct _tptz__RemovePresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePresetResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetResponse(struct soap *soap, const struct _tptz__RemovePresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePresetResponse(soap, tag ? tag : "tptz:RemovePresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePreset(struct soap *soap, const struct _tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePreset(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePreset), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetToken)
	{	if (soap_element_nil(soap, "tptz:PresetToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_in__tptz__RemovePreset(struct soap *soap, const char *tag, struct _tptz__RemovePreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePreset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__RemovePreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePreset, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_new__tptz__RemovePreset(struct soap *soap, int n)
{
	struct _tptz__RemovePreset *p;
	struct _tptz__RemovePreset *a = (struct _tptz__RemovePreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePreset));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePreset(struct soap *soap, const struct _tptz__RemovePreset *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePreset(soap, tag ? tag : "tptz:RemovePreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_get__tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetPresetResponse(struct soap *soap, const struct _tptz__SetPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPresetResponse), type))
		return soap->error;
	if (a->PresetToken)
		soap_element_result(soap, "tptz:PresetToken");
	if (!a->PresetToken)
	{	if (soap_element_nil(soap, "tptz:PresetToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_in__tptz__SetPresetResponse(struct soap *soap, const char *tag, struct _tptz__SetPresetResponse *a, const char *type)
{
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetPresetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			soap_check_result(soap, "tptz:PresetToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPresetResponse, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_new__tptz__SetPresetResponse(struct soap *soap, int n)
{
	struct _tptz__SetPresetResponse *p;
	struct _tptz__SetPresetResponse *a = (struct _tptz__SetPresetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetPresetResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetPresetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetPresetResponse(struct soap *soap, const struct _tptz__SetPresetResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetPresetResponse(soap, tag ? tag : "tptz:SetPresetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_get__tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_string(soap, &a->PresetName);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetPreset(struct soap *soap, const struct _tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_string(soap, (char*const*)&a->PresetName);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPreset(struct soap *soap, const char *tag, int id, const struct _tptz__SetPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPreset), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_string(soap, "tptz:PresetName", -1, (char*const*)&a->PresetName, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, (char*const*)&a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_in__tptz__SetPreset(struct soap *soap, const char *tag, struct _tptz__SetPreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetName = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetPreset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tptz:PresetName", (char**)&a->PresetName, "xsd:string"))
				{	soap_flag_PresetName--;
					continue;
				}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", (char**)&a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPreset, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_new__tptz__SetPreset(struct soap *soap, int n)
{
	struct _tptz__SetPreset *p;
	struct _tptz__SetPreset *a = (struct _tptz__SetPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetPreset));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetPreset(struct soap *soap, const struct _tptz__SetPreset *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetPreset(soap, tag ? tag : "tptz:SetPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_get__tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePreset = 0;
	a->Preset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetsResponse(struct soap *soap, const struct _tptz__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Preset)
	{	int i;
		for (i = 0; i < (int)a->__sizePreset; i++)
		{
			soap_embedded(soap, a->Preset + i, SOAP_TYPE_tt__PTZPreset);
			soap_serialize_tt__PTZPreset(soap, a->Preset + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePreset");
	if (a->Preset)
	{	int i;
		for (i = 0; i < (int)a->__sizePreset; i++)
			if (soap_out_tt__PTZPreset(soap, "tptz:Preset", -1, a->Preset + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Preset = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:Preset", 1, NULL))
			{	if (a->Preset == NULL)
				{	if (soap_blist_Preset == NULL)
						soap_blist_Preset = soap_alloc_block(soap);
					a->Preset = (struct tt__PTZPreset *)soap_push_block_max(soap, soap_blist_Preset, sizeof(struct tt__PTZPreset));
					if (a->Preset == NULL)
						return NULL;
					soap_default_tt__PTZPreset(soap, a->Preset);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPreset(soap, "tptz:Preset", a->Preset, "tt:PTZPreset"))
				{	a->__sizePreset++;
					a->Preset = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePreset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Preset)
			soap_pop_block(soap, soap_blist_Preset);
		if (a->__sizePreset)
		{	a->Preset = (struct tt__PTZPreset *)soap_save_block(soap, soap_blist_Preset, NULL, 1);
		}
		else
		{	a->Preset = NULL;
			if (soap_blist_Preset)
				soap_end_block(soap, soap_blist_Preset);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetsResponse, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_new__tptz__GetPresetsResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetsResponse *p;
	struct _tptz__GetPresetsResponse *a = (struct _tptz__GetPresetsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetsResponse(struct soap *soap, const struct _tptz__GetPresetsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetsResponse(soap, tag ? tag : "tptz:GetPresetsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresets(struct soap *soap, const struct _tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresets(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresets), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_in__tptz__GetPresets(struct soap *soap, const char *tag, struct _tptz__GetPresets *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresets *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresets(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresets, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_new__tptz__GetPresets(struct soap *soap, int n)
{
	struct _tptz__GetPresets *p;
	struct _tptz__GetPresets *a = (struct _tptz__GetPresets*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresets));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresets(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresets(struct soap *soap, const struct _tptz__GetPresets *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresets(soap, tag ? tag : "tptz:GetPresets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_get__tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tptz__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryResponse)
		soap_element_result(soap, "tptz:AuxiliaryResponse");
	if (!a->AuxiliaryResponse)
	{	if (soap_element_nil(soap, "tptz:AuxiliaryResponse"))
			return soap->error;
	}
	else
	if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", -1, (char*const*)&a->AuxiliaryResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", (char**)&a->AuxiliaryResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryResponse--;
					continue;
				}
			soap_check_result(soap, "tptz:AuxiliaryResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryResponse > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_new__tptz__SendAuxiliaryCommandResponse(struct soap *soap, int n)
{
	struct _tptz__SendAuxiliaryCommandResponse *p;
	struct _tptz__SendAuxiliaryCommandResponse *a = (struct _tptz__SendAuxiliaryCommandResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SendAuxiliaryCommandResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SendAuxiliaryCommandResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tptz__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag ? tag : "tptz:SendAuxiliaryCommandResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SendAuxiliaryCommand(struct soap *soap, const struct _tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->AuxiliaryData)
	{	if (soap_element_nil(soap, "tptz:AuxiliaryData"))
			return soap->error;
	}
	else
	if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", -1, (char*const*)&a->AuxiliaryData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_AuxiliaryData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SendAuxiliaryCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_AuxiliaryData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", (char**)&a->AuxiliaryData, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_AuxiliaryData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommand, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_new__tptz__SendAuxiliaryCommand(struct soap *soap, int n)
{
	struct _tptz__SendAuxiliaryCommand *p;
	struct _tptz__SendAuxiliaryCommand *a = (struct _tptz__SendAuxiliaryCommand*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SendAuxiliaryCommand));
	for (p = a; p && n--; p++)
		soap_default__tptz__SendAuxiliaryCommand(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SendAuxiliaryCommand(struct soap *soap, const struct _tptz__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SendAuxiliaryCommand(soap, tag ? tag : "tptz:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationOptionsResponse(struct soap *soap, const struct _tptz__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfigurationOptions(soap, &a->PTZConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse), type))
		return soap->error;
	if (a->PTZConfigurationOptions)
		soap_element_result(soap, "tptz:PTZConfigurationOptions");
	if (!a->PTZConfigurationOptions)
	{	if (soap_element_nil(soap, "tptz:PTZConfigurationOptions"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", -1, &a->PTZConfigurationOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_PTZConfigurationOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", &a->PTZConfigurationOptions, "tt:PTZConfigurationOptions"))
				{	soap_flag_PTZConfigurationOptions--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfigurationOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_new__tptz__GetConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationOptionsResponse *p;
	struct _tptz__GetConfigurationOptionsResponse *a = (struct _tptz__GetConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationOptionsResponse(struct soap *soap, const struct _tptz__GetConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationOptionsResponse(soap, tag ? tag : "tptz:GetConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationOptions(struct soap *soap, const struct _tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptions), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tptz:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptions, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_new__tptz__GetConfigurationOptions(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationOptions *p;
	struct _tptz__GetConfigurationOptions *a = (struct _tptz__GetConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationOptions(struct soap *soap, const struct _tptz__GetConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationOptions(soap, tag ? tag : "tptz:GetConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, const struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_in___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SetConfigurationResponse_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetConfigurationResponse_sequence(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_new___tptz__SetConfigurationResponse_sequence(struct soap *soap, int n)
{
	struct __tptz__SetConfigurationResponse_sequence *p;
	struct __tptz__SetConfigurationResponse_sequence *a = (struct __tptz__SetConfigurationResponse_sequence*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tptz__SetConfigurationResponse_sequence));
	for (p = a; p && n--; p++)
		soap_default___tptz__SetConfigurationResponse_sequence(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SetConfigurationResponse_sequence(soap, tag ? tag : "-tptz:SetConfigurationResponse-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_get___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__SetConfigurationResponse_sequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetConfigurationResponse(struct soap *soap, const struct _tptz__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(soap, &a->__SetConfigurationResponse_sequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfigurationResponse), type))
		return soap->error;
	if (a->__SetConfigurationResponse_sequence)
		soap_element_result(soap, "-SetConfigurationResponse-sequence");
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", -1, &a->__SetConfigurationResponse_sequence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__SetConfigurationResponse *a, const char *type)
{
	size_t soap_flag___SetConfigurationResponse_sequence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___SetConfigurationResponse_sequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", &a->__SetConfigurationResponse_sequence, "-tptz:SetConfigurationResponse-sequence"))
				{	soap_flag___SetConfigurationResponse_sequence--;
					continue;
				}
			soap_check_result(soap, "-SetConfigurationResponse-sequence");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfigurationResponse, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_new__tptz__SetConfigurationResponse(struct soap *soap, int n)
{
	struct _tptz__SetConfigurationResponse *p;
	struct _tptz__SetConfigurationResponse *a = (struct _tptz__SetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetConfigurationResponse(struct soap *soap, const struct _tptz__SetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetConfigurationResponse(soap, tag ? tag : "tptz:SetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfiguration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetConfiguration(struct soap *soap, const struct _tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfiguration(struct soap *soap, const char *tag, int id, const struct _tptz__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfiguration), type))
		return soap->error;
	if (!a->PTZConfiguration)
	{	if (soap_element_nil(soap, "tptz:PTZConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tptz:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_in__tptz__SetConfiguration(struct soap *soap, const char *tag, struct _tptz__SetConfiguration *a, const char *type)
{
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tptz:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfiguration > 0 || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__SetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfiguration, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_new__tptz__SetConfiguration(struct soap *soap, int n)
{
	struct _tptz__SetConfiguration *p;
	struct _tptz__SetConfiguration *a = (struct _tptz__SetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__SetConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tptz__SetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetConfiguration(struct soap *soap, const struct _tptz__SetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tptz__SetConfiguration(soap, tag ? tag : "tptz:SetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_get__tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationResponse(struct soap *soap, const struct _tptz__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationResponse), type))
		return soap->error;
	if (a->PTZConfiguration)
		soap_element_result(soap, "tptz:PTZConfiguration");
	if (!a->PTZConfiguration)
	{	if (soap_element_nil(soap, "tptz:PTZConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PTZConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationResponse, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_new__tptz__GetConfigurationResponse(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationResponse *p;
	struct _tptz__GetConfigurationResponse *a = (struct _tptz__GetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationResponse(struct soap *soap, const struct _tptz__GetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationResponse(soap, tag ? tag : "tptz:GetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PTZConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfiguration(struct soap *soap, const struct _tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PTZConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfiguration(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfiguration), type))
		return soap->error;
	if (!a->PTZConfigurationToken)
	{	if (soap_element_nil(soap, "tptz:PTZConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", -1, (char*const*)&a->PTZConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_in__tptz__GetConfiguration(struct soap *soap, const char *tag, struct _tptz__GetConfiguration *a, const char *type)
{
	size_t soap_flag_PTZConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", (char**)&a->PTZConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_PTZConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfiguration, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_new__tptz__GetConfiguration(struct soap *soap, int n)
{
	struct _tptz__GetConfiguration *p;
	struct _tptz__GetConfiguration *a = (struct _tptz__GetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfiguration(struct soap *soap, const struct _tptz__GetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfiguration(soap, tag ? tag : "tptz:GetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_get__tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZConfiguration = 0;
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationsResponse(struct soap *soap, const struct _tptz__GetConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
		{
			soap_embedded(soap, a->PTZConfiguration + i, SOAP_TYPE_tt__PTZConfiguration);
			soap_serialize_tt__PTZConfiguration(soap, a->PTZConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZConfiguration");
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
			if (soap_out_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, a->PTZConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
			{	if (a->PTZConfiguration == NULL)
				{	if (soap_blist_PTZConfiguration == NULL)
						soap_blist_PTZConfiguration = soap_alloc_block(soap);
					a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_push_block_max(soap, soap_blist_PTZConfiguration, sizeof(struct tt__PTZConfiguration));
					if (a->PTZConfiguration == NULL)
						return NULL;
					soap_default_tt__PTZConfiguration(soap, a->PTZConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", a->PTZConfiguration, "tt:PTZConfiguration"))
				{	a->__sizePTZConfiguration++;
					a->PTZConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZConfiguration)
			soap_pop_block(soap, soap_blist_PTZConfiguration);
		if (a->__sizePTZConfiguration)
		{	a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_save_block(soap, soap_blist_PTZConfiguration, NULL, 1);
		}
		else
		{	a->PTZConfiguration = NULL;
			if (soap_blist_PTZConfiguration)
				soap_end_block(soap, soap_blist_PTZConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationsResponse, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_new__tptz__GetConfigurationsResponse(struct soap *soap, int n)
{
	struct _tptz__GetConfigurationsResponse *p;
	struct _tptz__GetConfigurationsResponse *a = (struct _tptz__GetConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationsResponse(struct soap *soap, const struct _tptz__GetConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurationsResponse(soap, tag ? tag : "tptz:GetConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurations(struct soap *soap, const struct _tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurations(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_in__tptz__GetConfigurations(struct soap *soap, const char *tag, struct _tptz__GetConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurations, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_new__tptz__GetConfigurations(struct soap *soap, int n)
{
	struct _tptz__GetConfigurations *p;
	struct _tptz__GetConfigurations *a = (struct _tptz__GetConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurations(struct soap *soap, const struct _tptz__GetConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetConfigurations(soap, tag ? tag : "tptz:GetConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_get__tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodeResponse(struct soap *soap, const struct _tptz__GetNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZNode(soap, &a->PTZNode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodeResponse), type))
		return soap->error;
	if (a->PTZNode)
		soap_element_result(soap, "tptz:PTZNode");
	if (!a->PTZNode)
	{	if (soap_element_nil(soap, "tptz:PTZNode"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZNode(soap, "tptz:PTZNode", -1, &a->PTZNode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_in__tptz__GetNodeResponse(struct soap *soap, const char *tag, struct _tptz__GetNodeResponse *a, const char *type)
{
	size_t soap_flag_PTZNode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZNode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZNode(soap, "tptz:PTZNode", &a->PTZNode, "tt:PTZNode"))
				{	soap_flag_PTZNode--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZNode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetNodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodeResponse, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_new__tptz__GetNodeResponse(struct soap *soap, int n)
{
	struct _tptz__GetNodeResponse *p;
	struct _tptz__GetNodeResponse *a = (struct _tptz__GetNodeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNodeResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNodeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodeResponse(struct soap *soap, const struct _tptz__GetNodeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNodeResponse(soap, tag ? tag : "tptz:GetNodeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_get__tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNode(struct soap *soap, struct _tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->NodeToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNode(struct soap *soap, const struct _tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->NodeToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNode(struct soap *soap, const char *tag, int id, const struct _tptz__GetNode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNode), type))
		return soap->error;
	if (!a->NodeToken)
	{	if (soap_element_nil(soap, "tptz:NodeToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:NodeToken", -1, (char*const*)&a->NodeToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_in__tptz__GetNode(struct soap *soap, const char *tag, struct _tptz__GetNode *a, const char *type)
{
	size_t soap_flag_NodeToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:NodeToken", (char**)&a->NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NodeToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNode, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_new__tptz__GetNode(struct soap *soap, int n)
{
	struct _tptz__GetNode *p;
	struct _tptz__GetNode *a = (struct _tptz__GetNode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNode));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNode(struct soap *soap, const struct _tptz__GetNode *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNode(soap, tag ? tag : "tptz:GetNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_get__tptz__GetNode(struct soap *soap, struct _tptz__GetNode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNode(struct soap *soap, struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__Name(soap, &a->Name);
	a->SupportedPTZSpaces = NULL;
	soap_default_int(soap, &a->MaximumNumberOfPresets);
	soap_default_xsd__boolean(soap, &a->HomeSupported);
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->FixedHomePosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &a->SupportedPTZSpaces);
	soap_embedded(soap, &a->MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &a->HomeSupported, SOAP_TYPE_xsd__boolean);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, (char*const*)(a->AuxiliaryCommands + i));
		}
	}
	soap_serialize_PointerTott__PTZNodeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const struct tt__PTZNode *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->FixedHomePosition)
		soap_set_attr(soap, "FixedHomePosition", soap_xsd__boolean2s(soap, *a->FixedHomePosition), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->SupportedPTZSpaces)
	{	if (soap_element_nil(soap, "tt:SupportedPTZSpaces"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->SupportedPTZSpaces, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &a->MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:HomeSupported", -1, &a->HomeSupported, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
			soap_out_string(soap, "tt:AuxiliaryCommands", -1, (char*const*)(a->AuxiliaryCommands + i), "");
	}
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, struct tt__PTZNode *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_SupportedPTZSpaces = 1;
	size_t soap_flag_MaximumNumberOfPresets = 1;
	size_t soap_flag_HomeSupported = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNode(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "FixedHomePosition", 0);
		if (t)
		{
			if (!(a->FixedHomePosition = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FixedHomePosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_SupportedPTZSpaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &a->SupportedPTZSpaces, "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces--;
					continue;
				}
			if (soap_flag_MaximumNumberOfPresets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &a->MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets--;
					continue;
				}
			if (soap_flag_HomeSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:HomeSupported", &a->HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_alloc_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block_max(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", (char**)a->AuxiliaryCommands, "tt:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &a->Extension, "tt:PTZNodeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
		{	a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		}
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedPTZSpaces > 0 || soap_flag_MaximumNumberOfPresets > 0 || soap_flag_HomeSupported > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_new_tt__PTZNode(struct soap *soap, int n)
{
	struct tt__PTZNode *p;
	struct tt__PTZNode *a = (struct tt__PTZNode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNode));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, struct tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZNode = 0;
	a->PTZNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodesResponse(struct soap *soap, const struct _tptz__GetNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PTZNode)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZNode; i++)
		{
			soap_embedded(soap, a->PTZNode + i, SOAP_TYPE_tt__PTZNode);
			soap_serialize_tt__PTZNode(soap, a->PTZNode + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZNode");
	if (a->PTZNode)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZNode; i++)
			if (soap_out_tt__PTZNode(soap, "tptz:PTZNode", -1, a->PTZNode + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_in__tptz__GetNodesResponse(struct soap *soap, const char *tag, struct _tptz__GetNodesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZNode = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNodesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZNode", 1, NULL))
			{	if (a->PTZNode == NULL)
				{	if (soap_blist_PTZNode == NULL)
						soap_blist_PTZNode = soap_alloc_block(soap);
					a->PTZNode = (struct tt__PTZNode *)soap_push_block_max(soap, soap_blist_PTZNode, sizeof(struct tt__PTZNode));
					if (a->PTZNode == NULL)
						return NULL;
					soap_default_tt__PTZNode(soap, a->PTZNode);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZNode(soap, "tptz:PTZNode", a->PTZNode, "tt:PTZNode"))
				{	a->__sizePTZNode++;
					a->PTZNode = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZNode)
			soap_pop_block(soap, soap_blist_PTZNode);
		if (a->__sizePTZNode)
		{	a->PTZNode = (struct tt__PTZNode *)soap_save_block(soap, soap_blist_PTZNode, NULL, 1);
		}
		else
		{	a->PTZNode = NULL;
			if (soap_blist_PTZNode)
				soap_end_block(soap, soap_blist_PTZNode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodesResponse, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_new__tptz__GetNodesResponse(struct soap *soap, int n)
{
	struct _tptz__GetNodesResponse *p;
	struct _tptz__GetNodesResponse *a = (struct _tptz__GetNodesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNodesResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNodesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodesResponse(struct soap *soap, const struct _tptz__GetNodesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNodesResponse(soap, tag ? tag : "tptz:GetNodesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_get__tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodes(struct soap *soap, const struct _tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodes(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_in__tptz__GetNodes(struct soap *soap, const char *tag, struct _tptz__GetNodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodes, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_new__tptz__GetNodes(struct soap *soap, int n)
{
	struct _tptz__GetNodes *p;
	struct _tptz__GetNodes *a = (struct _tptz__GetNodes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetNodes));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetNodes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodes(struct soap *soap, const struct _tptz__GetNodes *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetNodes(soap, tag ? tag : "tptz:GetNodes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_get__tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tptz__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotptz__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tptz:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tptz:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotptz__Capabilities(soap, "tptz:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotptz__Capabilities(soap, "tptz:Capabilities", &a->Capabilities, "tptz:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tptz:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tptz__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tptz__GetServiceCapabilitiesResponse *p;
	struct _tptz__GetServiceCapabilitiesResponse *a = (struct _tptz__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tptz__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag ? tag : "tptz:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetServiceCapabilities(struct soap *soap, const struct _tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tptz__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilities, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_new__tptz__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tptz__GetServiceCapabilities *p;
	struct _tptz__GetServiceCapabilities *a = (struct _tptz__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetServiceCapabilities(struct soap *soap, const struct _tptz__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetServiceCapabilities(soap, tag ? tag : "tptz:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tptz__Capabilities(struct soap *soap, struct tptz__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->GetCompatibleConfigurations = NULL;
	a->MoveStatus = NULL;
	a->StatusPosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tptz__Capabilities(struct soap *soap, const struct tptz__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tptz__Capabilities(struct soap *soap, const char *tag, int id, const struct tptz__Capabilities *a, const char *type)
{
	if (a->EFlip)
		soap_set_attr(soap, "EFlip", soap_xsd__boolean2s(soap, *a->EFlip), 1);
	if (a->Reverse)
		soap_set_attr(soap, "Reverse", soap_xsd__boolean2s(soap, *a->Reverse), 1);
	if (a->GetCompatibleConfigurations)
		soap_set_attr(soap, "GetCompatibleConfigurations", soap_xsd__boolean2s(soap, *a->GetCompatibleConfigurations), 1);
	if (a->MoveStatus)
		soap_set_attr(soap, "MoveStatus", soap_xsd__boolean2s(soap, *a->MoveStatus), 1);
	if (a->StatusPosition)
		soap_set_attr(soap, "StatusPosition", soap_xsd__boolean2s(soap, *a->StatusPosition), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tptz__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_in_tptz__Capabilities(struct soap *soap, const char *tag, struct tptz__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tptz__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tptz__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "EFlip", 0);
		if (t)
		{
			if (!(a->EFlip = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->EFlip))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Reverse", 0);
		if (t)
		{
			if (!(a->Reverse = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Reverse))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "GetCompatibleConfigurations", 0);
		if (t)
		{
			if (!(a->GetCompatibleConfigurations = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GetCompatibleConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MoveStatus", 0);
		if (t)
		{
			if (!(a->MoveStatus = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MoveStatus))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "StatusPosition", 0);
		if (t)
		{
			if (!(a->StatusPosition = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->StatusPosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tptz__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tptz__Capabilities, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_new_tptz__Capabilities(struct soap *soap, int n)
{
	struct tptz__Capabilities *p;
	struct tptz__Capabilities *a = (struct tptz__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tptz__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tptz__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tptz__Capabilities(struct soap *soap, const struct tptz__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tptz__Capabilities(soap, tag ? tag : "tptz:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_get_tptz__Capabilities(struct soap *soap, struct tptz__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__DeleteOSD(struct soap *soap, struct _ns6__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__DeleteOSD(struct soap *soap, const struct _ns6__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__DeleteOSD(struct soap *soap, const char *tag, int id, const struct _ns6__DeleteOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__DeleteOSD), type))
		return soap->error;
	if (!a->OSDToken)
	{	if (soap_element_nil(soap, "ns6:OSDToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__DeleteOSD * SOAP_FMAC4 soap_in__ns6__DeleteOSD(struct soap *soap, const char *tag, struct _ns6__DeleteOSD *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__DeleteOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__DeleteOSD, sizeof(struct _ns6__DeleteOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__DeleteOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__DeleteOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__DeleteOSD, SOAP_TYPE__ns6__DeleteOSD, sizeof(struct _ns6__DeleteOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__DeleteOSD * SOAP_FMAC4 soap_new__ns6__DeleteOSD(struct soap *soap, int n)
{
	struct _ns6__DeleteOSD *p;
	struct _ns6__DeleteOSD *a = (struct _ns6__DeleteOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__DeleteOSD));
	for (p = a; p && n--; p++)
		soap_default__ns6__DeleteOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__DeleteOSD(struct soap *soap, const struct _ns6__DeleteOSD *a, const char *tag, const char *type)
{
	if (soap_out__ns6__DeleteOSD(soap, tag ? tag : "ns6:DeleteOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__DeleteOSD * SOAP_FMAC4 soap_get__ns6__DeleteOSD(struct soap *soap, struct _ns6__DeleteOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__CreateOSDResponse(struct soap *soap, struct _ns6__CreateOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__CreateOSDResponse(struct soap *soap, const struct _ns6__CreateOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__CreateOSDResponse(struct soap *soap, const char *tag, int id, const struct _ns6__CreateOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__CreateOSDResponse), type))
		return soap->error;
	if (a->OSDToken)
		soap_element_result(soap, "ns6:OSDToken");
	if (!a->OSDToken)
	{	if (soap_element_nil(soap, "ns6:OSDToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__CreateOSDResponse * SOAP_FMAC4 soap_in__ns6__CreateOSDResponse(struct soap *soap, const char *tag, struct _ns6__CreateOSDResponse *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__CreateOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__CreateOSDResponse, sizeof(struct _ns6__CreateOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__CreateOSDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			soap_check_result(soap, "ns6:OSDToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__CreateOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__CreateOSDResponse, SOAP_TYPE__ns6__CreateOSDResponse, sizeof(struct _ns6__CreateOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__CreateOSDResponse * SOAP_FMAC4 soap_new__ns6__CreateOSDResponse(struct soap *soap, int n)
{
	struct _ns6__CreateOSDResponse *p;
	struct _ns6__CreateOSDResponse *a = (struct _ns6__CreateOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__CreateOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__CreateOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__CreateOSDResponse(struct soap *soap, const struct _ns6__CreateOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__CreateOSDResponse(soap, tag ? tag : "ns6:CreateOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__CreateOSDResponse * SOAP_FMAC4 soap_get__ns6__CreateOSDResponse(struct soap *soap, struct _ns6__CreateOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__CreateOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__CreateOSD(struct soap *soap, struct _ns6__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__CreateOSD(struct soap *soap, const struct _ns6__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__CreateOSD(struct soap *soap, const char *tag, int id, const struct _ns6__CreateOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__CreateOSD), type))
		return soap->error;
	if (!a->OSD)
	{	if (soap_element_nil(soap, "ns6:OSD"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfiguration(soap, "ns6:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__CreateOSD * SOAP_FMAC4 soap_in__ns6__CreateOSD(struct soap *soap, const char *tag, struct _ns6__CreateOSD *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__CreateOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__CreateOSD, sizeof(struct _ns6__CreateOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__CreateOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfiguration(soap, "ns6:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSD > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__CreateOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__CreateOSD, SOAP_TYPE__ns6__CreateOSD, sizeof(struct _ns6__CreateOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__CreateOSD * SOAP_FMAC4 soap_new__ns6__CreateOSD(struct soap *soap, int n)
{
	struct _ns6__CreateOSD *p;
	struct _ns6__CreateOSD *a = (struct _ns6__CreateOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__CreateOSD));
	for (p = a; p && n--; p++)
		soap_default__ns6__CreateOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__CreateOSD(struct soap *soap, const struct _ns6__CreateOSD *a, const char *tag, const char *type)
{
	if (soap_out__ns6__CreateOSD(soap, tag ? tag : "ns6:CreateOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__CreateOSD * SOAP_FMAC4 soap_get__ns6__CreateOSD(struct soap *soap, struct _ns6__CreateOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetOSDOptionsResponse(struct soap *soap, struct _ns6__GetOSDOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSDOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetOSDOptionsResponse(struct soap *soap, const struct _ns6__GetOSDOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfigurationOptions(soap, &a->OSDOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetOSDOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetOSDOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetOSDOptionsResponse), type))
		return soap->error;
	if (a->OSDOptions)
		soap_element_result(soap, "ns6:OSDOptions");
	if (!a->OSDOptions)
	{	if (soap_element_nil(soap, "ns6:OSDOptions"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfigurationOptions(soap, "ns6:OSDOptions", -1, &a->OSDOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetOSDOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetOSDOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetOSDOptionsResponse *a, const char *type)
{
	size_t soap_flag_OSDOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetOSDOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetOSDOptionsResponse, sizeof(struct _ns6__GetOSDOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetOSDOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfigurationOptions(soap, "ns6:OSDOptions", &a->OSDOptions, "tt:OSDConfigurationOptions"))
				{	soap_flag_OSDOptions--;
					continue;
				}
			soap_check_result(soap, "ns6:OSDOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetOSDOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetOSDOptionsResponse, SOAP_TYPE__ns6__GetOSDOptionsResponse, sizeof(struct _ns6__GetOSDOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetOSDOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetOSDOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetOSDOptionsResponse *p;
	struct _ns6__GetOSDOptionsResponse *a = (struct _ns6__GetOSDOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetOSDOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetOSDOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetOSDOptionsResponse(struct soap *soap, const struct _ns6__GetOSDOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetOSDOptionsResponse(soap, tag ? tag : "ns6:GetOSDOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetOSDOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetOSDOptionsResponse(struct soap *soap, struct _ns6__GetOSDOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetOSDOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetOSDOptions(struct soap *soap, struct _ns6__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetOSDOptions(struct soap *soap, const struct _ns6__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetOSDOptions(struct soap *soap, const char *tag, int id, const struct _ns6__GetOSDOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetOSDOptions), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "ns6:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetOSDOptions * SOAP_FMAC4 soap_in__ns6__GetOSDOptions(struct soap *soap, const char *tag, struct _ns6__GetOSDOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetOSDOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetOSDOptions, sizeof(struct _ns6__GetOSDOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetOSDOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetOSDOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetOSDOptions, SOAP_TYPE__ns6__GetOSDOptions, sizeof(struct _ns6__GetOSDOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetOSDOptions * SOAP_FMAC4 soap_new__ns6__GetOSDOptions(struct soap *soap, int n)
{
	struct _ns6__GetOSDOptions *p;
	struct _ns6__GetOSDOptions *a = (struct _ns6__GetOSDOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetOSDOptions));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetOSDOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetOSDOptions(struct soap *soap, const struct _ns6__GetOSDOptions *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetOSDOptions(soap, tag ? tag : "ns6:GetOSDOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetOSDOptions * SOAP_FMAC4 soap_get__ns6__GetOSDOptions(struct soap *soap, struct _ns6__GetOSDOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetOSD(struct soap *soap, struct _ns6__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetOSD(struct soap *soap, const struct _ns6__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetOSD(struct soap *soap, const char *tag, int id, const struct _ns6__SetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetOSD), type))
		return soap->error;
	if (!a->OSD)
	{	if (soap_element_nil(soap, "ns6:OSD"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfiguration(soap, "ns6:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetOSD * SOAP_FMAC4 soap_in__ns6__SetOSD(struct soap *soap, const char *tag, struct _ns6__SetOSD *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetOSD, sizeof(struct _ns6__SetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfiguration(soap, "ns6:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSD > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetOSD, SOAP_TYPE__ns6__SetOSD, sizeof(struct _ns6__SetOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetOSD * SOAP_FMAC4 soap_new__ns6__SetOSD(struct soap *soap, int n)
{
	struct _ns6__SetOSD *p;
	struct _ns6__SetOSD *a = (struct _ns6__SetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetOSD));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetOSD(struct soap *soap, const struct _ns6__SetOSD *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetOSD(soap, tag ? tag : "ns6:SetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetOSD * SOAP_FMAC4 soap_get__ns6__SetOSD(struct soap *soap, struct _ns6__SetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetOSDsResponse(struct soap *soap, struct _ns6__GetOSDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOSDs = 0;
	a->OSDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetOSDsResponse(struct soap *soap, const struct _ns6__GetOSDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->OSDs)
	{	int i;
		for (i = 0; i < (int)a->__sizeOSDs; i++)
		{
			soap_embedded(soap, a->OSDs + i, SOAP_TYPE_tt__OSDConfiguration);
			soap_serialize_tt__OSDConfiguration(soap, a->OSDs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetOSDsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetOSDsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetOSDsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOSDs");
	if (a->OSDs)
	{	int i;
		for (i = 0; i < (int)a->__sizeOSDs; i++)
			if (soap_out_tt__OSDConfiguration(soap, "ns6:OSDs", -1, a->OSDs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetOSDsResponse * SOAP_FMAC4 soap_in__ns6__GetOSDsResponse(struct soap *soap, const char *tag, struct _ns6__GetOSDsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_OSDs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetOSDsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetOSDsResponse, sizeof(struct _ns6__GetOSDsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetOSDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:OSDs", 1, NULL))
			{	if (a->OSDs == NULL)
				{	if (soap_blist_OSDs == NULL)
						soap_blist_OSDs = soap_alloc_block(soap);
					a->OSDs = (struct tt__OSDConfiguration *)soap_push_block_max(soap, soap_blist_OSDs, sizeof(struct tt__OSDConfiguration));
					if (a->OSDs == NULL)
						return NULL;
					soap_default_tt__OSDConfiguration(soap, a->OSDs);
				}
				soap_revert(soap);
				if (soap_in_tt__OSDConfiguration(soap, "ns6:OSDs", a->OSDs, "tt:OSDConfiguration"))
				{	a->__sizeOSDs++;
					a->OSDs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOSDs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OSDs)
			soap_pop_block(soap, soap_blist_OSDs);
		if (a->__sizeOSDs)
		{	a->OSDs = (struct tt__OSDConfiguration *)soap_save_block(soap, soap_blist_OSDs, NULL, 1);
		}
		else
		{	a->OSDs = NULL;
			if (soap_blist_OSDs)
				soap_end_block(soap, soap_blist_OSDs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetOSDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetOSDsResponse, SOAP_TYPE__ns6__GetOSDsResponse, sizeof(struct _ns6__GetOSDsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetOSDsResponse * SOAP_FMAC4 soap_new__ns6__GetOSDsResponse(struct soap *soap, int n)
{
	struct _ns6__GetOSDsResponse *p;
	struct _ns6__GetOSDsResponse *a = (struct _ns6__GetOSDsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetOSDsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetOSDsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetOSDsResponse(struct soap *soap, const struct _ns6__GetOSDsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetOSDsResponse(soap, tag ? tag : "ns6:GetOSDsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetOSDsResponse * SOAP_FMAC4 soap_get__ns6__GetOSDsResponse(struct soap *soap, struct _ns6__GetOSDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetOSDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetOSDs(struct soap *soap, struct _ns6__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetOSDs(struct soap *soap, const struct _ns6__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetOSDs(struct soap *soap, const char *tag, int id, const struct _ns6__GetOSDs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetOSDs), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "ns6:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "ns6:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetOSDs * SOAP_FMAC4 soap_in__ns6__GetOSDs(struct soap *soap, const char *tag, struct _ns6__GetOSDs *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetOSDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetOSDs, sizeof(struct _ns6__GetOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetOSDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetOSDs, SOAP_TYPE__ns6__GetOSDs, sizeof(struct _ns6__GetOSDs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetOSDs * SOAP_FMAC4 soap_new__ns6__GetOSDs(struct soap *soap, int n)
{
	struct _ns6__GetOSDs *p;
	struct _ns6__GetOSDs *a = (struct _ns6__GetOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetOSDs));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetOSDs(struct soap *soap, const struct _ns6__GetOSDs *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetOSDs(soap, tag ? tag : "ns6:GetOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetOSDs * SOAP_FMAC4 soap_get__ns6__GetOSDs(struct soap *soap, struct _ns6__GetOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetVideoSourceModeResponse(struct soap *soap, struct _ns6__SetVideoSourceModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Reboot);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetVideoSourceModeResponse(struct soap *soap, const struct _ns6__SetVideoSourceModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Reboot, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetVideoSourceModeResponse(struct soap *soap, const char *tag, int id, const struct _ns6__SetVideoSourceModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetVideoSourceModeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns6:Reboot");
	if (soap_out_xsd__boolean(soap, "ns6:Reboot", -1, &a->Reboot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceModeResponse * SOAP_FMAC4 soap_in__ns6__SetVideoSourceModeResponse(struct soap *soap, const char *tag, struct _ns6__SetVideoSourceModeResponse *a, const char *type)
{
	size_t soap_flag_Reboot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetVideoSourceModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetVideoSourceModeResponse, sizeof(struct _ns6__SetVideoSourceModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetVideoSourceModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns6:Reboot", &a->Reboot, "xsd:boolean"))
				{	soap_flag_Reboot--;
					continue;
				}
			soap_check_result(soap, "ns6:Reboot");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Reboot > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetVideoSourceModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetVideoSourceModeResponse, SOAP_TYPE__ns6__SetVideoSourceModeResponse, sizeof(struct _ns6__SetVideoSourceModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetVideoSourceModeResponse * SOAP_FMAC4 soap_new__ns6__SetVideoSourceModeResponse(struct soap *soap, int n)
{
	struct _ns6__SetVideoSourceModeResponse *p;
	struct _ns6__SetVideoSourceModeResponse *a = (struct _ns6__SetVideoSourceModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetVideoSourceModeResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetVideoSourceModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetVideoSourceModeResponse(struct soap *soap, const struct _ns6__SetVideoSourceModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetVideoSourceModeResponse(soap, tag ? tag : "ns6:SetVideoSourceModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceModeResponse * SOAP_FMAC4 soap_get__ns6__SetVideoSourceModeResponse(struct soap *soap, struct _ns6__SetVideoSourceModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetVideoSourceModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetVideoSourceMode(struct soap *soap, struct _ns6__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceModeToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetVideoSourceMode(struct soap *soap, const struct _ns6__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceModeToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetVideoSourceMode(struct soap *soap, const char *tag, int id, const struct _ns6__SetVideoSourceMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetVideoSourceMode), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "ns6:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->VideoSourceModeToken)
	{	if (soap_element_nil(soap, "ns6:VideoSourceModeToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:VideoSourceModeToken", -1, (char*const*)&a->VideoSourceModeToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceMode * SOAP_FMAC4 soap_in__ns6__SetVideoSourceMode(struct soap *soap, const char *tag, struct _ns6__SetVideoSourceMode *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_VideoSourceModeToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetVideoSourceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetVideoSourceMode, sizeof(struct _ns6__SetVideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetVideoSourceMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_VideoSourceModeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:VideoSourceModeToken", (char**)&a->VideoSourceModeToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceModeToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_VideoSourceModeToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetVideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetVideoSourceMode, SOAP_TYPE__ns6__SetVideoSourceMode, sizeof(struct _ns6__SetVideoSourceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetVideoSourceMode * SOAP_FMAC4 soap_new__ns6__SetVideoSourceMode(struct soap *soap, int n)
{
	struct _ns6__SetVideoSourceMode *p;
	struct _ns6__SetVideoSourceMode *a = (struct _ns6__SetVideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetVideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetVideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetVideoSourceMode(struct soap *soap, const struct _ns6__SetVideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetVideoSourceMode(soap, tag ? tag : "ns6:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceMode * SOAP_FMAC4 soap_get__ns6__SetVideoSourceMode(struct soap *soap, struct _ns6__SetVideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoSourceModesResponse(struct soap *soap, struct _ns6__GetVideoSourceModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeVideoSourceModes = 0;
	a->VideoSourceModes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoSourceModesResponse(struct soap *soap, const struct _ns6__GetVideoSourceModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->VideoSourceModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceModes; i++)
		{
			soap_embedded(soap, a->VideoSourceModes + i, SOAP_TYPE_ns6__VideoSourceMode);
			soap_serialize_ns6__VideoSourceMode(soap, a->VideoSourceModes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoSourceModesResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoSourceModesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoSourceModesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeVideoSourceModes");
	if (a->VideoSourceModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceModes; i++)
			if (soap_out_ns6__VideoSourceMode(soap, "ns6:VideoSourceModes", -1, a->VideoSourceModes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceModesResponse * SOAP_FMAC4 soap_in__ns6__GetVideoSourceModesResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoSourceModesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_VideoSourceModes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoSourceModesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoSourceModesResponse, sizeof(struct _ns6__GetVideoSourceModesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoSourceModesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:VideoSourceModes", 1, NULL))
			{	if (a->VideoSourceModes == NULL)
				{	if (soap_blist_VideoSourceModes == NULL)
						soap_blist_VideoSourceModes = soap_alloc_block(soap);
					a->VideoSourceModes = (struct ns6__VideoSourceMode *)soap_push_block_max(soap, soap_blist_VideoSourceModes, sizeof(struct ns6__VideoSourceMode));
					if (a->VideoSourceModes == NULL)
						return NULL;
					soap_default_ns6__VideoSourceMode(soap, a->VideoSourceModes);
				}
				soap_revert(soap);
				if (soap_in_ns6__VideoSourceMode(soap, "ns6:VideoSourceModes", a->VideoSourceModes, "ns6:VideoSourceMode"))
				{	a->__sizeVideoSourceModes++;
					a->VideoSourceModes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeVideoSourceModes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceModes)
			soap_pop_block(soap, soap_blist_VideoSourceModes);
		if (a->__sizeVideoSourceModes)
		{	a->VideoSourceModes = (struct ns6__VideoSourceMode *)soap_save_block(soap, soap_blist_VideoSourceModes, NULL, 1);
		}
		else
		{	a->VideoSourceModes = NULL;
			if (soap_blist_VideoSourceModes)
				soap_end_block(soap, soap_blist_VideoSourceModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeVideoSourceModes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoSourceModesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoSourceModesResponse, SOAP_TYPE__ns6__GetVideoSourceModesResponse, sizeof(struct _ns6__GetVideoSourceModesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoSourceModesResponse * SOAP_FMAC4 soap_new__ns6__GetVideoSourceModesResponse(struct soap *soap, int n)
{
	struct _ns6__GetVideoSourceModesResponse *p;
	struct _ns6__GetVideoSourceModesResponse *a = (struct _ns6__GetVideoSourceModesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoSourceModesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoSourceModesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoSourceModesResponse(struct soap *soap, const struct _ns6__GetVideoSourceModesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoSourceModesResponse(soap, tag ? tag : "ns6:GetVideoSourceModesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceModesResponse * SOAP_FMAC4 soap_get__ns6__GetVideoSourceModesResponse(struct soap *soap, struct _ns6__GetVideoSourceModesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoSourceModesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoSourceModes(struct soap *soap, struct _ns6__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoSourceModes(struct soap *soap, const struct _ns6__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoSourceModes(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoSourceModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoSourceModes), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "ns6:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceModes * SOAP_FMAC4 soap_in__ns6__GetVideoSourceModes(struct soap *soap, const char *tag, struct _ns6__GetVideoSourceModes *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoSourceModes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoSourceModes, sizeof(struct _ns6__GetVideoSourceModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoSourceModes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoSourceModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoSourceModes, SOAP_TYPE__ns6__GetVideoSourceModes, sizeof(struct _ns6__GetVideoSourceModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoSourceModes * SOAP_FMAC4 soap_new__ns6__GetVideoSourceModes(struct soap *soap, int n)
{
	struct _ns6__GetVideoSourceModes *p;
	struct _ns6__GetVideoSourceModes *a = (struct _ns6__GetVideoSourceModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoSourceModes));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoSourceModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoSourceModes(struct soap *soap, const struct _ns6__GetVideoSourceModes *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoSourceModes(soap, tag ? tag : "ns6:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceModes * SOAP_FMAC4 soap_get__ns6__GetVideoSourceModes(struct soap *soap, struct _ns6__GetVideoSourceModes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__StartStopMulticastStreamingResponse(struct soap *soap, struct _ns6__StartStopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__StartStopMulticastStreamingResponse(struct soap *soap, const struct _ns6__StartStopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__StartStopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _ns6__StartStopMulticastStreamingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__StartStopMulticastStreamingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__StartStopMulticastStreamingResponse * SOAP_FMAC4 soap_in__ns6__StartStopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _ns6__StartStopMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__StartStopMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__StartStopMulticastStreamingResponse, sizeof(struct _ns6__StartStopMulticastStreamingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__StartStopMulticastStreamingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__StartStopMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__StartStopMulticastStreamingResponse, SOAP_TYPE__ns6__StartStopMulticastStreamingResponse, sizeof(struct _ns6__StartStopMulticastStreamingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__StartStopMulticastStreamingResponse * SOAP_FMAC4 soap_new__ns6__StartStopMulticastStreamingResponse(struct soap *soap, int n)
{
	struct _ns6__StartStopMulticastStreamingResponse *p;
	struct _ns6__StartStopMulticastStreamingResponse *a = (struct _ns6__StartStopMulticastStreamingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__StartStopMulticastStreamingResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__StartStopMulticastStreamingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__StartStopMulticastStreamingResponse(struct soap *soap, const struct _ns6__StartStopMulticastStreamingResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__StartStopMulticastStreamingResponse(soap, tag ? tag : "ns6:StartStopMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__StartStopMulticastStreamingResponse * SOAP_FMAC4 soap_get__ns6__StartStopMulticastStreamingResponse(struct soap *soap, struct _ns6__StartStopMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__StartStopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetSnapshotUriResponse(struct soap *soap, struct _ns6__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetSnapshotUriResponse(struct soap *soap, const struct _ns6__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetSnapshotUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetSnapshotUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "ns6:Uri");
	if (!a->Uri)
	{	if (soap_element_nil(soap, "ns6:Uri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "ns6:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetSnapshotUriResponse * SOAP_FMAC4 soap_in__ns6__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _ns6__GetSnapshotUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetSnapshotUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetSnapshotUriResponse, sizeof(struct _ns6__GetSnapshotUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetSnapshotUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns6:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			soap_check_result(soap, "ns6:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetSnapshotUriResponse, SOAP_TYPE__ns6__GetSnapshotUriResponse, sizeof(struct _ns6__GetSnapshotUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetSnapshotUriResponse * SOAP_FMAC4 soap_new__ns6__GetSnapshotUriResponse(struct soap *soap, int n)
{
	struct _ns6__GetSnapshotUriResponse *p;
	struct _ns6__GetSnapshotUriResponse *a = (struct _ns6__GetSnapshotUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetSnapshotUriResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetSnapshotUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetSnapshotUriResponse(struct soap *soap, const struct _ns6__GetSnapshotUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetSnapshotUriResponse(soap, tag ? tag : "ns6:GetSnapshotUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetSnapshotUriResponse * SOAP_FMAC4 soap_get__ns6__GetSnapshotUriResponse(struct soap *soap, struct _ns6__GetSnapshotUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetSnapshotUri(struct soap *soap, struct _ns6__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetSnapshotUri(struct soap *soap, const struct _ns6__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct _ns6__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetSnapshotUri), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns6:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetSnapshotUri * SOAP_FMAC4 soap_in__ns6__GetSnapshotUri(struct soap *soap, const char *tag, struct _ns6__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetSnapshotUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetSnapshotUri, sizeof(struct _ns6__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetSnapshotUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetSnapshotUri, SOAP_TYPE__ns6__GetSnapshotUri, sizeof(struct _ns6__GetSnapshotUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetSnapshotUri * SOAP_FMAC4 soap_new__ns6__GetSnapshotUri(struct soap *soap, int n)
{
	struct _ns6__GetSnapshotUri *p;
	struct _ns6__GetSnapshotUri *a = (struct _ns6__GetSnapshotUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetSnapshotUri));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetSnapshotUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetSnapshotUri(struct soap *soap, const struct _ns6__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetSnapshotUri(soap, tag ? tag : "ns6:GetSnapshotUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetSnapshotUri * SOAP_FMAC4 soap_get__ns6__GetSnapshotUri(struct soap *soap, struct _ns6__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
