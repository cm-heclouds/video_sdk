/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurationsResponse(struct soap *soap, const struct _tls__SetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_in__tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationsResponse, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_new__tls__SetPaneConfigurationsResponse(struct soap *soap, int n)
{
	struct _tls__SetPaneConfigurationsResponse *p;
	struct _tls__SetPaneConfigurationsResponse *a = (struct _tls__SetPaneConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurationsResponse(struct soap *soap, const struct _tls__SetPaneConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfigurationsResponse(soap, tag ? tag : "tls:SetPaneConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_get__tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__sizePaneConfiguration = 0;
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurations(struct soap *soap, const struct _tls__SetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
		{
			soap_embedded(soap, a->PaneConfiguration + i, SOAP_TYPE_tt__PaneConfiguration);
			soap_serialize_tt__PaneConfiguration(soap, a->PaneConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurations(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurations), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
			if (soap_out_tt__PaneConfiguration(soap, "tls:PaneConfiguration", -1, a->PaneConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_in__tls__SetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurations *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist_PaneConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
			{	if (a->PaneConfiguration == NULL)
				{	if (soap_blist_PaneConfiguration == NULL)
						soap_blist_PaneConfiguration = soap_alloc_block(soap);
					a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_push_block_max(soap, soap_blist_PaneConfiguration, sizeof(struct tt__PaneConfiguration));
					if (a->PaneConfiguration == NULL)
						return NULL;
					soap_default_tt__PaneConfiguration(soap, a->PaneConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneConfiguration(soap, "tls:PaneConfiguration", a->PaneConfiguration, "tt:PaneConfiguration"))
				{	a->__sizePaneConfiguration++;
					a->PaneConfiguration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneConfiguration)
			soap_pop_block(soap, soap_blist_PaneConfiguration);
		if (a->__sizePaneConfiguration)
		{	a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_save_block(soap, soap_blist_PaneConfiguration, NULL, 1);
		}
		else
		{	a->PaneConfiguration = NULL;
			if (soap_blist_PaneConfiguration)
				soap_end_block(soap, soap_blist_PaneConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || a->__sizePaneConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurations, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_new__tls__SetPaneConfigurations(struct soap *soap, int n)
{
	struct _tls__SetPaneConfigurations *p;
	struct _tls__SetPaneConfigurations *a = (struct _tls__SetPaneConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurations(struct soap *soap, const struct _tls__SetPaneConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfigurations(soap, tag ? tag : "tls:SetPaneConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_get__tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurationResponse(struct soap *soap, const struct _tls__GetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse), type))
		return soap->error;
	if (a->PaneConfiguration)
		soap_element_result(soap, "tls:PaneConfiguration");
	if (!a->PaneConfiguration)
	{	if (soap_element_nil(soap, "tls:PaneConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PaneConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			soap_check_result(soap, "tls:PaneConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PaneConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationResponse, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__GetPaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__GetPaneConfigurationResponse *p;
	struct _tls__GetPaneConfigurationResponse *a = (struct _tls__GetPaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurationResponse(struct soap *soap, const struct _tls__GetPaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfigurationResponse(soap, tag ? tag : "tls:GetPaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_default_tt__ReferenceToken(soap, &a->Pane);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfiguration(struct soap *soap, const struct _tls__GetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Pane);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->Pane)
	{	if (soap_element_nil(soap, "tls:Pane"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:Pane", -1, (char*const*)&a->Pane, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_in__tls__GetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__GetPaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_Pane = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:Pane", (char**)&a->Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_Pane > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfiguration, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_new__tls__GetPaneConfiguration(struct soap *soap, int n)
{
	struct _tls__GetPaneConfiguration *p;
	struct _tls__GetPaneConfiguration *a = (struct _tls__GetPaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfiguration(struct soap *soap, const struct _tls__GetPaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfiguration(soap, tag ? tag : "tls:GetPaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_get__tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneConfiguration = 0;
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurationsResponse(struct soap *soap, const struct _tls__GetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
		{
			soap_embedded(soap, a->PaneConfiguration + i, SOAP_TYPE_tt__PaneConfiguration);
			soap_serialize_tt__PaneConfiguration(soap, a->PaneConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePaneConfiguration");
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePaneConfiguration; i++)
			if (soap_out_tt__PaneConfiguration(soap, "tls:PaneConfiguration", -1, a->PaneConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_in__tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PaneConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
			{	if (a->PaneConfiguration == NULL)
				{	if (soap_blist_PaneConfiguration == NULL)
						soap_blist_PaneConfiguration = soap_alloc_block(soap);
					a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_push_block_max(soap, soap_blist_PaneConfiguration, sizeof(struct tt__PaneConfiguration));
					if (a->PaneConfiguration == NULL)
						return NULL;
					soap_default_tt__PaneConfiguration(soap, a->PaneConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneConfiguration(soap, "tls:PaneConfiguration", a->PaneConfiguration, "tt:PaneConfiguration"))
				{	a->__sizePaneConfiguration++;
					a->PaneConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePaneConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneConfiguration)
			soap_pop_block(soap, soap_blist_PaneConfiguration);
		if (a->__sizePaneConfiguration)
		{	a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_save_block(soap, soap_blist_PaneConfiguration, NULL, 1);
		}
		else
		{	a->PaneConfiguration = NULL;
			if (soap_blist_PaneConfiguration)
				soap_end_block(soap, soap_blist_PaneConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationsResponse, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_new__tls__GetPaneConfigurationsResponse(struct soap *soap, int n)
{
	struct _tls__GetPaneConfigurationsResponse *p;
	struct _tls__GetPaneConfigurationsResponse *a = (struct _tls__GetPaneConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurationsResponse(struct soap *soap, const struct _tls__GetPaneConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfigurationsResponse(soap, tag ? tag : "tls:GetPaneConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_get__tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurations(struct soap *soap, const struct _tls__GetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurations(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurations), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_in__tls__GetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurations *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurations, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_new__tls__GetPaneConfigurations(struct soap *soap, int n)
{
	struct _tls__GetPaneConfigurations *p;
	struct _tls__GetPaneConfigurations *a = (struct _tls__GetPaneConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetPaneConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tls__GetPaneConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurations(struct soap *soap, const struct _tls__GetPaneConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetPaneConfigurations(soap, tag ? tag : "tls:GetPaneConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_get__tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->LayoutOptions = NULL;
	a->CodingCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetDisplayOptionsResponse(struct soap *soap, const struct _tls__GetDisplayOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__LayoutOptions(soap, &a->LayoutOptions);
	soap_serialize_PointerTott__CodingCapabilities(soap, &a->CodingCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetDisplayOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse), type))
		return soap->error;
	if (a->LayoutOptions)
		soap_element_result(soap, "tls:LayoutOptions");
	if (soap_out_PointerTott__LayoutOptions(soap, "tls:LayoutOptions", -1, &a->LayoutOptions, ""))
		return soap->error;
	if (!a->CodingCapabilities)
	{	if (soap_element_nil(soap, "tls:CodingCapabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__CodingCapabilities(soap, "tls:CodingCapabilities", -1, &a->CodingCapabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_in__tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, struct _tls__GetDisplayOptionsResponse *a, const char *type)
{
	size_t soap_flag_LayoutOptions = 1;
	size_t soap_flag_CodingCapabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetDisplayOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LayoutOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LayoutOptions(soap, "tls:LayoutOptions", &a->LayoutOptions, "tt:LayoutOptions"))
				{	soap_flag_LayoutOptions--;
					continue;
				}
			if (soap_flag_CodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CodingCapabilities(soap, "tls:CodingCapabilities", &a->CodingCapabilities, "tt:CodingCapabilities"))
				{	soap_flag_CodingCapabilities--;
					continue;
				}
			soap_check_result(soap, "tls:LayoutOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CodingCapabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptionsResponse, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_new__tls__GetDisplayOptionsResponse(struct soap *soap, int n)
{
	struct _tls__GetDisplayOptionsResponse *p;
	struct _tls__GetDisplayOptionsResponse *a = (struct _tls__GetDisplayOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetDisplayOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetDisplayOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetDisplayOptionsResponse(struct soap *soap, const struct _tls__GetDisplayOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetDisplayOptionsResponse(soap, tag ? tag : "tls:GetDisplayOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_get__tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetDisplayOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetDisplayOptions(struct soap *soap, const struct _tls__GetDisplayOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetDisplayOptions(struct soap *soap, const char *tag, int id, const struct _tls__GetDisplayOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetDisplayOptions), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_in__tls__GetDisplayOptions(struct soap *soap, const char *tag, struct _tls__GetDisplayOptions *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetDisplayOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetDisplayOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptions, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_new__tls__GetDisplayOptions(struct soap *soap, int n)
{
	struct _tls__GetDisplayOptions *p;
	struct _tls__GetDisplayOptions *a = (struct _tls__GetDisplayOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetDisplayOptions));
	for (p = a; p && n--; p++)
		soap_default__tls__GetDisplayOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetDisplayOptions(struct soap *soap, const struct _tls__GetDisplayOptions *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetDisplayOptions(soap, tag ? tag : "tls:GetDisplayOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_get__tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetDisplayOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetLayoutResponse(struct soap *soap, const struct _tls__SetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetLayoutResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetLayoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetLayoutResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_in__tls__SetLayoutResponse(struct soap *soap, const char *tag, struct _tls__SetLayoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetLayoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetLayoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayoutResponse, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_new__tls__SetLayoutResponse(struct soap *soap, int n)
{
	struct _tls__SetLayoutResponse *p;
	struct _tls__SetLayoutResponse *a = (struct _tls__SetLayoutResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetLayoutResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__SetLayoutResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetLayoutResponse(struct soap *soap, const struct _tls__SetLayoutResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetLayoutResponse(soap, tag ? tag : "tls:SetLayoutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_get__tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetLayout(struct soap *soap, struct _tls__SetLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->Layout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetLayout(struct soap *soap, const struct _tls__SetLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetLayout(struct soap *soap, const char *tag, int id, const struct _tls__SetLayout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetLayout), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->Layout)
	{	if (soap_element_nil(soap, "tls:Layout"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Layout(soap, "tls:Layout", -1, &a->Layout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetLayout * SOAP_FMAC4 soap_in__tls__SetLayout(struct soap *soap, const char *tag, struct _tls__SetLayout *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_Layout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetLayout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Layout(soap, "tls:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_Layout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__SetLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayout, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetLayout * SOAP_FMAC4 soap_new__tls__SetLayout(struct soap *soap, int n)
{
	struct _tls__SetLayout *p;
	struct _tls__SetLayout *a = (struct _tls__SetLayout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetLayout));
	for (p = a; p && n--; p++)
		soap_default__tls__SetLayout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetLayout(struct soap *soap, const struct _tls__SetLayout *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetLayout(soap, tag ? tag : "tls:SetLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayout * SOAP_FMAC4 soap_get__tls__SetLayout(struct soap *soap, struct _tls__SetLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Layout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetLayoutResponse(struct soap *soap, const struct _tls__GetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetLayoutResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetLayoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetLayoutResponse), type))
		return soap->error;
	if (a->Layout)
		soap_element_result(soap, "tls:Layout");
	if (!a->Layout)
	{	if (soap_element_nil(soap, "tls:Layout"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Layout(soap, "tls:Layout", -1, &a->Layout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetLayoutResponse * SOAP_FMAC4 soap_in__tls__GetLayoutResponse(struct soap *soap, const char *tag, struct _tls__GetLayoutResponse *a, const char *type)
{
	size_t soap_flag_Layout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetLayoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetLayoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Layout(soap, "tls:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			soap_check_result(soap, "tls:Layout");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Layout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetLayoutResponse, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetLayoutResponse * SOAP_FMAC4 soap_new__tls__GetLayoutResponse(struct soap *soap, int n)
{
	struct _tls__GetLayoutResponse *p;
	struct _tls__GetLayoutResponse *a = (struct _tls__GetLayoutResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetLayoutResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetLayoutResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetLayoutResponse(struct soap *soap, const struct _tls__GetLayoutResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetLayoutResponse(soap, tag ? tag : "tls:GetLayoutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetLayoutResponse * SOAP_FMAC4 soap_get__tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetLayout(struct soap *soap, struct _tls__GetLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetLayout(struct soap *soap, const struct _tls__GetLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetLayout(struct soap *soap, const char *tag, int id, const struct _tls__GetLayout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetLayout), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetLayout * SOAP_FMAC4 soap_in__tls__GetLayout(struct soap *soap, const char *tag, struct _tls__GetLayout *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetLayout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetLayout, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetLayout * SOAP_FMAC4 soap_new__tls__GetLayout(struct soap *soap, int n)
{
	struct _tls__GetLayout *p;
	struct _tls__GetLayout *a = (struct _tls__GetLayout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetLayout));
	for (p = a; p && n--; p++)
		soap_default__tls__GetLayout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetLayout(struct soap *soap, const struct _tls__GetLayout *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetLayout(soap, tag ? tag : "tls:GetLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetLayout * SOAP_FMAC4 soap_get__tls__GetLayout(struct soap *soap, struct _tls__GetLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tls__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotls__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tls:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tls:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotls__Capabilities(soap, "tls:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tls__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tls__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotls__Capabilities(soap, "tls:Capabilities", &a->Capabilities, "tls:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tls:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tls__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tls__GetServiceCapabilitiesResponse *p;
	struct _tls__GetServiceCapabilitiesResponse *a = (struct _tls__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tls__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetServiceCapabilitiesResponse(soap, tag ? tag : "tls:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetServiceCapabilities(struct soap *soap, const struct _tls__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tls__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities * SOAP_FMAC4 soap_in__tls__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tls__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetServiceCapabilities, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities * SOAP_FMAC4 soap_new__tls__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tls__GetServiceCapabilities *p;
	struct _tls__GetServiceCapabilities *a = (struct _tls__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tls__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetServiceCapabilities(struct soap *soap, const struct _tls__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tls__GetServiceCapabilities(soap, tag ? tag : "tls:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities * SOAP_FMAC4 soap_get__tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tls__Capabilities(struct soap *soap, struct tls__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FixedLayout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tls__Capabilities(struct soap *soap, const struct tls__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tls__Capabilities(struct soap *soap, const char *tag, int id, const struct tls__Capabilities *a, const char *type)
{
	if (a->FixedLayout)
		soap_set_attr(soap, "FixedLayout", soap_xsd__boolean2s(soap, *a->FixedLayout), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tls__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tls__Capabilities * SOAP_FMAC4 soap_in_tls__Capabilities(struct soap *soap, const char *tag, struct tls__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tls__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tls__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "FixedLayout", 0);
		if (t)
		{
			if (!(a->FixedLayout = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FixedLayout))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tls__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tls__Capabilities, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tls__Capabilities * SOAP_FMAC4 soap_new_tls__Capabilities(struct soap *soap, int n)
{
	struct tls__Capabilities *p;
	struct tls__Capabilities *a = (struct tls__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tls__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tls__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tls__Capabilities(struct soap *soap, const struct tls__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tls__Capabilities(soap, tag ? tag : "tls:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tls__Capabilities * SOAP_FMAC4 soap_get_tls__Capabilities(struct soap *soap, struct tls__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tls__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteStorageConfigurationResponse(struct soap *soap, struct _tds__DeleteStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteStorageConfigurationResponse(struct soap *soap, const struct _tds__DeleteStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(struct _tds__DeleteStorageConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteStorageConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(struct _tds__DeleteStorageConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_new__tds__DeleteStorageConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__DeleteStorageConfigurationResponse *p;
	struct _tds__DeleteStorageConfigurationResponse *a = (struct _tds__DeleteStorageConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteStorageConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteStorageConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteStorageConfigurationResponse(struct soap *soap, const struct _tds__DeleteStorageConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteStorageConfigurationResponse(soap, tag ? tag : "tds:DeleteStorageConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteStorageConfigurationResponse(struct soap *soap, struct _tds__DeleteStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteStorageConfiguration(struct soap *soap, struct _tds__DeleteStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteStorageConfiguration(struct soap *soap, const struct _tds__DeleteStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfiguration), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "tds:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_in__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteStorageConfiguration *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(struct _tds__DeleteStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteStorageConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__DeleteStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfiguration, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(struct _tds__DeleteStorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_new__tds__DeleteStorageConfiguration(struct soap *soap, int n)
{
	struct _tds__DeleteStorageConfiguration *p;
	struct _tds__DeleteStorageConfiguration *a = (struct _tds__DeleteStorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteStorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteStorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteStorageConfiguration(struct soap *soap, const struct _tds__DeleteStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteStorageConfiguration(soap, tag ? tag : "tds:DeleteStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_get__tds__DeleteStorageConfiguration(struct soap *soap, struct _tds__DeleteStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetStorageConfigurationResponse(struct soap *soap, struct _tds__SetStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetStorageConfigurationResponse(struct soap *soap, const struct _tds__SetStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetStorageConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(struct _tds__SetStorageConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetStorageConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfigurationResponse, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(struct _tds__SetStorageConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_new__tds__SetStorageConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__SetStorageConfigurationResponse *p;
	struct _tds__SetStorageConfigurationResponse *a = (struct _tds__SetStorageConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetStorageConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetStorageConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetStorageConfigurationResponse(struct soap *soap, const struct _tds__SetStorageConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetStorageConfigurationResponse(soap, tag ? tag : "tds:SetStorageConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetStorageConfigurationResponse(struct soap *soap, struct _tds__SetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetStorageConfiguration(struct soap *soap, struct _tds__SetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetStorageConfiguration(struct soap *soap, const struct _tds__SetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &a->StorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__SetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfiguration), type))
		return soap->error;
	if (!a->StorageConfiguration)
	{	if (soap_element_nil(soap, "tds:StorageConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetStorageConfiguration * SOAP_FMAC4 soap_in__tds__SetStorageConfiguration(struct soap *soap, const char *tag, struct _tds__SetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_StorageConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(struct _tds__SetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetStorageConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StorageConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfiguration, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(struct _tds__SetStorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetStorageConfiguration * SOAP_FMAC4 soap_new__tds__SetStorageConfiguration(struct soap *soap, int n)
{
	struct _tds__SetStorageConfiguration *p;
	struct _tds__SetStorageConfiguration *a = (struct _tds__SetStorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetStorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__SetStorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetStorageConfiguration(struct soap *soap, const struct _tds__SetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetStorageConfiguration(soap, tag ? tag : "tds:SetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetStorageConfiguration * SOAP_FMAC4 soap_get__tds__SetStorageConfiguration(struct soap *soap, struct _tds__SetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetStorageConfigurationResponse(struct soap *soap, struct _tds__GetStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetStorageConfigurationResponse(struct soap *soap, const struct _tds__GetStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &a->StorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse), type))
		return soap->error;
	if (a->StorageConfiguration)
		soap_element_result(soap, "tds:StorageConfiguration");
	if (!a->StorageConfiguration)
	{	if (soap_element_nil(soap, "tds:StorageConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetStorageConfigurationResponse *a, const char *type)
{
	size_t soap_flag_StorageConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(struct _tds__GetStorageConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration--;
					continue;
				}
			soap_check_result(soap, "tds:StorageConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StorageConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationResponse, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(struct _tds__GetStorageConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_new__tds__GetStorageConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__GetStorageConfigurationResponse *p;
	struct _tds__GetStorageConfigurationResponse *a = (struct _tds__GetStorageConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfigurationResponse(struct soap *soap, const struct _tds__GetStorageConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfigurationResponse(soap, tag ? tag : "tds:GetStorageConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationResponse(struct soap *soap, struct _tds__GetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetStorageConfiguration(struct soap *soap, struct _tds__GetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetStorageConfiguration(struct soap *soap, const struct _tds__GetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__GetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfiguration), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "tds:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetStorageConfiguration * SOAP_FMAC4 soap_in__tds__GetStorageConfiguration(struct soap *soap, const char *tag, struct _tds__GetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfiguration, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(struct _tds__GetStorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfiguration * SOAP_FMAC4 soap_new__tds__GetStorageConfiguration(struct soap *soap, int n)
{
	struct _tds__GetStorageConfiguration *p;
	struct _tds__GetStorageConfiguration *a = (struct _tds__GetStorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfiguration(struct soap *soap, const struct _tds__GetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfiguration * SOAP_FMAC4 soap_get__tds__GetStorageConfiguration(struct soap *soap, struct _tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateStorageConfigurationResponse(struct soap *soap, struct _tds__CreateStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateStorageConfigurationResponse(struct soap *soap, const struct _tds__CreateStorageConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse), type))
		return soap->error;
	if (a->Token)
		soap_element_result(soap, "tds:Token");
	if (!a->Token)
	{	if (soap_element_nil(soap, "tds:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateStorageConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateStorageConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			soap_check_result(soap, "tds:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfigurationResponse, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(struct _tds__CreateStorageConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_new__tds__CreateStorageConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__CreateStorageConfigurationResponse *p;
	struct _tds__CreateStorageConfigurationResponse *a = (struct _tds__CreateStorageConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateStorageConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateStorageConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateStorageConfigurationResponse(struct soap *soap, const struct _tds__CreateStorageConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateStorageConfigurationResponse(soap, tag ? tag : "tds:CreateStorageConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateStorageConfigurationResponse(struct soap *soap, struct _tds__CreateStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateStorageConfiguration(struct soap *soap, struct _tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateStorageConfiguration(struct soap *soap, const struct _tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &a->StorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfiguration), type))
		return soap->error;
	if (!a->StorageConfiguration)
	{	if (soap_element_nil(soap, "tds:StorageConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", -1, &a->StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, struct _tds__CreateStorageConfiguration *a, const char *type)
{
	size_t soap_flag_StorageConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateStorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateStorageConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", &a->StorageConfiguration, "tds:StorageConfigurationData"))
				{	soap_flag_StorageConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StorageConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfiguration, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(struct _tds__CreateStorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_new__tds__CreateStorageConfiguration(struct soap *soap, int n)
{
	struct _tds__CreateStorageConfiguration *p;
	struct _tds__CreateStorageConfiguration *a = (struct _tds__CreateStorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateStorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateStorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateStorageConfiguration(struct soap *soap, const struct _tds__CreateStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get__tds__CreateStorageConfiguration(struct soap *soap, struct _tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Data = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__StorageConfiguration(struct soap *soap, const struct tds__StorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &a->Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfiguration(struct soap *soap, const char *tag, int id, const struct tds__StorageConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfiguration), type))
		return soap->error;
	if (!a->Data)
	{	if (soap_element_nil(soap, "tds:Data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__StorageConfiguration * SOAP_FMAC4 soap_in_tds__StorageConfiguration(struct soap *soap, const char *tag, struct tds__StorageConfiguration *a, const char *type)
{
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__StorageConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__StorageConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:Data", &a->Data, "tds:StorageConfigurationData"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__StorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_tds__StorageConfiguration, sizeof(struct tds__StorageConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__StorageConfiguration * SOAP_FMAC4 soap_new_tds__StorageConfiguration(struct soap *soap, int n)
{
	struct tds__StorageConfiguration *p;
	struct tds__StorageConfiguration *a = (struct tds__StorageConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__StorageConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tds__StorageConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__StorageConfiguration(struct soap *soap, const struct tds__StorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfiguration * SOAP_FMAC4 soap_get_tds__StorageConfiguration(struct soap *soap, struct tds__StorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetStorageConfigurationsResponse(struct soap *soap, struct _tds__GetStorageConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeStorageConfigurations = 0;
	a->StorageConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetStorageConfigurationsResponse(struct soap *soap, const struct _tds__GetStorageConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->StorageConfigurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeStorageConfigurations; i++)
		{
			soap_embedded(soap, a->StorageConfigurations + i, SOAP_TYPE_tds__StorageConfiguration);
			soap_serialize_tds__StorageConfiguration(soap, a->StorageConfigurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeStorageConfigurations");
	if (a->StorageConfigurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeStorageConfigurations; i++)
			if (soap_out_tds__StorageConfiguration(soap, "tds:StorageConfigurations", -1, a->StorageConfigurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_StorageConfigurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetStorageConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:StorageConfigurations", 1, NULL))
			{	if (a->StorageConfigurations == NULL)
				{	if (soap_blist_StorageConfigurations == NULL)
						soap_blist_StorageConfigurations = soap_alloc_block(soap);
					a->StorageConfigurations = (struct tds__StorageConfiguration *)soap_push_block_max(soap, soap_blist_StorageConfigurations, sizeof(struct tds__StorageConfiguration));
					if (a->StorageConfigurations == NULL)
						return NULL;
					soap_default_tds__StorageConfiguration(soap, a->StorageConfigurations);
				}
				soap_revert(soap);
				if (soap_in_tds__StorageConfiguration(soap, "tds:StorageConfigurations", a->StorageConfigurations, "tds:StorageConfiguration"))
				{	a->__sizeStorageConfigurations++;
					a->StorageConfigurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeStorageConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->StorageConfigurations)
			soap_pop_block(soap, soap_blist_StorageConfigurations);
		if (a->__sizeStorageConfigurations)
		{	a->StorageConfigurations = (struct tds__StorageConfiguration *)soap_save_block(soap, soap_blist_StorageConfigurations, NULL, 1);
		}
		else
		{	a->StorageConfigurations = NULL;
			if (soap_blist_StorageConfigurations)
				soap_end_block(soap, soap_blist_StorageConfigurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationsResponse, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(struct _tds__GetStorageConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_new__tds__GetStorageConfigurationsResponse(struct soap *soap, int n)
{
	struct _tds__GetStorageConfigurationsResponse *p;
	struct _tds__GetStorageConfigurationsResponse *a = (struct _tds__GetStorageConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfigurationsResponse(struct soap *soap, const struct _tds__GetStorageConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfigurationsResponse(soap, tag ? tag : "tds:GetStorageConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationsResponse(struct soap *soap, struct _tds__GetStorageConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetStorageConfigurations(struct soap *soap, struct _tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetStorageConfigurations(struct soap *soap, const struct _tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const struct _tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurations * SOAP_FMAC4 soap_in__tds__GetStorageConfigurations(struct soap *soap, const char *tag, struct _tds__GetStorageConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetStorageConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetStorageConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetStorageConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurations, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(struct _tds__GetStorageConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetStorageConfigurations * SOAP_FMAC4 soap_new__tds__GetStorageConfigurations(struct soap *soap, int n)
{
	struct _tds__GetStorageConfigurations *p;
	struct _tds__GetStorageConfigurations *a = (struct _tds__GetStorageConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetStorageConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tds__GetStorageConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetStorageConfigurations(struct soap *soap, const struct _tds__GetStorageConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetStorageConfigurations * SOAP_FMAC4 soap_get__tds__GetStorageConfigurations(struct soap *soap, struct _tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->UploadUri);
	soap_default_xsd__duration(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->UploadUri);
	soap_embedded(soap, &a->ExpectedDownTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (!a->UploadUri)
	{	if (soap_element_nil(soap, "tds:UploadUri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, (char*const*)&a->UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartSystemRestoreResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestoreResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:UploadUri", (char**)&a->UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri--;
					continue;
				}
			if (soap_flag_ExpectedDownTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri > 0 || soap_flag_ExpectedDownTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_new__tds__StartSystemRestoreResponse(struct soap *soap, int n)
{
	struct _tds__StartSystemRestoreResponse *p;
	struct _tds__StartSystemRestoreResponse *a = (struct _tds__StartSystemRestoreResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartSystemRestoreResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__StartSystemRestoreResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag ? tag : "tds:StartSystemRestoreResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, struct _tds__StartSystemRestore *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartSystemRestore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestore(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_new__tds__StartSystemRestore(struct soap *soap, int n)
{
	struct _tds__StartSystemRestore *p;
	struct _tds__StartSystemRestore *a = (struct _tds__StartSystemRestore*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartSystemRestore));
	for (p = a; p && n--; p++)
		soap_default__tds__StartSystemRestore(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->UploadUri);
	soap_default_xsd__duration(soap, &a->UploadDelay);
	soap_default_xsd__duration(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->UploadUri);
	soap_embedded(soap, &a->UploadDelay, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->ExpectedDownTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (!a->UploadUri)
	{	if (soap_element_nil(soap, "tds:UploadUri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, (char*const*)&a->UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, &a->UploadDelay, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_UploadDelay = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgradeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:UploadUri", (char**)&a->UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri--;
					continue;
				}
			if (soap_flag_UploadDelay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:UploadDelay", &a->UploadDelay, "xsd:duration"))
				{	soap_flag_UploadDelay--;
					continue;
				}
			if (soap_flag_ExpectedDownTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri > 0 || soap_flag_UploadDelay > 0 || soap_flag_ExpectedDownTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_new__tds__StartFirmwareUpgradeResponse(struct soap *soap, int n)
{
	struct _tds__StartFirmwareUpgradeResponse *p;
	struct _tds__StartFirmwareUpgradeResponse *a = (struct _tds__StartFirmwareUpgradeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartFirmwareUpgradeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__StartFirmwareUpgradeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag ? tag : "tds:StartFirmwareUpgradeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartFirmwareUpgrade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgrade(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_new__tds__StartFirmwareUpgrade(struct soap *soap, int n)
{
	struct _tds__StartFirmwareUpgrade *p;
	struct _tds__StartFirmwareUpgrade *a = (struct _tds__StartFirmwareUpgrade*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StartFirmwareUpgrade));
	for (p = a; p && n--; p++)
		soap_default__tds__StartFirmwareUpgrade(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse_Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_new__tds__GetSystemUrisResponse_Extension(struct soap *soap, int n)
{
	struct _tds__GetSystemUrisResponse_Extension *p;
	struct _tds__GetSystemUrisResponse_Extension *a = (struct _tds__GetSystemUrisResponse_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemUrisResponse_Extension));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemUrisResponse_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLogUris = NULL;
	soap_default_xsd__anyURI(soap, &a->SupportInfoUri);
	soap_default_xsd__anyURI(soap, &a->SystemBackupUri);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLogUriList(soap, &a->SystemLogUris);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SupportInfoUri);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->SystemLogUris, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SupportInfoUri", -1, (char*const*)&a->SupportInfoUri, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SystemBackupUri", -1, (char*const*)&a->SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse *a, const char *type)
{
	size_t soap_flag_SystemLogUris = 1;
	size_t soap_flag_SupportInfoUri = 1;
	size_t soap_flag_SystemBackupUri = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUrisResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris--;
					continue;
				}
			if (soap_flag_SupportInfoUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:SupportInfoUri", (char**)&a->SupportInfoUri, "xsd:anyURI"))
				{	soap_flag_SupportInfoUri--;
					continue;
				}
			if (soap_flag_SystemBackupUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:SystemBackupUri", (char**)&a->SystemBackupUri, "xsd:anyURI"))
				{	soap_flag_SystemBackupUri--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_new__tds__GetSystemUrisResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemUrisResponse *p;
	struct _tds__GetSystemUrisResponse *a = (struct _tds__GetSystemUrisResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemUrisResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemUrisResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemUrisResponse(soap, tag ? tag : "tds:GetSystemUrisResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, struct _tds__GetSystemUris *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUris *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUris(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_new__tds__GetSystemUris(struct soap *soap, int n)
{
	struct _tds__GetSystemUris *p;
	struct _tds__GetSystemUris *a = (struct _tds__GetSystemUris*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemUris));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemUris(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworks = 0;
	a->Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Networks)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworks; i++)
		{
			soap_embedded(soap, a->Networks + i, SOAP_TYPE_tt__Dot11AvailableNetworks);
			soap_serialize_tt__Dot11AvailableNetworks(soap, a->Networks + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworks");
	if (a->Networks)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworks; i++)
			if (soap_out_tt__Dot11AvailableNetworks(soap, "tds:Networks", -1, a->Networks + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Networks = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11NetworksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Networks", 1, NULL))
			{	if (a->Networks == NULL)
				{	if (soap_blist_Networks == NULL)
						soap_blist_Networks = soap_alloc_block(soap);
					a->Networks = (struct tt__Dot11AvailableNetworks *)soap_push_block_max(soap, soap_blist_Networks, sizeof(struct tt__Dot11AvailableNetworks));
					if (a->Networks == NULL)
						return NULL;
					soap_default_tt__Dot11AvailableNetworks(soap, a->Networks);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AvailableNetworks(soap, "tds:Networks", a->Networks, "tt:Dot11AvailableNetworks"))
				{	a->__sizeNetworks++;
					a->Networks = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Networks)
			soap_pop_block(soap, soap_blist_Networks);
		if (a->__sizeNetworks)
		{	a->Networks = (struct tt__Dot11AvailableNetworks *)soap_save_block(soap, soap_blist_Networks, NULL, 1);
		}
		else
		{	a->Networks = NULL;
			if (soap_blist_Networks)
				soap_end_block(soap, soap_blist_Networks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_new__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int n)
{
	struct _tds__ScanAvailableDot11NetworksResponse *p;
	struct _tds__ScanAvailableDot11NetworksResponse *a = (struct _tds__ScanAvailableDot11NetworksResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__ScanAvailableDot11NetworksResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__ScanAvailableDot11NetworksResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag ? tag : "tds:ScanAvailableDot11NetworksResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_nil(soap, "tds:InterfaceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11Networks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_new__tds__ScanAvailableDot11Networks(struct soap *soap, int n)
{
	struct _tds__ScanAvailableDot11Networks *p;
	struct _tds__ScanAvailableDot11Networks *a = (struct _tds__ScanAvailableDot11Networks*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__ScanAvailableDot11Networks));
	for (p = a; p && n--; p++)
		soap_default__tds__ScanAvailableDot11Networks(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Status(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (!a->Status)
	{	if (soap_element_nil(soap, "tds:Status"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, struct _tds__GetDot11StatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11StatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11StatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->Status, "tt:Dot11Status"))
				{	soap_flag_Status--;
					continue;
				}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_new__tds__GetDot11StatusResponse(struct soap *soap, int n)
{
	struct _tds__GetDot11StatusResponse *p;
	struct _tds__GetDot11StatusResponse *a = (struct _tds__GetDot11StatusResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11StatusResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11StatusResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11StatusResponse(soap, tag ? tag : "tds:GetDot11StatusResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_nil(soap, "tds:InterfaceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, struct _tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_new__tds__GetDot11Status(struct soap *soap, int n)
{
	struct _tds__GetDot11Status *p;
	struct _tds__GetDot11Status *a = (struct _tds__GetDot11Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11Status));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tds:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11CapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetDot11CapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetDot11CapabilitiesResponse *p;
	struct _tds__GetDot11CapabilitiesResponse *a = (struct _tds__GetDot11CapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11CapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11CapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag ? tag : "tds:GetDot11CapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct _tds__GetDot11Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_new__tds__GetDot11Capabilities(struct soap *soap, int n)
{
	struct _tds__GetDot11Capabilities *p;
	struct _tds__GetDot11Capabilities *a = (struct _tds__GetDot11Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDot11Capabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDot11Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryCommandResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, (char*const*)&a->AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommandResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", (char**)&a->AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse--;
					continue;
				}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_new__tds__SendAuxiliaryCommandResponse(struct soap *soap, int n)
{
	struct _tds__SendAuxiliaryCommandResponse *p;
	struct _tds__SendAuxiliaryCommandResponse *a = (struct _tds__SendAuxiliaryCommandResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SendAuxiliaryCommandResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SendAuxiliaryCommandResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag ? tag : "tds:SendAuxiliaryCommandResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, (char*const*)&a->AuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (!a->AuxiliaryCommand)
	{	if (soap_element_nil(soap, "tds:AuxiliaryCommand"))
			return soap->error;
	}
	else
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, (char*const*)&a->AuxiliaryCommand, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommand = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", (char**)&a->AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_new__tds__SendAuxiliaryCommand(struct soap *soap, int n)
{
	struct _tds__SendAuxiliaryCommand *p;
	struct _tds__SendAuxiliaryCommand *a = (struct _tds__SendAuxiliaryCommand*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SendAuxiliaryCommand));
	for (p = a; p && n--; p++)
		soap_default__tds__SendAuxiliaryCommand(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_new__tds__SetRelayOutputStateResponse(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputStateResponse *p;
	struct _tds__SetRelayOutputStateResponse *a = (struct _tds__SetRelayOutputStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputStateResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag ? tag : "tds:SetRelayOutputStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &a->LogicalState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RelayOutputToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (!a->RelayOutputToken)
	{	if (soap_element_nil(soap, "tds:RelayOutputToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, (char*const*)&a->RelayOutputToken, ""))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_LogicalState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", (char**)&a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			if (soap_flag_LogicalState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_LogicalState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_new__tds__SetRelayOutputState(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputState *p;
	struct _tds__SetRelayOutputState *a = (struct _tds__SetRelayOutputState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputState));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_new__tds__SetRelayOutputSettingsResponse(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputSettingsResponse *p;
	struct _tds__SetRelayOutputSettingsResponse *a = (struct _tds__SetRelayOutputSettingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputSettingsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputSettingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag ? tag : "tds:SetRelayOutputSettingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (!a->RelayOutputToken)
	{	if (soap_element_nil(soap, "tds:RelayOutputToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, (char*const*)&a->RelayOutputToken, ""))
		return soap->error;
	if (!a->Properties)
	{	if (soap_element_nil(soap, "tds:Properties"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", (char**)&a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_Properties > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_new__tds__SetRelayOutputSettings(struct soap *soap, int n)
{
	struct _tds__SetRelayOutputSettings *p;
	struct _tds__SetRelayOutputSettings *a = (struct _tds__SetRelayOutputSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRelayOutputSettings));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRelayOutputSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const struct tt__RelayOutput *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type))
		return soap->error;
	if (!a->Properties)
	{	if (soap_element_nil(soap, "tt:Properties"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput *a, const char *type)
{
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelayOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Properties > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_new_tt__RelayOutput(struct soap *soap, int n)
{
	struct tt__RelayOutput *p;
	struct tt__RelayOutput *a = (struct tt__RelayOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelayOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRelayOutputs = 0;
	a->RelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelayOutputs; i++)
		{
			soap_embedded(soap, a->RelayOutputs + i, SOAP_TYPE_tt__RelayOutput);
			soap_serialize_tt__RelayOutput(soap, a->RelayOutputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRelayOutputs");
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelayOutputs; i++)
			if (soap_out_tt__RelayOutput(soap, "tds:RelayOutputs", -1, a->RelayOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RelayOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRelayOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
			{	if (a->RelayOutputs == NULL)
				{	if (soap_blist_RelayOutputs == NULL)
						soap_blist_RelayOutputs = soap_alloc_block(soap);
					a->RelayOutputs = (struct tt__RelayOutput *)soap_push_block_max(soap, soap_blist_RelayOutputs, sizeof(struct tt__RelayOutput));
					if (a->RelayOutputs == NULL)
						return NULL;
					soap_default_tt__RelayOutput(soap, a->RelayOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__RelayOutput(soap, "tds:RelayOutputs", a->RelayOutputs, "tt:RelayOutput"))
				{	a->__sizeRelayOutputs++;
					a->RelayOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RelayOutputs)
			soap_pop_block(soap, soap_blist_RelayOutputs);
		if (a->__sizeRelayOutputs)
		{	a->RelayOutputs = (struct tt__RelayOutput *)soap_save_block(soap, soap_blist_RelayOutputs, NULL, 1);
		}
		else
		{	a->RelayOutputs = NULL;
			if (soap_blist_RelayOutputs)
				soap_end_block(soap, soap_blist_RelayOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_new__tds__GetRelayOutputsResponse(struct soap *soap, int n)
{
	struct _tds__GetRelayOutputsResponse *p;
	struct _tds__GetRelayOutputsResponse *a = (struct _tds__GetRelayOutputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRelayOutputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRelayOutputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag ? tag : "tds:GetRelayOutputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRelayOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_new__tds__GetRelayOutputs(struct soap *soap, int n)
{
	struct _tds__GetRelayOutputs *p;
	struct _tds__GetRelayOutputs *a = (struct _tds__GetRelayOutputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRelayOutputs));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRelayOutputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_new__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int n)
{
	struct _tds__DeleteDot1XConfigurationResponse *p;
	struct _tds__DeleteDot1XConfigurationResponse *a = (struct _tds__DeleteDot1XConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteDot1XConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteDot1XConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag ? tag : "tds:DeleteDot1XConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfigurationToken = 0;
	a->Dot1XConfigurationToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot1XConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Dot1XConfigurationToken + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot1XConfigurationToken; i++)
			soap_out_string(soap, "tds:Dot1XConfigurationToken", -1, (char*const*)(a->Dot1XConfigurationToken + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfigurationToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfigurationToken", 1, NULL))
			{	if (a->Dot1XConfigurationToken == NULL)
				{	if (soap_blist_Dot1XConfigurationToken == NULL)
						soap_blist_Dot1XConfigurationToken = soap_alloc_block(soap);
					a->Dot1XConfigurationToken = (char **)soap_push_block_max(soap, soap_blist_Dot1XConfigurationToken, sizeof(char *));
					if (a->Dot1XConfigurationToken == NULL)
						return NULL;
					*a->Dot1XConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", (char**)a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	a->__sizeDot1XConfigurationToken++;
					a->Dot1XConfigurationToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfigurationToken)
			soap_pop_block(soap, soap_blist_Dot1XConfigurationToken);
		if (a->__sizeDot1XConfigurationToken)
		{	a->Dot1XConfigurationToken = (char **)soap_save_block(soap, soap_blist_Dot1XConfigurationToken, NULL, 1);
		}
		else
		{	a->Dot1XConfigurationToken = NULL;
			if (soap_blist_Dot1XConfigurationToken)
				soap_end_block(soap, soap_blist_Dot1XConfigurationToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_new__tds__DeleteDot1XConfiguration(struct soap *soap, int n)
{
	struct _tds__DeleteDot1XConfiguration *p;
	struct _tds__DeleteDot1XConfiguration *a = (struct _tds__DeleteDot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteDot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteDot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
