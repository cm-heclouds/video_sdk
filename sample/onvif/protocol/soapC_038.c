/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IANA_IfTypes(soap, &a->InterfaceType);
	a->__sizeDot3 = 0;
	a->Dot3 = NULL;
	a->__sizeDot11 = 0;
	a->Dot11 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceExtension(struct soap *soap, const struct tt__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Dot3)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot3; i++)
		{
			soap_embedded(soap, a->Dot3 + i, SOAP_TYPE_tt__Dot3Configuration);
			soap_serialize_tt__Dot3Configuration(soap, a->Dot3 + i);
		}
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot11; i++)
		{
			soap_embedded(soap, a->Dot11 + i, SOAP_TYPE_tt__Dot11Configuration);
			soap_serialize_tt__Dot11Configuration(soap, a->Dot11 + i);
		}
	}
	soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	if (a->Dot3)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot3; i++)
			if (soap_out_tt__Dot3Configuration(soap, "tt:Dot3", -1, a->Dot3 + i, ""))
				return soap->error;
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < (int)a->__sizeDot11; i++)
			if (soap_out_tt__Dot11Configuration(soap, "tt:Dot11", -1, a->Dot11 + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension *a, const char *type)
{
	size_t soap_flag_InterfaceType = 1;
	struct soap_blist *soap_blist_Dot3 = NULL;
	struct soap_blist *soap_blist_Dot11 = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
			{	if (a->Dot3 == NULL)
				{	if (soap_blist_Dot3 == NULL)
						soap_blist_Dot3 = soap_alloc_block(soap);
					a->Dot3 = (struct tt__Dot3Configuration *)soap_push_block_max(soap, soap_blist_Dot3, sizeof(struct tt__Dot3Configuration));
					if (a->Dot3 == NULL)
						return NULL;
					soap_default_tt__Dot3Configuration(soap, a->Dot3);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot3Configuration(soap, "tt:Dot3", a->Dot3, "tt:Dot3Configuration"))
				{	a->__sizeDot3++;
					a->Dot3 = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
			{	if (a->Dot11 == NULL)
				{	if (soap_blist_Dot11 == NULL)
						soap_blist_Dot11 = soap_alloc_block(soap);
					a->Dot11 = (struct tt__Dot11Configuration *)soap_push_block_max(soap, soap_blist_Dot11, sizeof(struct tt__Dot11Configuration));
					if (a->Dot11 == NULL)
						return NULL;
					soap_default_tt__Dot11Configuration(soap, a->Dot11);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Configuration(soap, "tt:Dot11", a->Dot11, "tt:Dot11Configuration"))
				{	a->__sizeDot11++;
					a->Dot11 = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot3)
			soap_pop_block(soap, soap_blist_Dot3);
		if (a->__sizeDot3)
		{	a->Dot3 = (struct tt__Dot3Configuration *)soap_save_block(soap, soap_blist_Dot3, NULL, 1);
		}
		else
		{	a->Dot3 = NULL;
			if (soap_blist_Dot3)
				soap_end_block(soap, soap_blist_Dot3);
		}
		if (a->Dot11)
			soap_pop_block(soap, soap_blist_Dot11);
		if (a->__sizeDot11)
		{	a->Dot11 = (struct tt__Dot11Configuration *)soap_save_block(soap, soap_blist_Dot11, NULL, 1);
		}
		else
		{	a->Dot11 = NULL;
			if (soap_blist_Dot11)
				soap_end_block(soap, soap_blist_Dot11);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceType > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_new_tt__NetworkInterfaceExtension(struct soap *soap, int n)
{
	struct tt__NetworkInterfaceExtension *p;
	struct tt__NetworkInterfaceExtension *a = (struct tt__NetworkInterfaceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterfaceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterfaceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceExtension(struct soap *soap, const struct tt__NetworkInterfaceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Scope(struct soap *soap, struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ScopeDefinition(soap, &a->ScopeDef);
	soap_default_xsd__anyURI(soap, &a->ScopeItem);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Scope(struct soap *soap, const struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ScopeItem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const struct tt__Scope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->ScopeDef, ""))
		return soap->error;
	if (!a->ScopeItem)
	{	if (soap_element_nil(soap, "tt:ScopeItem"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, (char*const*)&a->ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, struct tt__Scope *a, const char *type)
{
	size_t soap_flag_ScopeDef = 1;
	size_t soap_flag_ScopeItem = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Scope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Scope(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef--;
					continue;
				}
			if (soap_flag_ScopeItem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", (char**)&a->ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef > 0 || soap_flag_ScopeItem > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_new_tt__Scope(struct soap *soap, int n)
{
	struct tt__Scope *p;
	struct tt__Scope *a = (struct tt__Scope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Scope));
	for (p = a; p && n--; p++)
		soap_default_tt__Scope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Scope(struct soap *soap, const struct tt__Scope *a, const char *tag, const char *type)
{
	if (soap_out_tt__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, struct tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaUri(struct soap *soap, struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
	soap_default_xsd__boolean(soap, &a->InvalidAfterConnect);
	soap_default_xsd__boolean(soap, &a->InvalidAfterReboot);
	soap_default_xsd__duration(soap, &a->Timeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
	soap_embedded(soap, &a->InvalidAfterConnect, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->InvalidAfterReboot, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->Timeout, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const struct tt__MediaUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type))
		return soap->error;
	if (!a->Uri)
	{	if (soap_element_nil(soap, "tt:Uri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:InvalidAfterConnect", -1, &a->InvalidAfterConnect, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:InvalidAfterReboot", -1, &a->InvalidAfterReboot, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	size_t soap_flag_InvalidAfterConnect = 1;
	size_t soap_flag_InvalidAfterReboot = 1;
	size_t soap_flag_Timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			if (soap_flag_InvalidAfterConnect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:InvalidAfterConnect", &a->InvalidAfterConnect, "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect--;
					continue;
				}
			if (soap_flag_InvalidAfterReboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:InvalidAfterReboot", &a->InvalidAfterReboot, "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot--;
					continue;
				}
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0 || soap_flag_InvalidAfterConnect > 0 || soap_flag_InvalidAfterReboot > 0 || soap_flag_Timeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_new_tt__MediaUri(struct soap *soap, int n)
{
	struct tt__MediaUri *p;
	struct tt__MediaUri *a = (struct tt__MediaUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaUri));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, struct tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Transport(struct soap *soap, struct tt__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TransportProtocol(soap, &a->Protocol);
	a->Tunnel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Transport(struct soap *soap, const struct tt__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transport(soap, &a->Tunnel);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transport(struct soap *soap, const char *tag, int id, const struct tt__Transport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transport), type))
		return soap->error;
	if (soap_out_tt__TransportProtocol(soap, "tt:Protocol", -1, &a->Protocol, ""))
		return soap->error;
	if (soap_out_PointerTott__Transport(soap, "tt:Tunnel", -1, &a->Tunnel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_in_tt__Transport(struct soap *soap, const char *tag, struct tt__Transport *a, const char *type)
{
	size_t soap_flag_Protocol = 1;
	size_t soap_flag_Tunnel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Transport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Transport(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TransportProtocol(soap, "tt:Protocol", &a->Protocol, "tt:TransportProtocol"))
				{	soap_flag_Protocol--;
					continue;
				}
			if (soap_flag_Tunnel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transport(soap, "tt:Tunnel", &a->Tunnel, "tt:Transport"))
				{	soap_flag_Tunnel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_new_tt__Transport(struct soap *soap, int n)
{
	struct tt__Transport *p;
	struct tt__Transport *a = (struct tt__Transport*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Transport));
	for (p = a; p && n--; p++)
		soap_default_tt__Transport(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Transport(struct soap *soap, const struct tt__Transport *a, const char *tag, const char *type)
{
	if (soap_out_tt__Transport(soap, tag ? tag : "tt:Transport", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_get_tt__Transport(struct soap *soap, struct tt__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StreamSetup(struct soap *soap, struct tt__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__StreamType(soap, &a->Stream);
	a->Transport = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StreamSetup(struct soap *soap, const struct tt__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transport(soap, &a->Transport);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamSetup(struct soap *soap, const char *tag, int id, const struct tt__StreamSetup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamSetup), type))
		return soap->error;
	if (soap_out_tt__StreamType(soap, "tt:Stream", -1, &a->Stream, ""))
		return soap->error;
	if (!a->Transport)
	{	if (soap_element_nil(soap, "tt:Transport"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Transport(soap, "tt:Transport", -1, &a->Transport, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_in_tt__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup *a, const char *type)
{
	size_t soap_flag_Stream = 1;
	size_t soap_flag_Transport = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__StreamSetup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__StreamSetup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__StreamType(soap, "tt:Stream", &a->Stream, "tt:StreamType"))
				{	soap_flag_Stream--;
					continue;
				}
			if (soap_flag_Transport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transport(soap, "tt:Transport", &a->Transport, "tt:Transport"))
				{	soap_flag_Transport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream > 0 || soap_flag_Transport > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_new_tt__StreamSetup(struct soap *soap, int n)
{
	struct tt__StreamSetup *p;
	struct tt__StreamSetup *a = (struct tt__StreamSetup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__StreamSetup));
	for (p = a; p && n--; p++)
		soap_default_tt__StreamSetup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamSetup(struct soap *soap, const struct tt__StreamSetup *a, const char *tag, const char *type)
{
	if (soap_out_tt__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_get_tt__StreamSetup(struct soap *soap, struct tt__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddress(struct soap *soap, struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &a->Type);
	soap_default_tt__IPv4Address(soap, &a->IPv4Address);
	soap_default_tt__IPv6Address(soap, &a->IPv6Address);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__IPv4Address(soap, (char*const*)&a->IPv4Address);
	soap_serialize_tt__IPv6Address(soap, (char*const*)&a->IPv6Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const struct tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, (char*const*)&a->IPv4Address, ""))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, (char*const*)&a->IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPType(soap, "tt:Type", &a->Type, "tt:IPType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", (char**)&a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", (char**)&a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_new_tt__IPAddress(struct soap *soap, int n)
{
	struct tt__IPAddress *p;
	struct tt__IPAddress *a = (struct tt__IPAddress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IPAddress));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, struct tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	soap_default_int(soap, &a->Port);
	soap_default_int(soap, &a->TTL);
	soap_default_xsd__boolean(soap, &a->AutoStart);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddress(soap, &a->Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
	soap_embedded(soap, &a->TTL, SOAP_TYPE_int);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MulticastConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_nil(soap, "tt:Address"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &a->Port, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_Port = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_AutoStart = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MulticastConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MulticastConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->Address, "tt:IPAddress"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Port", &a->Port, "xsd:int"))
				{	soap_flag_Port--;
					continue;
				}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:TTL", &a->TTL, "xsd:int"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_Port > 0 || soap_flag_TTL > 0 || soap_flag_AutoStart > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_new_tt__MulticastConfiguration(struct soap *soap, int n)
{
	struct tt__MulticastConfiguration *p;
	struct tt__MulticastConfiguration *a = (struct tt__MulticastConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MulticastConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__MulticastConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__AudioDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDecoderConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDecoderConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_new_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, int n)
{
	struct tt__AudioDecoderConfigurationOptionsExtension *p;
	struct tt__AudioDecoderConfigurationOptionsExtension *a = (struct tt__AudioDecoderConfigurationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioDecoderConfigurationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioDecoderConfigurationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__AudioDecoderConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:AudioDecoderConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	a->SampleRateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__G726DecOptions(struct soap *soap, const struct tt__G726DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &a->Bitrate);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G726DecOptions(struct soap *soap, const char *tag, int id, const struct tt__G726DecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G726DecOptions), type))
		return soap->error;
	if (!a->Bitrate)
	{	if (soap_element_nil(soap, "tt:Bitrate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (!a->SampleRateRange)
	{	if (soap_element_nil(soap, "tt:SampleRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->SampleRateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__G726DecOptions * SOAP_FMAC4 soap_in_tt__G726DecOptions(struct soap *soap, const char *tag, struct tt__G726DecOptions *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__G726DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__G726DecOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bitrate > 0 || soap_flag_SampleRateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__G726DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G726DecOptions, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__G726DecOptions * SOAP_FMAC4 soap_new_tt__G726DecOptions(struct soap *soap, int n)
{
	struct tt__G726DecOptions *p;
	struct tt__G726DecOptions *a = (struct tt__G726DecOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__G726DecOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__G726DecOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__G726DecOptions(struct soap *soap, const struct tt__G726DecOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__G726DecOptions(soap, tag ? tag : "tt:G726DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G726DecOptions * SOAP_FMAC4 soap_get_tt__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	a->SampleRateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__G711DecOptions(struct soap *soap, const struct tt__G711DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &a->Bitrate);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G711DecOptions(struct soap *soap, const char *tag, int id, const struct tt__G711DecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G711DecOptions), type))
		return soap->error;
	if (!a->Bitrate)
	{	if (soap_element_nil(soap, "tt:Bitrate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (!a->SampleRateRange)
	{	if (soap_element_nil(soap, "tt:SampleRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->SampleRateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__G711DecOptions * SOAP_FMAC4 soap_in_tt__G711DecOptions(struct soap *soap, const char *tag, struct tt__G711DecOptions *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__G711DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__G711DecOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bitrate > 0 || soap_flag_SampleRateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__G711DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G711DecOptions, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__G711DecOptions * SOAP_FMAC4 soap_new_tt__G711DecOptions(struct soap *soap, int n)
{
	struct tt__G711DecOptions *p;
	struct tt__G711DecOptions *a = (struct tt__G711DecOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__G711DecOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__G711DecOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__G711DecOptions(struct soap *soap, const struct tt__G711DecOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__G711DecOptions(soap, tag ? tag : "tt:G711DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G711DecOptions * SOAP_FMAC4 soap_get_tt__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	a->SampleRateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AACDecOptions(struct soap *soap, const struct tt__AACDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &a->Bitrate);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AACDecOptions(struct soap *soap, const char *tag, int id, const struct tt__AACDecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AACDecOptions), type))
		return soap->error;
	if (!a->Bitrate)
	{	if (soap_element_nil(soap, "tt:Bitrate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (!a->SampleRateRange)
	{	if (soap_element_nil(soap, "tt:SampleRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->SampleRateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AACDecOptions * SOAP_FMAC4 soap_in_tt__AACDecOptions(struct soap *soap, const char *tag, struct tt__AACDecOptions *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AACDecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AACDecOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bitrate > 0 || soap_flag_SampleRateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AACDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AACDecOptions, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AACDecOptions * SOAP_FMAC4 soap_new_tt__AACDecOptions(struct soap *soap, int n)
{
	struct tt__AACDecOptions *p;
	struct tt__AACDecOptions *a = (struct tt__AACDecOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AACDecOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AACDecOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AACDecOptions(struct soap *soap, const struct tt__AACDecOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AACDecOptions(soap, tag ? tag : "tt:AACDecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AACDecOptions * SOAP_FMAC4 soap_get_tt__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AACDecOptions = NULL;
	a->G711DecOptions = NULL;
	a->G726DecOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfigurationOptions(struct soap *soap, const struct tt__AudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AACDecOptions(soap, &a->AACDecOptions);
	soap_serialize_PointerTott__G711DecOptions(soap, &a->G711DecOptions);
	soap_serialize_PointerTott__G726DecOptions(soap, &a->G726DecOptions);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", -1, &a->AACDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", -1, &a->G711DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", -1, &a->G726DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_AACDecOptions = 1;
	size_t soap_flag_G711DecOptions = 1;
	size_t soap_flag_G726DecOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDecoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AACDecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", &a->AACDecOptions, "tt:AACDecOptions"))
				{	soap_flag_AACDecOptions--;
					continue;
				}
			if (soap_flag_G711DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", &a->G711DecOptions, "tt:G711DecOptions"))
				{	soap_flag_G711DecOptions--;
					continue;
				}
			if (soap_flag_G726DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", &a->G726DecOptions, "tt:G726DecOptions"))
				{	soap_flag_G726DecOptions--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:AudioDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioDecoderConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioDecoderConfigurationOptions *p;
	struct tt__AudioDecoderConfigurationOptions *a = (struct tt__AudioDecoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioDecoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioDecoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfigurationOptions(struct soap *soap, const struct tt__AudioDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOutputTokensAvailable = 0;
	a->OutputTokensAvailable = NULL;
	a->__sizeSendPrimacyOptions = 0;
	a->SendPrimacyOptions = NULL;
	a->OutputLevelRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfigurationOptions(struct soap *soap, const struct tt__AudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->OutputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeOutputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->OutputTokensAvailable + i));
		}
	}
	if (a->SendPrimacyOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSendPrimacyOptions; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->SendPrimacyOptions + i));
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->OutputLevelRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions), type))
		return soap->error;
	if (a->OutputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeOutputTokensAvailable; i++)
			soap_out_string(soap, "tt:OutputTokensAvailable", -1, (char*const*)(a->OutputTokensAvailable + i), "");
	}
	if (a->SendPrimacyOptions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSendPrimacyOptions; i++)
			soap_out_string(soap, "tt:SendPrimacyOptions", -1, (char*const*)(a->SendPrimacyOptions + i), "");
	}
	if (!a->OutputLevelRange)
	{	if (soap_element_nil(soap, "tt:OutputLevelRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:OutputLevelRange", -1, &a->OutputLevelRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_OutputTokensAvailable = NULL;
	struct soap_blist *soap_blist_SendPrimacyOptions = NULL;
	size_t soap_flag_OutputLevelRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutputConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:OutputTokensAvailable", 1, NULL))
			{	if (a->OutputTokensAvailable == NULL)
				{	if (soap_blist_OutputTokensAvailable == NULL)
						soap_blist_OutputTokensAvailable = soap_alloc_block(soap);
					a->OutputTokensAvailable = (char **)soap_push_block_max(soap, soap_blist_OutputTokensAvailable, sizeof(char *));
					if (a->OutputTokensAvailable == NULL)
						return NULL;
					*a->OutputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:OutputTokensAvailable", (char**)a->OutputTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeOutputTokensAvailable++;
					a->OutputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SendPrimacyOptions", 1, NULL))
			{	if (a->SendPrimacyOptions == NULL)
				{	if (soap_blist_SendPrimacyOptions == NULL)
						soap_blist_SendPrimacyOptions = soap_alloc_block(soap);
					a->SendPrimacyOptions = (char **)soap_push_block_max(soap, soap_blist_SendPrimacyOptions, sizeof(char *));
					if (a->SendPrimacyOptions == NULL)
						return NULL;
					*a->SendPrimacyOptions = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:SendPrimacyOptions", (char**)a->SendPrimacyOptions, "xsd:anyURI"))
				{	a->__sizeSendPrimacyOptions++;
					a->SendPrimacyOptions = NULL;
					continue;
				}
			}
			if (soap_flag_OutputLevelRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:OutputLevelRange", &a->OutputLevelRange, "tt:IntRange"))
				{	soap_flag_OutputLevelRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OutputTokensAvailable)
			soap_pop_block(soap, soap_blist_OutputTokensAvailable);
		if (a->__sizeOutputTokensAvailable)
		{	a->OutputTokensAvailable = (char **)soap_save_block(soap, soap_blist_OutputTokensAvailable, NULL, 1);
		}
		else
		{	a->OutputTokensAvailable = NULL;
			if (soap_blist_OutputTokensAvailable)
				soap_end_block(soap, soap_blist_OutputTokensAvailable);
		}
		if (a->SendPrimacyOptions)
			soap_pop_block(soap, soap_blist_SendPrimacyOptions);
		if (a->__sizeSendPrimacyOptions)
		{	a->SendPrimacyOptions = (char **)soap_save_block(soap, soap_blist_SendPrimacyOptions, NULL, 1);
		}
		else
		{	a->SendPrimacyOptions = NULL;
			if (soap_blist_SendPrimacyOptions)
				soap_end_block(soap, soap_blist_SendPrimacyOptions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOutputTokensAvailable < 1 || soap_flag_OutputLevelRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfigurationOptions, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioOutputConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioOutputConfigurationOptions *p;
	struct tt__AudioOutputConfigurationOptions *a = (struct tt__AudioOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfigurationOptions(struct soap *soap, const struct tt__AudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoDecoderConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoDecoderConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_new_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, int n)
{
	struct tt__VideoDecoderConfigurationOptionsExtension *p;
	struct tt__VideoDecoderConfigurationOptionsExtension *a = (struct tt__VideoDecoderConfigurationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoDecoderConfigurationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoDecoderConfigurationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoDecoderConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoDecoderConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->__sizeSupportedMpeg4Profiles = 0;
	a->SupportedMpeg4Profiles = NULL;
	a->SupportedInputBitrate = NULL;
	a->SupportedFrameRate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4DecOptions(struct soap *soap, const struct tt__Mpeg4DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	if (a->SupportedMpeg4Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedMpeg4Profiles; i++)
		{
			soap_embedded(soap, a->SupportedMpeg4Profiles + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedFrameRate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4DecOptions(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4DecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4DecOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->SupportedMpeg4Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedMpeg4Profiles; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:SupportedMpeg4Profiles", -1, a->SupportedMpeg4Profiles + i, ""))
				return soap->error;
	}
	if (!a->SupportedInputBitrate)
	{	if (soap_element_nil(soap, "tt:SupportedInputBitrate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->SupportedInputBitrate, ""))
		return soap->error;
	if (!a->SupportedFrameRate)
	{	if (soap_element_nil(soap, "tt:SupportedFrameRate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->SupportedFrameRate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions * SOAP_FMAC4 soap_in_tt__Mpeg4DecOptions(struct soap *soap, const char *tag, struct tt__Mpeg4DecOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	struct soap_blist *soap_blist_SupportedMpeg4Profiles = NULL;
	size_t soap_flag_SupportedInputBitrate = 1;
	size_t soap_flag_SupportedFrameRate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4DecOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedMpeg4Profiles", 1, NULL))
			{	if (a->SupportedMpeg4Profiles == NULL)
				{	if (soap_blist_SupportedMpeg4Profiles == NULL)
						soap_blist_SupportedMpeg4Profiles = soap_alloc_block(soap);
					a->SupportedMpeg4Profiles = (enum tt__Mpeg4Profile *)soap_push_block_max(soap, soap_blist_SupportedMpeg4Profiles, sizeof(enum tt__Mpeg4Profile));
					if (a->SupportedMpeg4Profiles == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->SupportedMpeg4Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:SupportedMpeg4Profiles", a->SupportedMpeg4Profiles, "tt:Mpeg4Profile"))
				{	a->__sizeSupportedMpeg4Profiles++;
					a->SupportedMpeg4Profiles = NULL;
					continue;
				}
			}
			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate--;
					continue;
				}
			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->SupportedMpeg4Profiles)
			soap_pop_block(soap, soap_blist_SupportedMpeg4Profiles);
		if (a->__sizeSupportedMpeg4Profiles)
		{	a->SupportedMpeg4Profiles = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_SupportedMpeg4Profiles, NULL, 1);
		}
		else
		{	a->SupportedMpeg4Profiles = NULL;
			if (soap_blist_SupportedMpeg4Profiles)
				soap_end_block(soap, soap_blist_SupportedMpeg4Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || a->__sizeSupportedMpeg4Profiles < 1 || soap_flag_SupportedInputBitrate > 0 || soap_flag_SupportedFrameRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4DecOptions, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions * SOAP_FMAC4 soap_new_tt__Mpeg4DecOptions(struct soap *soap, int n)
{
	struct tt__Mpeg4DecOptions *p;
	struct tt__Mpeg4DecOptions *a = (struct tt__Mpeg4DecOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4DecOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4DecOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4DecOptions(struct soap *soap, const struct tt__Mpeg4DecOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4DecOptions(soap, tag ? tag : "tt:Mpeg4DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions * SOAP_FMAC4 soap_get_tt__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->__sizeSupportedH264Profiles = 0;
	a->SupportedH264Profiles = NULL;
	a->SupportedInputBitrate = NULL;
	a->SupportedFrameRate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264DecOptions(struct soap *soap, const struct tt__H264DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	if (a->SupportedH264Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedH264Profiles; i++)
		{
			soap_embedded(soap, a->SupportedH264Profiles + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedFrameRate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264DecOptions(struct soap *soap, const char *tag, int id, const struct tt__H264DecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264DecOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->SupportedH264Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedH264Profiles; i++)
			if (soap_out_tt__H264Profile(soap, "tt:SupportedH264Profiles", -1, a->SupportedH264Profiles + i, ""))
				return soap->error;
	}
	if (!a->SupportedInputBitrate)
	{	if (soap_element_nil(soap, "tt:SupportedInputBitrate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->SupportedInputBitrate, ""))
		return soap->error;
	if (!a->SupportedFrameRate)
	{	if (soap_element_nil(soap, "tt:SupportedFrameRate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->SupportedFrameRate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264DecOptions * SOAP_FMAC4 soap_in_tt__H264DecOptions(struct soap *soap, const char *tag, struct tt__H264DecOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	struct soap_blist *soap_blist_SupportedH264Profiles = NULL;
	size_t soap_flag_SupportedInputBitrate = 1;
	size_t soap_flag_SupportedFrameRate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264DecOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedH264Profiles", 1, NULL))
			{	if (a->SupportedH264Profiles == NULL)
				{	if (soap_blist_SupportedH264Profiles == NULL)
						soap_blist_SupportedH264Profiles = soap_alloc_block(soap);
					a->SupportedH264Profiles = (enum tt__H264Profile *)soap_push_block_max(soap, soap_blist_SupportedH264Profiles, sizeof(enum tt__H264Profile));
					if (a->SupportedH264Profiles == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->SupportedH264Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:SupportedH264Profiles", a->SupportedH264Profiles, "tt:H264Profile"))
				{	a->__sizeSupportedH264Profiles++;
					a->SupportedH264Profiles = NULL;
					continue;
				}
			}
			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate--;
					continue;
				}
			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->SupportedH264Profiles)
			soap_pop_block(soap, soap_blist_SupportedH264Profiles);
		if (a->__sizeSupportedH264Profiles)
		{	a->SupportedH264Profiles = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_SupportedH264Profiles, NULL, 1);
		}
		else
		{	a->SupportedH264Profiles = NULL;
			if (soap_blist_SupportedH264Profiles)
				soap_end_block(soap, soap_blist_SupportedH264Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || a->__sizeSupportedH264Profiles < 1 || soap_flag_SupportedInputBitrate > 0 || soap_flag_SupportedFrameRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264DecOptions, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264DecOptions * SOAP_FMAC4 soap_new_tt__H264DecOptions(struct soap *soap, int n)
{
	struct tt__H264DecOptions *p;
	struct tt__H264DecOptions *a = (struct tt__H264DecOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264DecOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__H264DecOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264DecOptions(struct soap *soap, const struct tt__H264DecOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264DecOptions(soap, tag ? tag : "tt:H264DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264DecOptions * SOAP_FMAC4 soap_get_tt__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->SupportedInputBitrate = NULL;
	a->SupportedFrameRate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegDecOptions(struct soap *soap, const struct tt__JpegDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedFrameRate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegDecOptions(struct soap *soap, const char *tag, int id, const struct tt__JpegDecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegDecOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->SupportedInputBitrate)
	{	if (soap_element_nil(soap, "tt:SupportedInputBitrate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->SupportedInputBitrate, ""))
		return soap->error;
	if (!a->SupportedFrameRate)
	{	if (soap_element_nil(soap, "tt:SupportedFrameRate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->SupportedFrameRate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegDecOptions * SOAP_FMAC4 soap_in_tt__JpegDecOptions(struct soap *soap, const char *tag, struct tt__JpegDecOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_SupportedInputBitrate = 1;
	size_t soap_flag_SupportedFrameRate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__JpegDecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegDecOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate--;
					continue;
				}
			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_SupportedInputBitrate > 0 || soap_flag_SupportedFrameRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__JpegDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegDecOptions, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__JpegDecOptions * SOAP_FMAC4 soap_new_tt__JpegDecOptions(struct soap *soap, int n)
{
	struct tt__JpegDecOptions *p;
	struct tt__JpegDecOptions *a = (struct tt__JpegDecOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__JpegDecOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__JpegDecOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegDecOptions(struct soap *soap, const struct tt__JpegDecOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__JpegDecOptions(soap, tag ? tag : "tt:JpegDecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegDecOptions * SOAP_FMAC4 soap_get_tt__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JpegDecOptions = NULL;
	a->H264DecOptions = NULL;
	a->Mpeg4DecOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoDecoderConfigurationOptions(struct soap *soap, const struct tt__VideoDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__JpegDecOptions(soap, &a->JpegDecOptions);
	soap_serialize_PointerTott__H264DecOptions(soap, &a->H264DecOptions);
	soap_serialize_PointerTott__Mpeg4DecOptions(soap, &a->Mpeg4DecOptions);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_PointerTott__JpegDecOptions(soap, "tt:JpegDecOptions", -1, &a->JpegDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__H264DecOptions(soap, "tt:H264DecOptions", -1, &a->H264DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4DecOptions(soap, "tt:Mpeg4DecOptions", -1, &a->Mpeg4DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_JpegDecOptions = 1;
	size_t soap_flag_H264DecOptions = 1;
	size_t soap_flag_Mpeg4DecOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoDecoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JpegDecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegDecOptions(soap, "tt:JpegDecOptions", &a->JpegDecOptions, "tt:JpegDecOptions"))
				{	soap_flag_JpegDecOptions--;
					continue;
				}
			if (soap_flag_H264DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264DecOptions(soap, "tt:H264DecOptions", &a->H264DecOptions, "tt:H264DecOptions"))
				{	soap_flag_H264DecOptions--;
					continue;
				}
			if (soap_flag_Mpeg4DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4DecOptions(soap, "tt:Mpeg4DecOptions", &a->Mpeg4DecOptions, "tt:Mpeg4DecOptions"))
				{	soap_flag_Mpeg4DecOptions--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoDecoderConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoDecoderConfigurationOptions *p;
	struct tt__VideoDecoderConfigurationOptions *a = (struct tt__VideoDecoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoDecoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoDecoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoDecoderConfigurationOptions(struct soap *soap, const struct tt__VideoDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoDecoderConfigurationOptions(soap, tag ? tag : "tt:VideoDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputConfigurationOptions(struct soap *soap, const struct tt__VideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoOutputConfigurationOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfigurationOptions, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoOutputConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoOutputConfigurationOptions *p;
	struct tt__VideoOutputConfigurationOptions *a = (struct tt__VideoOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputConfigurationOptions(struct soap *soap, const struct tt__VideoOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutputConfigurationOptions(soap, tag ? tag : "tt:VideoOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputExtension(struct soap *soap, const struct tt__VideoOutputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputExtension * SOAP_FMAC4 soap_in_tt__VideoOutputExtension(struct soap *soap, const char *tag, struct tt__VideoOutputExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoOutputExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputExtension, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutputExtension * SOAP_FMAC4 soap_new_tt__VideoOutputExtension(struct soap *soap, int n)
{
	struct tt__VideoOutputExtension *p;
	struct tt__VideoOutputExtension *a = (struct tt__VideoOutputExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutputExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutputExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputExtension(struct soap *soap, const struct tt__VideoOutputExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutputExtension(soap, tag ? tag : "tt:VideoOutputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputExtension * SOAP_FMAC4 soap_get_tt__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const struct tt__PTZStatusFilterOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStatusFilterOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatusFilterOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_new_tt__PTZStatusFilterOptionsExtension(struct soap *soap, int n)
{
	struct tt__PTZStatusFilterOptionsExtension *p;
	struct tt__PTZStatusFilterOptionsExtension *a = (struct tt__PTZStatusFilterOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStatusFilterOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStatusFilterOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const struct tt__PTZStatusFilterOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag ? tag : "tt:PTZStatusFilterOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const struct tt__MetadataConfigurationOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfigurationOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfigurationOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(struct tt__MetadataConfigurationOptionsExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfigurationOptionsExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(struct tt__MetadataConfigurationOptionsExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_new_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, int n)
{
	struct tt__MetadataConfigurationOptionsExtension2 *p;
	struct tt__MetadataConfigurationOptionsExtension2 *a = (struct tt__MetadataConfigurationOptionsExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataConfigurationOptionsExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataConfigurationOptionsExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const struct tt__MetadataConfigurationOptionsExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataConfigurationOptionsExtension2(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfigurationOptionsExtension(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCompressionType = 0;
	a->CompressionType = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const struct tt__MetadataConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->CompressionType)
	{	int i;
		for (i = 0; i < (int)a->__sizeCompressionType; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->CompressionType + i));
		}
	}
	soap_serialize_PointerTott__MetadataConfigurationOptionsExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension), type))
		return soap->error;
	if (a->CompressionType)
	{	int i;
		for (i = 0; i < (int)a->__sizeCompressionType; i++)
			soap_out_string(soap, "tt:CompressionType", -1, (char*const*)(a->CompressionType + i), "");
	}
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist_CompressionType = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(struct tt__MetadataConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:CompressionType", 1, NULL))
			{	if (a->CompressionType == NULL)
				{	if (soap_blist_CompressionType == NULL)
						soap_blist_CompressionType = soap_alloc_block(soap);
					a->CompressionType = (char **)soap_push_block_max(soap, soap_blist_CompressionType, sizeof(char *));
					if (a->CompressionType == NULL)
						return NULL;
					*a->CompressionType = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:CompressionType", (char**)a->CompressionType, "xsd:string"))
				{	a->__sizeCompressionType++;
					a->CompressionType = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfigurationOptionsExtension2(soap, "tt:Extension", &a->Extension, "tt:MetadataConfigurationOptionsExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CompressionType)
			soap_pop_block(soap, soap_blist_CompressionType);
		if (a->__sizeCompressionType)
		{	a->CompressionType = (char **)soap_save_block(soap, soap_blist_CompressionType, NULL, 1);
		}
		else
		{	a->CompressionType = NULL;
			if (soap_blist_CompressionType)
				soap_end_block(soap, soap_blist_CompressionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(struct tt__MetadataConfigurationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_new_tt__MetadataConfigurationOptionsExtension(struct soap *soap, int n)
{
	struct tt__MetadataConfigurationOptionsExtension *p;
	struct tt__MetadataConfigurationOptionsExtension *a = (struct tt__MetadataConfigurationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataConfigurationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataConfigurationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const struct tt__MetadataConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataConfigurationOptionsExtension(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptionsExtension(struct soap *soap, struct tt__MetadataConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->PanTiltStatusSupported);
	soap_default_xsd__boolean(soap, &a->ZoomStatusSupported);
	a->PanTiltPositionSupported = NULL;
	a->ZoomPositionSupported = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatusFilterOptions(struct soap *soap, const struct tt__PTZStatusFilterOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->PanTiltStatusSupported, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->ZoomStatusSupported, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToxsd__boolean(soap, &a->PanTiltPositionSupported);
	soap_serialize_PointerToxsd__boolean(soap, &a->ZoomPositionSupported);
	soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZStatusFilterOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptions), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:PanTiltStatusSupported", -1, &a->PanTiltStatusSupported, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:ZoomStatusSupported", -1, &a->ZoomStatusSupported, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:PanTiltPositionSupported", -1, &a->PanTiltPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:ZoomPositionSupported", -1, &a->ZoomPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptions *a, const char *type)
{
	size_t soap_flag_PanTiltStatusSupported = 1;
	size_t soap_flag_ZoomStatusSupported = 1;
	size_t soap_flag_PanTiltPositionSupported = 1;
	size_t soap_flag_ZoomPositionSupported = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStatusFilterOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatusFilterOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTiltStatusSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:PanTiltStatusSupported", &a->PanTiltStatusSupported, "xsd:boolean"))
				{	soap_flag_PanTiltStatusSupported--;
					continue;
				}
			if (soap_flag_ZoomStatusSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:ZoomStatusSupported", &a->ZoomStatusSupported, "xsd:boolean"))
				{	soap_flag_ZoomStatusSupported--;
					continue;
				}
			if (soap_flag_PanTiltPositionSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:PanTiltPositionSupported", &a->PanTiltPositionSupported, "xsd:boolean"))
				{	soap_flag_PanTiltPositionSupported--;
					continue;
				}
			if (soap_flag_ZoomPositionSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:ZoomPositionSupported", &a->ZoomPositionSupported, "xsd:boolean"))
				{	soap_flag_ZoomPositionSupported--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStatusFilterOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PanTiltStatusSupported > 0 || soap_flag_ZoomStatusSupported > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptions, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_new_tt__PTZStatusFilterOptions(struct soap *soap, int n)
{
	struct tt__PTZStatusFilterOptions *p;
	struct tt__PTZStatusFilterOptions *a = (struct tt__PTZStatusFilterOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStatusFilterOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStatusFilterOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatusFilterOptions(struct soap *soap, const struct tt__PTZStatusFilterOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStatusFilterOptions(soap, tag ? tag : "tt:PTZStatusFilterOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatusFilterOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfigurationOptions(struct soap *soap, const struct tt__MetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatusFilterOptions(soap, &a->PTZStatusFilterOptions);
	soap_serialize_PointerTott__MetadataConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptions), type))
		return soap->error;
	if (!a->PTZStatusFilterOptions)
	{	if (soap_element_nil(soap, "tt:PTZStatusFilterOptions"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", -1, &a->PTZStatusFilterOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_PTZStatusFilterOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatusFilterOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", &a->PTZStatusFilterOptions, "tt:PTZStatusFilterOptions"))
				{	soap_flag_PTZStatusFilterOptions--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZStatusFilterOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptions, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_new_tt__MetadataConfigurationOptions(struct soap *soap, int n)
{
	struct tt__MetadataConfigurationOptions *p;
	struct tt__MetadataConfigurationOptions *a = (struct tt__MetadataConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfigurationOptions(struct soap *soap, const struct tt__MetadataConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataConfigurationOptions(soap, tag ? tag : "tt:MetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const struct _tt__EventSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__EventSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__EventSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__EventSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_new__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _tt__EventSubscription_SubscriptionPolicy *p;
	struct _tt__EventSubscription_SubscriptionPolicy *a = (struct _tt__EventSubscription_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__EventSubscription_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__tt__EventSubscription_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const struct _tt__EventSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag ? tag : "tt:EventSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const struct wsnt__FilterType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__FilterType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_new_wsnt__FilterType(struct soap *soap, int n)
{
	struct wsnt__FilterType *p;
	struct wsnt__FilterType *a = (struct wsnt__FilterType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__FilterType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__FilterType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventSubscription(struct soap *soap, struct tt__EventSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventSubscription(struct soap *soap, const struct tt__EventSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap *soap, const char *tag, int id, const struct tt__EventSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap *soap, const char *tag, struct tt__EventSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__FilterType(soap, "tt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventSubscription * SOAP_FMAC4 soap_new_tt__EventSubscription(struct soap *soap, int n)
{
	struct tt__EventSubscription *p;
	struct tt__EventSubscription *a = (struct tt__EventSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventSubscription));
	for (p = a; p && n--; p++)
		soap_default_tt__EventSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventSubscription(struct soap *soap, const struct tt__EventSubscription *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap *soap, struct tt__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZFilter(struct soap *soap, struct tt__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Status);
	soap_default_xsd__boolean(soap, &a->Position);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZFilter(struct soap *soap, const struct tt__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->Position, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const struct tt__PTZFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter *a, const char *type)
{
	size_t soap_flag_Status = 1;
	size_t soap_flag_Position = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Position", &a->Position, "xsd:boolean"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_Position > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_new_tt__PTZFilter(struct soap *soap, int n)
{
	struct tt__PTZFilter *p;
	struct tt__PTZFilter *a = (struct tt__PTZFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZFilter(struct soap *soap, const struct tt__PTZFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, struct tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfigurationExtension(struct soap *soap, const struct tt__MetadataConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationExtension, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_new_tt__MetadataConfigurationExtension(struct soap *soap, int n)
{
	struct tt__MetadataConfigurationExtension *p;
	struct tt__MetadataConfigurationExtension *a = (struct tt__MetadataConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfigurationExtension(struct soap *soap, const struct tt__MetadataConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, struct tt__AudioEncoder2ConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Encoding);
	a->BitrateList = NULL;
	a->SampleRateList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, const struct tt__AudioEncoder2ConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__IntList(soap, &a->BitrateList);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoder2ConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions), type))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_nil(soap, "tt:Encoding"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (!a->BitrateList)
	{	if (soap_element_nil(soap, "tt:BitrateList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->BitrateList, ""))
		return soap->error;
	if (!a->SampleRateList)
	{	if (soap_element_nil(soap, "tt:SampleRateList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->SampleRateList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoder2ConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_BitrateList = 1;
	size_t soap_flag_SampleRateList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoder2ConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(struct tt__AudioEncoder2ConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoder2ConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_BitrateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &a->BitrateList, "tt:IntList"))
				{	soap_flag_BitrateList--;
					continue;
				}
			if (soap_flag_SampleRateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &a->SampleRateList, "tt:IntList"))
				{	soap_flag_SampleRateList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_BitrateList > 0 || soap_flag_SampleRateList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioEncoder2ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions, sizeof(struct tt__AudioEncoder2ConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioEncoder2ConfigurationOptions *p;
	struct tt__AudioEncoder2ConfigurationOptions *a = (struct tt__AudioEncoder2ConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoder2ConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoder2ConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, const struct tt__AudioEncoder2ConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoder2ConfigurationOptions(soap, tag ? tag : "tt:AudioEncoder2ConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoder2ConfigurationOptions(struct soap *soap, struct tt__AudioEncoder2ConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoder2ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	a->BitrateList = NULL;
	a->SampleRateList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfigurationOption(struct soap *soap, const struct tt__AudioEncoderConfigurationOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntList(soap, &a->BitrateList);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfigurationOption *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption), type))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (!a->BitrateList)
	{	if (soap_element_nil(soap, "tt:BitrateList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->BitrateList, ""))
		return soap->error;
	if (!a->SampleRateList)
	{	if (soap_element_nil(soap, "tt:SampleRateList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->SampleRateList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOption *a, const char *type)
{
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_BitrateList = 1;
	size_t soap_flag_SampleRateList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoderConfigurationOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoderConfigurationOption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_BitrateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &a->BitrateList, "tt:IntList"))
				{	soap_flag_BitrateList--;
					continue;
				}
			if (soap_flag_SampleRateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &a->SampleRateList, "tt:IntList"))
				{	soap_flag_SampleRateList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_BitrateList > 0 || soap_flag_SampleRateList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_new_tt__AudioEncoderConfigurationOption(struct soap *soap, int n)
{
	struct tt__AudioEncoderConfigurationOption *p;
	struct tt__AudioEncoderConfigurationOption *a = (struct tt__AudioEncoderConfigurationOption*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoderConfigurationOption));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoderConfigurationOption(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfigurationOption(struct soap *soap, const struct tt__AudioEncoderConfigurationOption *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoderConfigurationOption(soap, tag ? tag : "tt:AudioEncoderConfigurationOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfigurationOptions(struct soap *soap, const struct tt__AudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
			soap_serialize_tt__AudioEncoderConfigurationOption(soap, a->Options + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions), type))
		return soap->error;
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
			if (soap_out_tt__AudioEncoderConfigurationOption(soap, "tt:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_alloc_block(soap);
					a->Options = (struct tt__AudioEncoderConfigurationOption *)soap_push_block_max(soap, soap_blist_Options, sizeof(struct tt__AudioEncoderConfigurationOption));
					if (a->Options == NULL)
						return NULL;
					soap_default_tt__AudioEncoderConfigurationOption(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoderConfigurationOption(soap, "tt:Options", a->Options, "tt:AudioEncoderConfigurationOption"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
		{	a->Options = (struct tt__AudioEncoderConfigurationOption *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		}
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioEncoderConfigurationOptions *p;
	struct tt__AudioEncoderConfigurationOptions *a = (struct tt__AudioEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfigurationOptions(struct soap *soap, const struct tt__AudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceOptionsExtension(struct soap *soap, const struct tt__AudioSourceOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioSourceOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSourceOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceOptionsExtension, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_new_tt__AudioSourceOptionsExtension(struct soap *soap, int n)
{
	struct tt__AudioSourceOptionsExtension *p;
	struct tt__AudioSourceOptionsExtension *a = (struct tt__AudioSourceOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioSourceOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioSourceOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceOptionsExtension(struct soap *soap, const struct tt__AudioSourceOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioSourceOptionsExtension(soap, tag ? tag : "tt:AudioSourceOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInputTokensAvailable = 0;
	a->InputTokensAvailable = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfigurationOptions(struct soap *soap, const struct tt__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->InputTokensAvailable + i));
		}
	}
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), type))
		return soap->error;
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputTokensAvailable; i++)
			soap_out_string(soap, "tt:InputTokensAvailable", -1, (char*const*)(a->InputTokensAvailable + i), "");
	}
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_InputTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputTokensAvailable", 1, NULL))
			{	if (a->InputTokensAvailable == NULL)
				{	if (soap_blist_InputTokensAvailable == NULL)
						soap_blist_InputTokensAvailable = soap_alloc_block(soap);
					a->InputTokensAvailable = (char **)soap_push_block_max(soap, soap_blist_InputTokensAvailable, sizeof(char *));
					if (a->InputTokensAvailable == NULL)
						return NULL;
					*a->InputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputTokensAvailable", (char**)a->InputTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeInputTokensAvailable++;
					a->InputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputTokensAvailable)
			soap_pop_block(soap, soap_blist_InputTokensAvailable);
		if (a->__sizeInputTokensAvailable)
		{	a->InputTokensAvailable = (char **)soap_save_block(soap, soap_blist_InputTokensAvailable, NULL, 1);
		}
		else
		{	a->InputTokensAvailable = NULL;
			if (soap_blist_InputTokensAvailable)
				soap_end_block(soap, soap_blist_InputTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeInputTokensAvailable < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_new_tt__AudioSourceConfigurationOptions(struct soap *soap, int n)
{
	struct tt__AudioSourceConfigurationOptions *p;
	struct tt__AudioSourceConfigurationOptions *a = (struct tt__AudioSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfigurationOptions(struct soap *soap, const struct tt__AudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, struct tt__VideoEncoder2ConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Encoding);
	a->QualityRange = NULL;
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->BitrateRange = NULL;
	soap_default_tt__IntAttrList(soap, &a->GovLengthRange);
	soap_default_tt__FloatAttrList(soap, &a->FrameRatesSupported);
	soap_default_tt__StringAttrList(soap, &a->ProfilesSupported);
	a->ConstantBitRateSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, const struct tt__VideoEncoder2ConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__FloatRange(soap, &a->QualityRange);
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution2);
			soap_serialize_tt__VideoResolution2(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoder2ConfigurationOptions *a, const char *type)
{
	if (a->GovLengthRange)
		soap_set_attr(soap, "GovLengthRange", soap_tt__IntAttrList2s(soap, a->GovLengthRange), 1);
	if (a->FrameRatesSupported)
		soap_set_attr(soap, "FrameRatesSupported", soap_tt__FloatAttrList2s(soap, a->FrameRatesSupported), 1);
	if (a->ProfilesSupported)
		soap_set_attr(soap, "ProfilesSupported", soap_tt__StringAttrList2s(soap, a->ProfilesSupported), 1);
	if (a->ConstantBitRateSupported)
		soap_set_attr(soap, "ConstantBitRateSupported", soap_xsd__boolean2s(soap, *a->ConstantBitRateSupported), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions), type))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_nil(soap, "tt:Encoding"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (!a->QualityRange)
	{	if (soap_element_nil(soap, "tt:QualityRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:QualityRange", -1, &a->QualityRange, ""))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution2(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->BitrateRange)
	{	if (soap_element_nil(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoder2ConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_QualityRange = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_BitrateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoder2ConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(struct tt__VideoEncoder2ConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoder2ConfigurationOptions(soap, a);
	if (soap_s2tt__IntAttrList(soap, soap_attr_value(soap, "GovLengthRange", 0), &a->GovLengthRange))
		return NULL;
	if (soap_s2tt__FloatAttrList(soap, soap_attr_value(soap, "FrameRatesSupported", 0), &a->FrameRatesSupported))
		return NULL;
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "ProfilesSupported", 0), &a->ProfilesSupported))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ConstantBitRateSupported", 0);
		if (t)
		{
			if (!(a->ConstantBitRateSupported = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ConstantBitRateSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:QualityRange", &a->QualityRange, "tt:FloatRange"))
				{	soap_flag_QualityRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution2 *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution2));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution2(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution2(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution2"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution2 *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_QualityRange > 0 || a->__sizeResolutionsAvailable < 1 || soap_flag_BitrateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoder2ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions, sizeof(struct tt__VideoEncoder2ConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoEncoder2ConfigurationOptions *p;
	struct tt__VideoEncoder2ConfigurationOptions *a = (struct tt__VideoEncoder2ConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoder2ConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoder2ConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, const struct tt__VideoEncoder2ConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoder2ConfigurationOptions(soap, tag ? tag : "tt:VideoEncoder2ConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoder2ConfigurationOptions(struct soap *soap, struct tt__VideoEncoder2ConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoder2ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->FrameRateLimit);
	soap_default_int(soap, &a->BitrateLimit);
	a->ConstantBitRate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoRateControl2(struct soap *soap, const struct tt__VideoRateControl2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FrameRateLimit, SOAP_TYPE_float);
	soap_embedded(soap, &a->BitrateLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl2(struct soap *soap, const char *tag, int id, const struct tt__VideoRateControl2 *a, const char *type)
{
	if (a->ConstantBitRate)
		soap_set_attr(soap, "ConstantBitRate", soap_xsd__boolean2s(soap, *a->ConstantBitRate), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl2), type))
		return soap->error;
	if (soap_out_float(soap, "tt:FrameRateLimit", -1, &a->FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->BitrateLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoRateControl2 * SOAP_FMAC4 soap_in_tt__VideoRateControl2(struct soap *soap, const char *tag, struct tt__VideoRateControl2 *a, const char *type)
{
	size_t soap_flag_FrameRateLimit = 1;
	size_t soap_flag_BitrateLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoRateControl2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoRateControl2(soap, a);
	{	const char *t = soap_attr_value(soap, "ConstantBitRate", 0);
		if (t)
		{
			if (!(a->ConstantBitRate = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ConstantBitRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:FrameRateLimit", &a->FrameRateLimit, "xsd:float"))
				{	soap_flag_FrameRateLimit--;
					continue;
				}
			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:BitrateLimit", &a->BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_BitrateLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl2, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoRateControl2 * SOAP_FMAC4 soap_new_tt__VideoRateControl2(struct soap *soap, int n)
{
	struct tt__VideoRateControl2 *p;
	struct tt__VideoRateControl2 *a = (struct tt__VideoRateControl2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoRateControl2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoRateControl2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoRateControl2(struct soap *soap, const struct tt__VideoRateControl2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoRateControl2(soap, tag ? tag : "tt:VideoRateControl2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl2 * SOAP_FMAC4 soap_get_tt__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoResolution2(struct soap *soap, const struct tt__VideoResolution2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution2(struct soap *soap, const char *tag, int id, const struct tt__VideoResolution2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution2), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoResolution2 * SOAP_FMAC4 soap_in_tt__VideoResolution2(struct soap *soap, const char *tag, struct tt__VideoResolution2 *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoResolution2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoResolution2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoResolution2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution2, SOAP_TYPE_tt__VideoResolution2, sizeof(struct tt__VideoResolution2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoResolution2 * SOAP_FMAC4 soap_new_tt__VideoResolution2(struct soap *soap, int n)
{
	struct tt__VideoResolution2 *p;
	struct tt__VideoResolution2 *a = (struct tt__VideoResolution2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoResolution2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoResolution2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoResolution2(struct soap *soap, const struct tt__VideoResolution2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoResolution2(soap, tag ? tag : "tt:VideoResolution2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution2 * SOAP_FMAC4 soap_get_tt__VideoResolution2(struct soap *soap, struct tt__VideoResolution2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderOptionsExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_new_tt__VideoEncoderOptionsExtension2(struct soap *soap, int n)
{
	struct tt__VideoEncoderOptionsExtension2 *p;
	struct tt__VideoEncoderOptionsExtension2 *a = (struct tt__VideoEncoderOptionsExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderOptionsExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderOptionsExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
	a->BitrateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const struct tt__H264Options2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_nil(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_nil(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	if (!a->BitrateRange)
	{	if (soap_element_nil(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Options2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_alloc_block(soap);
					a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block_max(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
		{	a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		}
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1 || soap_flag_BitrateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_new_tt__H264Options2(struct soap *soap, int n)
{
	struct tt__H264Options2 *p;
	struct tt__H264Options2 *a = (struct tt__H264Options2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264Options2));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Options2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
	a->BitrateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_nil(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_nil(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	if (!a->BitrateRange)
	{	if (soap_element_nil(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Options2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_alloc_block(soap);
					a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block_max(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
		{	a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		}
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1 || soap_flag_BitrateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_new_tt__Mpeg4Options2(struct soap *soap, int n)
{
	struct tt__Mpeg4Options2 *p;
	struct tt__Mpeg4Options2 *a = (struct tt__Mpeg4Options2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4Options2));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Options2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->BitrateRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->FrameRateRange)
	{	if (soap_element_nil(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (!a->BitrateRange)
	{	if (soap_element_nil(soap, "tt:BitrateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	size_t soap_flag_BitrateRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__JpegOptions2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegOptions2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || soap_flag_BitrateRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_new_tt__JpegOptions2(struct soap *soap, int n)
{
	struct tt__JpegOptions2 *p;
	struct tt__JpegOptions2 *a = (struct tt__JpegOptions2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__JpegOptions2));
	for (p = a; p && n--; p++)
		soap_default_tt__JpegOptions2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__JpegOptions2(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions2"))
				{	soap_flag_JPEG--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options2"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &a->H264, "tt:H264Options2"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_new_tt__VideoEncoderOptionsExtension(struct soap *soap, int n)
{
	struct tt__VideoEncoderOptionsExtension *p;
	struct tt__VideoEncoderOptionsExtension *a = (struct tt__VideoEncoderOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options(struct soap *soap, struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options(struct soap *soap, const struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const struct tt__H264Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_nil(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_nil(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, struct tt__H264Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_alloc_block(soap);
					a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block_max(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
		{	a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		}
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_new_tt__H264Options(struct soap *soap, int n)
{
	struct tt__H264Options *p;
	struct tt__H264Options *a = (struct tt__H264Options*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264Options));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Options(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options(struct soap *soap, const struct tt__H264Options *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Options(soap, tag ? tag : "tt:H264Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, struct tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->GovLengthRange)
	{	if (soap_element_nil(soap, "tt:GovLengthRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
		return soap->error;
	if (!a->FrameRateRange)
	{	if (soap_element_nil(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < (int)a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_alloc_block(soap);
					a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block_max(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
		{	a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		}
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_new_tt__Mpeg4Options(struct soap *soap, int n)
{
	struct tt__Mpeg4Options *p;
	struct tt__Mpeg4Options *a = (struct tt__Mpeg4Options*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4Options));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Options(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < (int)a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (!a->FrameRateRange)
	{	if (soap_element_nil(soap, "tt:FrameRateRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
		return soap->error;
	if (!a->EncodingIntervalRange)
	{	if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__JpegOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_alloc_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block_max(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
		{	a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		}
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_new_tt__JpegOptions(struct soap *soap, int n)
{
	struct tt__JpegOptions *p;
	struct tt__JpegOptions *a = (struct tt__JpegOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__JpegOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__JpegOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->QualityRange = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &a->QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type))
		return soap->error;
	if (!a->QualityRange)
	{	if (soap_element_nil(soap, "tt:QualityRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->QualityRange, ""))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_QualityRange = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &a->QualityRange, "tt:IntRange"))
				{	soap_flag_QualityRange--;
					continue;
				}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions"))
				{	soap_flag_JPEG--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options(soap, "tt:H264", &a->H264, "tt:H264Options"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QualityRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_new_tt__VideoEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct tt__VideoEncoderConfigurationOptions *p;
	struct tt__VideoEncoderConfigurationOptions *a = (struct tt__VideoEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__H264Profile(soap, &a->H264Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->H264Profile, SOAP_TYPE_tt__H264Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const struct tt__H264Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->H264Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_H264Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			if (soap_flag_H264Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->H264Profile, "tt:H264Profile"))
				{	soap_flag_H264Profile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_H264Profile > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_new_tt__H264Configuration(struct soap *soap, int n)
{
	struct tt__H264Configuration *p;
	struct tt__H264Configuration *a = (struct tt__H264Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__H264Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__Mpeg4Profile(soap, &a->Mpeg4Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->Mpeg4Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_Mpeg4Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			if (soap_flag_Mpeg4Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->Mpeg4Profile, "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_Mpeg4Profile > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_new_tt__Mpeg4Configuration(struct soap *soap, int n)
{
	struct tt__Mpeg4Configuration *p;
	struct tt__Mpeg4Configuration *a = (struct tt__Mpeg4Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Mpeg4Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->FrameRateLimit);
	soap_default_int(soap, &a->EncodingInterval);
	soap_default_int(soap, &a->BitrateLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &a->EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &a->BitrateLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const struct tt__VideoRateControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->BitrateLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl *a, const char *type)
{
	size_t soap_flag_FrameRateLimit = 1;
	size_t soap_flag_EncodingInterval = 1;
	size_t soap_flag_BitrateLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoRateControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoRateControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:FrameRateLimit", &a->FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit--;
					continue;
				}
			if (soap_flag_EncodingInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:EncodingInterval", &a->EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval--;
					continue;
				}
			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:BitrateLimit", &a->BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_EncodingInterval > 0 || soap_flag_BitrateLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_new_tt__VideoRateControl(struct soap *soap, int n)
{
	struct tt__VideoRateControl *p;
	struct tt__VideoRateControl *a = (struct tt__VideoRateControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoRateControl));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoRateControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
