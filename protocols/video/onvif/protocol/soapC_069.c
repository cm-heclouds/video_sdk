/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTreeExtension))
		soap_serialize_tt__ObjectTreeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, int id, struct tt__ObjectTreeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTreeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectTreeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, struct tt__ObjectTreeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectTreeExtension **)soap_malloc(soap, sizeof(struct tt__ObjectTreeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectTreeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTreeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectTreeExtension(soap, tag ? tag : "tt:ObjectTreeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Merge(struct soap *soap, struct tt__Merge *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Merge))
		soap_serialize_tt__Merge(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Merge(struct soap *soap, const char *tag, int id, struct tt__Merge *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Merge, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Merge(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Merge ** SOAP_FMAC4 soap_in_PointerTott__Merge(struct soap *soap, const char *tag, struct tt__Merge **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Merge **)soap_malloc(soap, sizeof(struct tt__Merge *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Merge(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Merge **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Merge(struct soap *soap, struct tt__Merge *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Merge(soap, tag ? tag : "tt:Merge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Merge ** SOAP_FMAC4 soap_get_PointerTott__Merge(struct soap *soap, struct tt__Merge **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Split(struct soap *soap, struct tt__Split *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Split))
		soap_serialize_tt__Split(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Split(struct soap *soap, const char *tag, int id, struct tt__Split *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Split, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Split(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Split ** SOAP_FMAC4 soap_in_PointerTott__Split(struct soap *soap, const char *tag, struct tt__Split **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Split **)soap_malloc(soap, sizeof(struct tt__Split *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Split(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Split **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Split(struct soap *soap, struct tt__Split *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Split(soap, tag ? tag : "tt:Split", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Split ** SOAP_FMAC4 soap_get_PointerTott__Split(struct soap *soap, struct tt__Split **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rename(struct soap *soap, struct tt__Rename *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rename))
		soap_serialize_tt__Rename(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rename(struct soap *soap, const char *tag, int id, struct tt__Rename *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rename, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rename(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rename ** SOAP_FMAC4 soap_in_PointerTott__Rename(struct soap *soap, const char *tag, struct tt__Rename **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rename **)soap_malloc(soap, sizeof(struct tt__Rename *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rename(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rename **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rename(struct soap *soap, struct tt__Rename *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rename(soap, tag ? tag : "tt:Rename", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rename ** SOAP_FMAC4 soap_get_PointerTott__Rename(struct soap *soap, struct tt__Rename **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BehaviourExtension))
		soap_serialize_tt__BehaviourExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, int id, struct tt__BehaviourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BehaviourExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BehaviourExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BehaviourExtension ** SOAP_FMAC4 soap_in_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, struct tt__BehaviourExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BehaviourExtension **)soap_malloc(soap, sizeof(struct tt__BehaviourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BehaviourExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BehaviourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BehaviourExtension(soap, tag ? tag : "tt:BehaviourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BehaviourExtension ** SOAP_FMAC4 soap_get_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Idle))
		soap_serialize__tt__Behaviour_Idle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, struct _tt__Behaviour_Idle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Idle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__Behaviour_Idle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, struct _tt__Behaviour_Idle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__Behaviour_Idle **)soap_malloc(soap, sizeof(struct _tt__Behaviour_Idle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__Behaviour_Idle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Idle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, tag ? tag : "tt:Behaviour-Idle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Removed))
		soap_serialize__tt__Behaviour_Removed(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, struct _tt__Behaviour_Removed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Removed, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__Behaviour_Removed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, struct _tt__Behaviour_Removed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__Behaviour_Removed **)soap_malloc(soap, sizeof(struct _tt__Behaviour_Removed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__Behaviour_Removed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Removed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, tag ? tag : "tt:Behaviour-Removed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectId))
		soap_serialize_tt__ObjectId(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectId(struct soap *soap, const char *tag, int id, struct tt__ObjectId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectId, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectId ** SOAP_FMAC4 soap_in_PointerTott__ObjectId(struct soap *soap, const char *tag, struct tt__ObjectId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectId **)soap_malloc(soap, sizeof(struct tt__ObjectId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectId(soap, tag ? tag : "tt:ObjectId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectId ** SOAP_FMAC4 soap_get_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension2))
		soap_serialize_tt__FrameExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension2(struct soap *soap, const char *tag, int id, struct tt__FrameExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FrameExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FrameExtension2 ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension2(struct soap *soap, const char *tag, struct tt__FrameExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FrameExtension2 **)soap_malloc(soap, sizeof(struct tt__FrameExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FrameExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FrameExtension2(soap, tag ? tag : "tt:FrameExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension2 ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionInCells))
		soap_serialize_tt__MotionInCells(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionInCells(struct soap *soap, const char *tag, int id, struct tt__MotionInCells *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionInCells, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MotionInCells(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MotionInCells ** SOAP_FMAC4 soap_in_PointerTott__MotionInCells(struct soap *soap, const char *tag, struct tt__MotionInCells **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MotionInCells **)soap_malloc(soap, sizeof(struct tt__MotionInCells *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MotionInCells(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MotionInCells **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MotionInCells(soap, tag ? tag : "tt:MotionInCells", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionInCells ** SOAP_FMAC4 soap_get_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionInCells(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension))
		soap_serialize_tt__FrameExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension(struct soap *soap, const char *tag, int id, struct tt__FrameExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FrameExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FrameExtension ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension(struct soap *soap, const char *tag, struct tt__FrameExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FrameExtension **)soap_malloc(soap, sizeof(struct tt__FrameExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FrameExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FrameExtension(soap, tag ? tag : "tt:FrameExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTree))
		soap_serialize_tt__ObjectTree(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTree(struct soap *soap, const char *tag, int id, struct tt__ObjectTree *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTree, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectTree(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectTree ** SOAP_FMAC4 soap_in_PointerTott__ObjectTree(struct soap *soap, const char *tag, struct tt__ObjectTree **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectTree **)soap_malloc(soap, sizeof(struct tt__ObjectTree *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectTree(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTree **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectTree(soap, tag ? tag : "tt:ObjectTree", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTree ** SOAP_FMAC4 soap_get_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Object(struct soap *soap, struct tt__Object *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Object))
		soap_serialize_tt__Object(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Object(struct soap *soap, const char *tag, int id, struct tt__Object *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Object, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Object(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Object ** SOAP_FMAC4 soap_in_PointerTott__Object(struct soap *soap, const char *tag, struct tt__Object **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Object **)soap_malloc(soap, sizeof(struct tt__Object *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Object(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Object **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Object(struct soap *soap, struct tt__Object *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Object(soap, tag ? tag : "tt:Object", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Object ** SOAP_FMAC4 soap_get_PointerTott__Object(struct soap *soap, struct tt__Object **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatus))
		soap_serialize_tt__PTZStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatus(struct soap *soap, const char *tag, int id, struct tt__PTZStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZStatus(struct soap *soap, const char *tag, struct tt__PTZStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatus **)soap_malloc(soap, sizeof(struct tt__PTZStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TransformationExtension))
		soap_serialize_tt__TransformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TransformationExtension(struct soap *soap, const char *tag, int id, struct tt__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TransformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TransformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTott__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TransformationExtension **)soap_malloc(soap, sizeof(struct tt__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TransformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension2))
		soap_serialize_tt__ClassDescriptorExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension2(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptorExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptorExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension2(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptorExtension2 **)soap_malloc(soap, sizeof(struct tt__ClassDescriptorExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptorExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ClassDescriptorExtension2(soap, tag ? tag : "tt:ClassDescriptorExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OtherType(struct soap *soap, struct tt__OtherType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OtherType))
		soap_serialize_tt__OtherType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OtherType(struct soap *soap, const char *tag, int id, struct tt__OtherType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OtherType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OtherType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OtherType ** SOAP_FMAC4 soap_in_PointerTott__OtherType(struct soap *soap, const char *tag, struct tt__OtherType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OtherType **)soap_malloc(soap, sizeof(struct tt__OtherType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OtherType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OtherType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OtherType(struct soap *soap, struct tt__OtherType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OtherType(soap, tag ? tag : "tt:OtherType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OtherType ** SOAP_FMAC4 soap_get_PointerTott__OtherType(struct soap *soap, struct tt__OtherType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OtherType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension))
		soap_serialize_tt__ClassDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, tag ? tag : "tt:ClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate))
		soap_serialize__tt__ClassDescriptor_ClassCandidate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, struct _tt__ClassDescriptor_ClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _tt__ClassDescriptor_ClassCandidate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ClassDescriptor_ClassCandidate **)soap_malloc(soap, sizeof(struct _tt__ClassDescriptor_ClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ClassDescriptor_ClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag ? tag : "tt:ClassDescriptor-ClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_get_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptorExtension))
		soap_serialize_tt__ColorDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ColorDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptorExtension(struct soap *soap, const char *tag, struct tt__ColorDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ColorDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(struct tt__ColorDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorDescriptorExtension(soap, tag ? tag : "tt:ColorDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster))
		soap_serialize__tt__ColorDescriptor_ColorCluster(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ColorDescriptor_ColorCluster(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ColorDescriptor_ColorCluster **)soap_malloc(soap, sizeof(struct _tt__ColorDescriptor_ColorCluster *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag ? tag : "tt:ColorDescriptor-ColorCluster", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_get_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorCovariance))
		soap_serialize_tt__ColorCovariance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorCovariance(struct soap *soap, const char *tag, int id, struct tt__ColorCovariance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorCovariance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorCovariance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_in_PointerTott__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorCovariance **)soap_malloc(soap, sizeof(struct tt__ColorCovariance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorCovariance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorCovariance(soap, tag ? tag : "tt:ColorCovariance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_get_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, struct tt__Color *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		soap_serialize_tt__Color(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, struct tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, struct tt__Color **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Color **)soap_malloc(soap, sizeof(struct tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Color(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, struct tt__Color *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, struct tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptorExtension))
		soap_serialize_tt__ShapeDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ShapeDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptorExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ShapeDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct tt__ShapeDescriptorExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ShapeDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ShapeDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ShapeDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, tag ? tag : "tt:ShapeDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polygon(struct soap *soap, struct tt__Polygon *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polygon))
		soap_serialize_tt__Polygon(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polygon(struct soap *soap, const char *tag, int id, struct tt__Polygon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polygon, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Polygon(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Polygon ** SOAP_FMAC4 soap_in_PointerTott__Polygon(struct soap *soap, const char *tag, struct tt__Polygon **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Polygon **)soap_malloc(soap, sizeof(struct tt__Polygon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Polygon(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polygon(struct soap *soap, struct tt__Polygon *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Polygon(soap, tag ? tag : "tt:Polygon", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polygon ** SOAP_FMAC4 soap_get_PointerTott__Polygon(struct soap *soap, struct tt__Polygon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AppearanceExtension))
		soap_serialize_tt__AppearanceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, int id, struct tt__AppearanceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AppearanceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AppearanceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AppearanceExtension ** SOAP_FMAC4 soap_in_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, struct tt__AppearanceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AppearanceExtension **)soap_malloc(soap, sizeof(struct tt__AppearanceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AppearanceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AppearanceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AppearanceExtension(soap, tag ? tag : "tt:AppearanceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AppearanceExtension ** SOAP_FMAC4 soap_get_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptor))
		soap_serialize_tt__ClassDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, struct tt__ClassDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptor **)soap_malloc(soap, sizeof(struct tt__ClassDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ClassDescriptor(soap, tag ? tag : "tt:ClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptor))
		soap_serialize_tt__ColorDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, int id, struct tt__ColorDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, struct tt__ColorDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorDescriptor **)soap_malloc(soap, sizeof(struct tt__ColorDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorDescriptor(soap, tag ? tag : "tt:ColorDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptor))
		soap_serialize_tt__ShapeDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, int id, struct tt__ShapeDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ShapeDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ShapeDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, struct tt__ShapeDescriptor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ShapeDescriptor **)soap_malloc(soap, sizeof(struct tt__ShapeDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ShapeDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ShapeDescriptor(soap, tag ? tag : "tt:ShapeDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transformation))
		soap_serialize_tt__Transformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transformation(struct soap *soap, const char *tag, int id, struct tt__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Transformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_in_PointerTott__Transformation(struct soap *soap, const char *tag, struct tt__Transformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Transformation **)soap_malloc(soap, sizeof(struct tt__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Transformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Transformation(soap, tag ? tag : "tt:Transformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_get_PointerTott__Transformation(struct soap *soap, struct tt__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		soap_serialize_tt__Vector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, struct tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, struct tt__Vector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector **)soap_malloc(soap, sizeof(struct tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, struct tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescriptionExtension))
		soap_serialize_tt__ItemListDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription))
		soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription))
		soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescriptionExtension))
		soap_serialize_tt__MessageDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescriptionExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		soap_serialize_tt__ItemListExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListExtension **)soap_malloc(soap, sizeof(struct tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		soap_serialize__tt__ItemList_ElementItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		soap_serialize__tt__ItemList_SimpleItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		soap_serialize_tt__FocusOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(struct tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		soap_serialize_tt__WhiteBalanceOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		soap_serialize_tt__FocusConfiguration20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		soap_serialize_tt__WhiteBalance20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		soap_serialize_tt__RelativeFocusOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, struct tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(struct tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, int id, enum tt__BacklightCompensationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__BacklightCompensationMode **)soap_malloc(soap, sizeof(enum tt__BacklightCompensationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationMode(soap, tag ? tag : "tt:BacklightCompensationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension))
		soap_serialize_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_malloc(soap, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension))
		soap_serialize_tt__ImageStabilizationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationMode(struct soap *soap, const char *tag, int id, enum tt__ImageStabilizationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationMode(struct soap *soap, const char *tag, enum tt__ImageStabilizationMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ImageStabilizationMode **)soap_malloc(soap, sizeof(enum tt__ImageStabilizationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ImageStabilizationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationMode(soap, tag ? tag : "tt:ImageStabilizationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension4))
		soap_serialize_tt__ImagingOptions20Extension4(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension4, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension4(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension4 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension4(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReductionOptions))
		soap_serialize_tt__NoiseReductionOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, int id, struct tt__NoiseReductionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReductionOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NoiseReductionOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions ** SOAP_FMAC4 soap_in_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, struct tt__NoiseReductionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NoiseReductionOptions **)soap_malloc(soap, sizeof(struct tt__NoiseReductionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NoiseReductionOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NoiseReductionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions ** SOAP_FMAC4 soap_get_PointerTott__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingOptions))
		soap_serialize_tt__DefoggingOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, int id, struct tt__DefoggingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DefoggingOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DefoggingOptions ** SOAP_FMAC4 soap_in_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, struct tt__DefoggingOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DefoggingOptions **)soap_malloc(soap, sizeof(struct tt__DefoggingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DefoggingOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DefoggingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingOptions ** SOAP_FMAC4 soap_get_PointerTott__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
