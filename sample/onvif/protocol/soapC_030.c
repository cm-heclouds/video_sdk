/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->StorageToken);
	soap_default_string(soap, &a->RelativePath);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StorageReferencePath(struct soap *soap, const struct tt__StorageReferencePath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->StorageToken);
	soap_serialize_string(soap, (char*const*)&a->RelativePath);
	soap_serialize_PointerTott__StorageReferencePathExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StorageReferencePath(struct soap *soap, const char *tag, int id, const struct tt__StorageReferencePath *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StorageReferencePath), type))
		return soap->error;
	if (!a->StorageToken)
	{	if (soap_element_nil(soap, "tt:StorageToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:StorageToken", -1, (char*const*)&a->StorageToken, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:RelativePath", -1, (char*const*)&a->RelativePath, ""))
		return soap->error;
	if (soap_out_PointerTott__StorageReferencePathExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__StorageReferencePath * SOAP_FMAC4 soap_in_tt__StorageReferencePath(struct soap *soap, const char *tag, struct tt__StorageReferencePath *a, const char *type)
{
	size_t soap_flag_StorageToken = 1;
	size_t soap_flag_RelativePath = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__StorageReferencePath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__StorageReferencePath(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:StorageToken", (char**)&a->StorageToken, "tt:ReferenceToken"))
				{	soap_flag_StorageToken--;
					continue;
				}
			if (soap_flag_RelativePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:RelativePath", (char**)&a->RelativePath, "xsd:string"))
				{	soap_flag_RelativePath--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StorageReferencePathExtension(soap, "tt:Extension", &a->Extension, "tt:StorageReferencePathExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StorageToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__StorageReferencePath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StorageReferencePath, SOAP_TYPE_tt__StorageReferencePath, sizeof(struct tt__StorageReferencePath), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__StorageReferencePath * SOAP_FMAC4 soap_new_tt__StorageReferencePath(struct soap *soap, int n)
{
	struct tt__StorageReferencePath *p;
	struct tt__StorageReferencePath *a = (struct tt__StorageReferencePath*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__StorageReferencePath));
	for (p = a; p && n--; p++)
		soap_default_tt__StorageReferencePath(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StorageReferencePath(struct soap *soap, const struct tt__StorageReferencePath *a, const char *tag, const char *type)
{
	if (soap_out_tt__StorageReferencePath(soap, tag ? tag : "tt:StorageReferencePath", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StorageReferencePath * SOAP_FMAC4 soap_get_tt__StorageReferencePath(struct soap *soap, struct tt__StorageReferencePath *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StorageReferencePath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ArrayOfFileProgressExtension(struct soap *soap, const struct tt__ArrayOfFileProgressExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, int id, const struct tt__ArrayOfFileProgressExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_in_tt__ArrayOfFileProgressExtension(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgressExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ArrayOfFileProgressExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ArrayOfFileProgressExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgressExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgressExtension, SOAP_TYPE_tt__ArrayOfFileProgressExtension, sizeof(struct tt__ArrayOfFileProgressExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_new_tt__ArrayOfFileProgressExtension(struct soap *soap, int n)
{
	struct tt__ArrayOfFileProgressExtension *p;
	struct tt__ArrayOfFileProgressExtension *a = (struct tt__ArrayOfFileProgressExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ArrayOfFileProgressExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ArrayOfFileProgressExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ArrayOfFileProgressExtension(struct soap *soap, const struct tt__ArrayOfFileProgressExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ArrayOfFileProgressExtension(soap, tag ? tag : "tt:ArrayOfFileProgressExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgressExtension * SOAP_FMAC4 soap_get_tt__ArrayOfFileProgressExtension(struct soap *soap, struct tt__ArrayOfFileProgressExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ArrayOfFileProgressExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeFileProgress = 0;
	a->FileProgress = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ArrayOfFileProgress(struct soap *soap, const struct tt__ArrayOfFileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->FileProgress)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileProgress; i++)
		{
			soap_embedded(soap, a->FileProgress + i, SOAP_TYPE_tt__FileProgress);
			soap_serialize_tt__FileProgress(soap, a->FileProgress + i);
		}
	}
	soap_serialize_PointerTott__ArrayOfFileProgressExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ArrayOfFileProgress(struct soap *soap, const char *tag, int id, const struct tt__ArrayOfFileProgress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ArrayOfFileProgress), type))
		return soap->error;
	if (a->FileProgress)
	{	int i;
		for (i = 0; i < (int)a->__sizeFileProgress; i++)
			if (soap_out_tt__FileProgress(soap, "tt:FileProgress", -1, a->FileProgress + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ArrayOfFileProgressExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress * SOAP_FMAC4 soap_in_tt__ArrayOfFileProgress(struct soap *soap, const char *tag, struct tt__ArrayOfFileProgress *a, const char *type)
{
	struct soap_blist *soap_blist_FileProgress = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ArrayOfFileProgress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ArrayOfFileProgress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FileProgress", 1, NULL))
			{	if (a->FileProgress == NULL)
				{	if (soap_blist_FileProgress == NULL)
						soap_blist_FileProgress = soap_alloc_block(soap);
					a->FileProgress = (struct tt__FileProgress *)soap_push_block_max(soap, soap_blist_FileProgress, sizeof(struct tt__FileProgress));
					if (a->FileProgress == NULL)
						return NULL;
					soap_default_tt__FileProgress(soap, a->FileProgress);
				}
				soap_revert(soap);
				if (soap_in_tt__FileProgress(soap, "tt:FileProgress", a->FileProgress, "tt:FileProgress"))
				{	a->__sizeFileProgress++;
					a->FileProgress = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ArrayOfFileProgressExtension(soap, "tt:Extension", &a->Extension, "tt:ArrayOfFileProgressExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->FileProgress)
			soap_pop_block(soap, soap_blist_FileProgress);
		if (a->__sizeFileProgress)
		{	a->FileProgress = (struct tt__FileProgress *)soap_save_block(soap, soap_blist_FileProgress, NULL, 1);
		}
		else
		{	a->FileProgress = NULL;
			if (soap_blist_FileProgress)
				soap_end_block(soap, soap_blist_FileProgress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ArrayOfFileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ArrayOfFileProgress, SOAP_TYPE_tt__ArrayOfFileProgress, sizeof(struct tt__ArrayOfFileProgress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress * SOAP_FMAC4 soap_new_tt__ArrayOfFileProgress(struct soap *soap, int n)
{
	struct tt__ArrayOfFileProgress *p;
	struct tt__ArrayOfFileProgress *a = (struct tt__ArrayOfFileProgress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ArrayOfFileProgress));
	for (p = a; p && n--; p++)
		soap_default_tt__ArrayOfFileProgress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ArrayOfFileProgress(struct soap *soap, const struct tt__ArrayOfFileProgress *a, const char *tag, const char *type)
{
	if (soap_out_tt__ArrayOfFileProgress(soap, tag ? tag : "tt:ArrayOfFileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ArrayOfFileProgress * SOAP_FMAC4 soap_get_tt__ArrayOfFileProgress(struct soap *soap, struct tt__ArrayOfFileProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ArrayOfFileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FileProgress(struct soap *soap, struct tt__FileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->FileName);
	soap_default_float(soap, &a->Progress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FileProgress(struct soap *soap, const struct tt__FileProgress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->FileName);
	soap_embedded(soap, &a->Progress, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FileProgress(struct soap *soap, const char *tag, int id, const struct tt__FileProgress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FileProgress), type))
		return soap->error;
	if (!a->FileName)
	{	if (soap_element_nil(soap, "tt:FileName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:FileName", -1, (char*const*)&a->FileName, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Progress", -1, &a->Progress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FileProgress * SOAP_FMAC4 soap_in_tt__FileProgress(struct soap *soap, const char *tag, struct tt__FileProgress *a, const char *type)
{
	size_t soap_flag_FileName = 1;
	size_t soap_flag_Progress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FileProgress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FileProgress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:FileName", (char**)&a->FileName, "xsd:string"))
				{	soap_flag_FileName--;
					continue;
				}
			if (soap_flag_Progress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Progress", &a->Progress, "xsd:float"))
				{	soap_flag_Progress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FileName > 0 || soap_flag_Progress > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__FileProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FileProgress, SOAP_TYPE_tt__FileProgress, sizeof(struct tt__FileProgress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FileProgress * SOAP_FMAC4 soap_new_tt__FileProgress(struct soap *soap, int n)
{
	struct tt__FileProgress *p;
	struct tt__FileProgress *a = (struct tt__FileProgress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FileProgress));
	for (p = a; p && n--; p++)
		soap_default_tt__FileProgress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FileProgress(struct soap *soap, const struct tt__FileProgress *a, const char *tag, const char *type)
{
	if (soap_out_tt__FileProgress(soap, tag ? tag : "tt:FileProgress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FileProgress * SOAP_FMAC4 soap_get_tt__FileProgress(struct soap *soap, struct tt__FileProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FileProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfigurationOptionsExtension(struct soap *soap, const struct tt__OSDConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(struct tt__OSDConfigurationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDConfigurationOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDConfigurationOptionsExtension *p;
	struct tt__OSDConfigurationOptionsExtension *a = (struct tt__OSDConfigurationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfigurationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfigurationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfigurationOptionsExtension(struct soap *soap, const struct tt__OSDConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptionsExtension(struct soap *soap, struct tt__OSDConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MaximumNumberOfOSDs = NULL;
	a->__sizeType = 0;
	a->Type = NULL;
	a->__sizePositionOption = 0;
	a->PositionOption = NULL;
	a->TextOption = NULL;
	a->ImageOption = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfigurationOptions(struct soap *soap, const struct tt__OSDConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MaximumNumberOfOSDs(soap, &a->MaximumNumberOfOSDs);
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
		{
			soap_embedded(soap, a->Type + i, SOAP_TYPE_tt__OSDType);
		}
	}
	if (a->PositionOption)
	{	int i;
		for (i = 0; i < (int)a->__sizePositionOption; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->PositionOption + i));
		}
	}
	soap_serialize_PointerTott__OSDTextOptions(soap, &a->TextOption);
	soap_serialize_PointerTott__OSDImgOptions(soap, &a->ImageOption);
	soap_serialize_PointerTott__OSDConfigurationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptions), type))
		return soap->error;
	if (!a->MaximumNumberOfOSDs)
	{	if (soap_element_nil(soap, "tt:MaximumNumberOfOSDs"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", -1, &a->MaximumNumberOfOSDs, ""))
		return soap->error;
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
			if (soap_out_tt__OSDType(soap, "tt:Type", -1, a->Type + i, ""))
				return soap->error;
	}
	if (a->PositionOption)
	{	int i;
		for (i = 0; i < (int)a->__sizePositionOption; i++)
			soap_out_string(soap, "tt:PositionOption", -1, (char*const*)(a->PositionOption + i), "");
	}
	if (soap_out_PointerTott__OSDTextOptions(soap, "tt:TextOption", -1, &a->TextOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgOptions(soap, "tt:ImageOption", -1, &a->ImageOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, struct tt__OSDConfigurationOptions *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfOSDs = 1;
	struct soap_blist *soap_blist_Type = NULL;
	struct soap_blist *soap_blist_PositionOption = NULL;
	size_t soap_flag_TextOption = 1;
	size_t soap_flag_ImageOption = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfOSDs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", &a->MaximumNumberOfOSDs, "tt:MaximumNumberOfOSDs"))
				{	soap_flag_MaximumNumberOfOSDs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
			{	if (a->Type == NULL)
				{	if (soap_blist_Type == NULL)
						soap_blist_Type = soap_alloc_block(soap);
					a->Type = (enum tt__OSDType *)soap_push_block_max(soap, soap_blist_Type, sizeof(enum tt__OSDType));
					if (a->Type == NULL)
						return NULL;
					soap_default_tt__OSDType(soap, a->Type);
				}
				soap_revert(soap);
				if (soap_in_tt__OSDType(soap, "tt:Type", a->Type, "tt:OSDType"))
				{	a->__sizeType++;
					a->Type = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PositionOption", 1, NULL))
			{	if (a->PositionOption == NULL)
				{	if (soap_blist_PositionOption == NULL)
						soap_blist_PositionOption = soap_alloc_block(soap);
					a->PositionOption = (char **)soap_push_block_max(soap, soap_blist_PositionOption, sizeof(char *));
					if (a->PositionOption == NULL)
						return NULL;
					*a->PositionOption = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:PositionOption", (char**)a->PositionOption, "xsd:string"))
				{	a->__sizePositionOption++;
					a->PositionOption = NULL;
					continue;
				}
			}
			if (soap_flag_TextOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDTextOptions(soap, "tt:TextOption", &a->TextOption, "tt:OSDTextOptions"))
				{	soap_flag_TextOption--;
					continue;
				}
			if (soap_flag_ImageOption && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDImgOptions(soap, "tt:ImageOption", &a->ImageOption, "tt:OSDImgOptions"))
				{	soap_flag_ImageOption--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Type)
			soap_pop_block(soap, soap_blist_Type);
		if (a->__sizeType)
		{	a->Type = (enum tt__OSDType *)soap_save_block(soap, soap_blist_Type, NULL, 1);
		}
		else
		{	a->Type = NULL;
			if (soap_blist_Type)
				soap_end_block(soap, soap_blist_Type);
		}
		if (a->PositionOption)
			soap_pop_block(soap, soap_blist_PositionOption);
		if (a->__sizePositionOption)
		{	a->PositionOption = (char **)soap_save_block(soap, soap_blist_PositionOption, NULL, 1);
		}
		else
		{	a->PositionOption = NULL;
			if (soap_blist_PositionOption)
				soap_end_block(soap, soap_blist_PositionOption);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfOSDs > 0 || a->__sizeType < 1 || a->__sizePositionOption < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptions, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(struct tt__OSDConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions * SOAP_FMAC4 soap_new_tt__OSDConfigurationOptions(struct soap *soap, int n)
{
	struct tt__OSDConfigurationOptions *p;
	struct tt__OSDConfigurationOptions *a = (struct tt__OSDConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfigurationOptions(struct soap *soap, const struct tt__OSDConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationOptions * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptions(struct soap *soap, struct tt__OSDConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Total);
	a->Image = NULL;
	a->PlainText = NULL;
	a->Date = NULL;
	a->Time = NULL;
	a->DateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MaximumNumberOfOSDs(struct soap *soap, const struct tt__MaximumNumberOfOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, const struct tt__MaximumNumberOfOSDs *a, const char *type)
{
	soap_set_attr(soap, "Total", soap_int2s(soap, a->Total), 1);
	if (a->Image)
		soap_set_attr(soap, "Image", soap_int2s(soap, *a->Image), 1);
	if (a->PlainText)
		soap_set_attr(soap, "PlainText", soap_int2s(soap, *a->PlainText), 1);
	if (a->Date)
		soap_set_attr(soap, "Date", soap_int2s(soap, *a->Date), 1);
	if (a->Time)
		soap_set_attr(soap, "Time", soap_int2s(soap, *a->Time), 1);
	if (a->DateAndTime)
		soap_set_attr(soap, "DateAndTime", soap_int2s(soap, *a->DateAndTime), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_in_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, struct tt__MaximumNumberOfOSDs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MaximumNumberOfOSDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MaximumNumberOfOSDs(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "Total", 1), &a->Total))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Image", 0);
		if (t)
		{
			if (!(a->Image = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Image))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "PlainText", 0);
		if (t)
		{
			if (!(a->PlainText = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->PlainText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Date", 0);
		if (t)
		{
			if (!(a->Date = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Date))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Time", 0);
		if (t)
		{
			if (!(a->Time = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Time))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DateAndTime", 0);
		if (t)
		{
			if (!(a->DateAndTime = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->DateAndTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MaximumNumberOfOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MaximumNumberOfOSDs, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(struct tt__MaximumNumberOfOSDs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_new_tt__MaximumNumberOfOSDs(struct soap *soap, int n)
{
	struct tt__MaximumNumberOfOSDs *p;
	struct tt__MaximumNumberOfOSDs *a = (struct tt__MaximumNumberOfOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MaximumNumberOfOSDs));
	for (p = a; p && n--; p++)
		soap_default_tt__MaximumNumberOfOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MaximumNumberOfOSDs(struct soap *soap, const struct tt__MaximumNumberOfOSDs *a, const char *tag, const char *type)
{
	if (soap_out_tt__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_get_tt__MaximumNumberOfOSDs(struct soap *soap, struct tt__MaximumNumberOfOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfigurationExtension(struct soap *soap, const struct tt__OSDConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationExtension, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDConfigurationExtension *p;
	struct tt__OSDConfigurationExtension *a = (struct tt__OSDConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfigurationExtension(struct soap *soap, const struct tt__OSDConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgOptionsExtension(struct soap *soap, const struct tt__OSDImgOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDImgOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDImgOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDImgOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptionsExtension, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(struct tt__OSDImgOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDImgOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDImgOptionsExtension *p;
	struct tt__OSDImgOptionsExtension *a = (struct tt__OSDImgOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgOptionsExtension(struct soap *soap, const struct tt__OSDImgOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDImgOptionsExtension(struct soap *soap, struct tt__OSDImgOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeImagePath = 0;
	a->ImagePath = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgOptions(struct soap *soap, const struct tt__OSDImgOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ImagePath)
	{	int i;
		for (i = 0; i < (int)a->__sizeImagePath; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ImagePath + i));
		}
	}
	soap_serialize_PointerTott__OSDImgOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDImgOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptions), type))
		return soap->error;
	if (a->ImagePath)
	{	int i;
		for (i = 0; i < (int)a->__sizeImagePath; i++)
			soap_out_string(soap, "tt:ImagePath", -1, (char*const*)(a->ImagePath + i), "");
	}
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgOptions * SOAP_FMAC4 soap_in_tt__OSDImgOptions(struct soap *soap, const char *tag, struct tt__OSDImgOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ImagePath = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDImgOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ImagePath", 1, NULL))
			{	if (a->ImagePath == NULL)
				{	if (soap_blist_ImagePath == NULL)
						soap_blist_ImagePath = soap_alloc_block(soap);
					a->ImagePath = (char **)soap_push_block_max(soap, soap_blist_ImagePath, sizeof(char *));
					if (a->ImagePath == NULL)
						return NULL;
					*a->ImagePath = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:ImagePath", (char**)a->ImagePath, "xsd:anyURI"))
				{	a->__sizeImagePath++;
					a->ImagePath = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDImgOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ImagePath)
			soap_pop_block(soap, soap_blist_ImagePath);
		if (a->__sizeImagePath)
		{	a->ImagePath = (char **)soap_save_block(soap, soap_blist_ImagePath, NULL, 1);
		}
		else
		{	a->ImagePath = NULL;
			if (soap_blist_ImagePath)
				soap_end_block(soap, soap_blist_ImagePath);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeImagePath < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDImgOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptions, SOAP_TYPE_tt__OSDImgOptions, sizeof(struct tt__OSDImgOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgOptions * SOAP_FMAC4 soap_new_tt__OSDImgOptions(struct soap *soap, int n)
{
	struct tt__OSDImgOptions *p;
	struct tt__OSDImgOptions *a = (struct tt__OSDImgOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgOptions(struct soap *soap, const struct tt__OSDImgOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgOptions * SOAP_FMAC4 soap_get_tt__OSDImgOptions(struct soap *soap, struct tt__OSDImgOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextOptionsExtension(struct soap *soap, const struct tt__OSDTextOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDTextOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDTextOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDTextOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptionsExtension, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(struct tt__OSDTextOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDTextOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDTextOptionsExtension *p;
	struct tt__OSDTextOptionsExtension *a = (struct tt__OSDTextOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextOptionsExtension(struct soap *soap, const struct tt__OSDTextOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDTextOptionsExtension(struct soap *soap, struct tt__OSDTextOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeType = 0;
	a->Type = NULL;
	a->FontSizeRange = NULL;
	a->__sizeDateFormat = 0;
	a->DateFormat = NULL;
	a->__sizeTimeFormat = 0;
	a->TimeFormat = NULL;
	a->FontColor = NULL;
	a->BackgroundColor = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextOptions(struct soap *soap, const struct tt__OSDTextOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Type + i));
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FontSizeRange);
	if (a->DateFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeDateFormat; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->DateFormat + i));
		}
	}
	if (a->TimeFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeTimeFormat; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->TimeFormat + i));
		}
	}
	soap_serialize_PointerTott__OSDColorOptions(soap, &a->FontColor);
	soap_serialize_PointerTott__OSDColorOptions(soap, &a->BackgroundColor);
	soap_serialize_PointerTott__OSDTextOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDTextOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptions), type))
		return soap->error;
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
			soap_out_string(soap, "tt:Type", -1, (char*const*)(a->Type + i), "");
	}
	if (soap_out_PointerTott__IntRange(soap, "tt:FontSizeRange", -1, &a->FontSizeRange, ""))
		return soap->error;
	if (a->DateFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeDateFormat; i++)
			soap_out_string(soap, "tt:DateFormat", -1, (char*const*)(a->DateFormat + i), "");
	}
	if (a->TimeFormat)
	{	int i;
		for (i = 0; i < (int)a->__sizeTimeFormat; i++)
			soap_out_string(soap, "tt:TimeFormat", -1, (char*const*)(a->TimeFormat + i), "");
	}
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", -1, &a->BackgroundColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_in_tt__OSDTextOptions(struct soap *soap, const char *tag, struct tt__OSDTextOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Type = NULL;
	size_t soap_flag_FontSizeRange = 1;
	struct soap_blist *soap_blist_DateFormat = NULL;
	struct soap_blist *soap_blist_TimeFormat = NULL;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_BackgroundColor = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDTextOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Type", 1, NULL))
			{	if (a->Type == NULL)
				{	if (soap_blist_Type == NULL)
						soap_blist_Type = soap_alloc_block(soap);
					a->Type = (char **)soap_push_block_max(soap, soap_blist_Type, sizeof(char *));
					if (a->Type == NULL)
						return NULL;
					*a->Type = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Type", (char**)a->Type, "xsd:string"))
				{	a->__sizeType++;
					a->Type = NULL;
					continue;
				}
			}
			if (soap_flag_FontSizeRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FontSizeRange", &a->FontSizeRange, "tt:IntRange"))
				{	soap_flag_FontSizeRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DateFormat", 1, NULL))
			{	if (a->DateFormat == NULL)
				{	if (soap_blist_DateFormat == NULL)
						soap_blist_DateFormat = soap_alloc_block(soap);
					a->DateFormat = (char **)soap_push_block_max(soap, soap_blist_DateFormat, sizeof(char *));
					if (a->DateFormat == NULL)
						return NULL;
					*a->DateFormat = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:DateFormat", (char**)a->DateFormat, "xsd:string"))
				{	a->__sizeDateFormat++;
					a->DateFormat = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TimeFormat", 1, NULL))
			{	if (a->TimeFormat == NULL)
				{	if (soap_blist_TimeFormat == NULL)
						soap_blist_TimeFormat = soap_alloc_block(soap);
					a->TimeFormat = (char **)soap_push_block_max(soap, soap_blist_TimeFormat, sizeof(char *));
					if (a->TimeFormat == NULL)
						return NULL;
					*a->TimeFormat = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:TimeFormat", (char**)a->TimeFormat, "xsd:string"))
				{	a->__sizeTimeFormat++;
					a->TimeFormat = NULL;
					continue;
				}
			}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDColorOptions(soap, "tt:FontColor", &a->FontColor, "tt:OSDColorOptions"))
				{	soap_flag_FontColor--;
					continue;
				}
			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", &a->BackgroundColor, "tt:OSDColorOptions"))
				{	soap_flag_BackgroundColor--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDTextOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Type)
			soap_pop_block(soap, soap_blist_Type);
		if (a->__sizeType)
		{	a->Type = (char **)soap_save_block(soap, soap_blist_Type, NULL, 1);
		}
		else
		{	a->Type = NULL;
			if (soap_blist_Type)
				soap_end_block(soap, soap_blist_Type);
		}
		if (a->DateFormat)
			soap_pop_block(soap, soap_blist_DateFormat);
		if (a->__sizeDateFormat)
		{	a->DateFormat = (char **)soap_save_block(soap, soap_blist_DateFormat, NULL, 1);
		}
		else
		{	a->DateFormat = NULL;
			if (soap_blist_DateFormat)
				soap_end_block(soap, soap_blist_DateFormat);
		}
		if (a->TimeFormat)
			soap_pop_block(soap, soap_blist_TimeFormat);
		if (a->__sizeTimeFormat)
		{	a->TimeFormat = (char **)soap_save_block(soap, soap_blist_TimeFormat, NULL, 1);
		}
		else
		{	a->TimeFormat = NULL;
			if (soap_blist_TimeFormat)
				soap_end_block(soap, soap_blist_TimeFormat);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeType < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDTextOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptions, SOAP_TYPE_tt__OSDTextOptions, sizeof(struct tt__OSDTextOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_new_tt__OSDTextOptions(struct soap *soap, int n)
{
	struct tt__OSDTextOptions *p;
	struct tt__OSDTextOptions *a = (struct tt__OSDTextOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextOptions(struct soap *soap, const struct tt__OSDTextOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextOptions * SOAP_FMAC4 soap_get_tt__OSDTextOptions(struct soap *soap, struct tt__OSDTextOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColorOptionsExtension(struct soap *soap, const struct tt__OSDColorOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDColorOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, struct tt__OSDColorOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDColorOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColorOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptionsExtension, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(struct tt__OSDColorOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_new_tt__OSDColorOptionsExtension(struct soap *soap, int n)
{
	struct tt__OSDColorOptionsExtension *p;
	struct tt__OSDColorOptionsExtension *a = (struct tt__OSDColorOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColorOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColorOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColorOptionsExtension(struct soap *soap, const struct tt__OSDColorOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDColorOptionsExtension(struct soap *soap, struct tt__OSDColorOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Transparent = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColorOptions(struct soap *soap, const struct tt__OSDColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorOptions(soap, &a->Color);
	soap_serialize_PointerTott__IntRange(soap, &a->Transparent);
	soap_serialize_PointerTott__OSDColorOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptions(struct soap *soap, const char *tag, int id, const struct tt__OSDColorOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptions), type))
		return soap->error;
	if (soap_out_PointerTott__ColorOptions(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:Transparent", -1, &a->Transparent, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_in_tt__OSDColorOptions(struct soap *soap, const char *tag, struct tt__OSDColorOptions *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Transparent = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDColorOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColorOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorOptions(soap, "tt:Color", &a->Color, "tt:ColorOptions"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Transparent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:Transparent", &a->Transparent, "tt:IntRange"))
				{	soap_flag_Transparent--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:OSDColorOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptions, SOAP_TYPE_tt__OSDColorOptions, sizeof(struct tt__OSDColorOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_new_tt__OSDColorOptions(struct soap *soap, int n)
{
	struct tt__OSDColorOptions *p;
	struct tt__OSDColorOptions *a = (struct tt__OSDColorOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColorOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColorOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColorOptions(struct soap *soap, const struct tt__OSDColorOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColorOptions * SOAP_FMAC4 soap_get_tt__OSDColorOptions(struct soap *soap, struct tt__OSDColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorOptions(struct soap *soap, struct tt__ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorList = 0;
	a->ColorList = NULL;
	a->__sizeColorspaceRange = 0;
	a->ColorspaceRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorOptions(struct soap *soap, const struct tt__ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ColorList)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorList; i++)
		{
			soap_embedded(soap, a->ColorList + i, SOAP_TYPE_tt__Color);
			soap_serialize_tt__Color(soap, a->ColorList + i);
		}
	}
	if (a->ColorspaceRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorspaceRange; i++)
		{
			soap_embedded(soap, a->ColorspaceRange + i, SOAP_TYPE_tt__ColorspaceRange);
			soap_serialize_tt__ColorspaceRange(soap, a->ColorspaceRange + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorOptions(struct soap *soap, const char *tag, int id, const struct tt__ColorOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorOptions), type))
		return soap->error;
	if (a->ColorList)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorList; i++)
			if (soap_out_tt__Color(soap, "tt:ColorList", -1, a->ColorList + i, ""))
				return soap->error;
	}
	if (a->ColorspaceRange)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorspaceRange; i++)
			if (soap_out_tt__ColorspaceRange(soap, "tt:ColorspaceRange", -1, a->ColorspaceRange + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_in_tt__ColorOptions(struct soap *soap, const char *tag, struct tt__ColorOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ColorList = NULL;
	struct soap_blist *soap_blist_ColorspaceRange = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorList", 1, NULL))
			{	if (a->ColorList == NULL)
				{	if (soap_blist_ColorList == NULL)
						soap_blist_ColorList = soap_alloc_block(soap);
					a->ColorList = (struct tt__Color *)soap_push_block_max(soap, soap_blist_ColorList, sizeof(struct tt__Color));
					if (a->ColorList == NULL)
						return NULL;
					soap_default_tt__Color(soap, a->ColorList);
				}
				soap_revert(soap);
				if (soap_in_tt__Color(soap, "tt:ColorList", a->ColorList, "tt:Color"))
				{	a->__sizeColorList++;
					a->ColorList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorspaceRange", 1, NULL))
			{	if (a->ColorspaceRange == NULL)
				{	if (soap_blist_ColorspaceRange == NULL)
						soap_blist_ColorspaceRange = soap_alloc_block(soap);
					a->ColorspaceRange = (struct tt__ColorspaceRange *)soap_push_block_max(soap, soap_blist_ColorspaceRange, sizeof(struct tt__ColorspaceRange));
					if (a->ColorspaceRange == NULL)
						return NULL;
					soap_default_tt__ColorspaceRange(soap, a->ColorspaceRange);
				}
				soap_revert(soap);
				if (soap_in_tt__ColorspaceRange(soap, "tt:ColorspaceRange", a->ColorspaceRange, "tt:ColorspaceRange"))
				{	a->__sizeColorspaceRange++;
					a->ColorspaceRange = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorList)
			soap_pop_block(soap, soap_blist_ColorList);
		if (a->__sizeColorList)
		{	a->ColorList = (struct tt__Color *)soap_save_block(soap, soap_blist_ColorList, NULL, 1);
		}
		else
		{	a->ColorList = NULL;
			if (soap_blist_ColorList)
				soap_end_block(soap, soap_blist_ColorList);
		}
		if (a->ColorspaceRange)
			soap_pop_block(soap, soap_blist_ColorspaceRange);
		if (a->__sizeColorspaceRange)
		{	a->ColorspaceRange = (struct tt__ColorspaceRange *)soap_save_block(soap, soap_blist_ColorspaceRange, NULL, 1);
		}
		else
		{	a->ColorspaceRange = NULL;
			if (soap_blist_ColorspaceRange)
				soap_end_block(soap, soap_blist_ColorspaceRange);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorOptions, SOAP_TYPE_tt__ColorOptions, sizeof(struct tt__ColorOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_new_tt__ColorOptions(struct soap *soap, int n)
{
	struct tt__ColorOptions *p;
	struct tt__ColorOptions *a = (struct tt__ColorOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorOptions(struct soap *soap, const struct tt__ColorOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorOptions * SOAP_FMAC4 soap_get_tt__ColorOptions(struct soap *soap, struct tt__ColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X = NULL;
	a->Y = NULL;
	a->Z = NULL;
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorspaceRange(struct soap *soap, const struct tt__ColorspaceRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->X);
	soap_serialize_PointerTott__FloatRange(soap, &a->Y);
	soap_serialize_PointerTott__FloatRange(soap, &a->Z);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Colorspace);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorspaceRange(struct soap *soap, const char *tag, int id, const struct tt__ColorspaceRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorspaceRange), type))
		return soap->error;
	if (!a->X)
	{	if (soap_element_nil(soap, "tt:X"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:X", -1, &a->X, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_nil(soap, "tt:Y"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:Y", -1, &a->Y, ""))
		return soap->error;
	if (!a->Z)
	{	if (soap_element_nil(soap, "tt:Z"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:Z", -1, &a->Z, ""))
		return soap->error;
	if (!a->Colorspace)
	{	if (soap_element_nil(soap, "tt:Colorspace"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:Colorspace", -1, (char*const*)&a->Colorspace, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_in_tt__ColorspaceRange(struct soap *soap, const char *tag, struct tt__ColorspaceRange *a, const char *type)
{
	size_t soap_flag_X = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_Z = 1;
	size_t soap_flag_Colorspace = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorspaceRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorspaceRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:X", &a->X, "tt:FloatRange"))
				{	soap_flag_X--;
					continue;
				}
			if (soap_flag_Y && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Y", &a->Y, "tt:FloatRange"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_Z && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Z", &a->Z, "tt:FloatRange"))
				{	soap_flag_Z--;
					continue;
				}
			if (soap_flag_Colorspace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:Colorspace", (char**)&a->Colorspace, "xsd:anyURI"))
				{	soap_flag_Colorspace--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X > 0 || soap_flag_Y > 0 || soap_flag_Z > 0 || soap_flag_Colorspace > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ColorspaceRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_tt__ColorspaceRange, sizeof(struct tt__ColorspaceRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_new_tt__ColorspaceRange(struct soap *soap, int n)
{
	struct tt__ColorspaceRange *p;
	struct tt__ColorspaceRange *a = (struct tt__ColorspaceRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorspaceRange));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorspaceRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorspaceRange(struct soap *soap, const struct tt__ColorspaceRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorspaceRange * SOAP_FMAC4 soap_get_tt__ColorspaceRange(struct soap *soap, struct tt__ColorspaceRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgConfigurationExtension(struct soap *soap, const struct tt__OSDImgConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDImgConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDImgConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDImgConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfigurationExtension, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(struct tt__OSDImgConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDImgConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDImgConfigurationExtension *p;
	struct tt__OSDImgConfigurationExtension *a = (struct tt__OSDImgConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgConfigurationExtension(struct soap *soap, const struct tt__OSDImgConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDImgConfigurationExtension(struct soap *soap, struct tt__OSDImgConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->ImgPath);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDImgConfiguration(struct soap *soap, const struct tt__OSDImgConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ImgPath);
	soap_serialize_PointerTott__OSDImgConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDImgConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfiguration), type))
		return soap->error;
	if (!a->ImgPath)
	{	if (soap_element_nil(soap, "tt:ImgPath"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:ImgPath", -1, (char*const*)&a->ImgPath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_in_tt__OSDImgConfiguration(struct soap *soap, const char *tag, struct tt__OSDImgConfiguration *a, const char *type)
{
	size_t soap_flag_ImgPath = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDImgConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDImgConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImgPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:ImgPath", (char**)&a->ImgPath, "xsd:anyURI"))
				{	soap_flag_ImgPath--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDImgConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImgPath > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfiguration, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_new_tt__OSDImgConfiguration(struct soap *soap, int n)
{
	struct tt__OSDImgConfiguration *p;
	struct tt__OSDImgConfiguration *a = (struct tt__OSDImgConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDImgConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDImgConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDImgConfiguration(struct soap *soap, const struct tt__OSDImgConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration * SOAP_FMAC4 soap_get_tt__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextConfigurationExtension(struct soap *soap, const struct tt__OSDTextConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDTextConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDTextConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDTextConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfigurationExtension, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(struct tt__OSDTextConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDTextConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDTextConfigurationExtension *p;
	struct tt__OSDTextConfigurationExtension *a = (struct tt__OSDTextConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextConfigurationExtension(struct soap *soap, const struct tt__OSDTextConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDTextConfigurationExtension(struct soap *soap, struct tt__OSDTextConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->DateFormat);
	soap_default_string(soap, &a->TimeFormat);
	a->FontSize = NULL;
	a->FontColor = NULL;
	a->BackgroundColor = NULL;
	soap_default_string(soap, &a->PlainText);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDTextConfiguration(struct soap *soap, const struct tt__OSDTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_string(soap, (char*const*)&a->DateFormat);
	soap_serialize_string(soap, (char*const*)&a->TimeFormat);
	soap_serialize_PointerToint(soap, &a->FontSize);
	soap_serialize_PointerTott__OSDColor(soap, &a->FontColor);
	soap_serialize_PointerTott__OSDColor(soap, &a->BackgroundColor);
	soap_serialize_string(soap, (char*const*)&a->PlainText);
	soap_serialize_PointerTott__OSDTextConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDTextConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfiguration), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_nil(soap, "tt:Type"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DateFormat", -1, (char*const*)&a->DateFormat, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:TimeFormat", -1, (char*const*)&a->TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:FontSize", -1, &a->FontSize, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:FontColor", -1, &a->FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:BackgroundColor", -1, &a->BackgroundColor, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:PlainText", -1, (char*const*)&a->PlainText, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_in_tt__OSDTextConfiguration(struct soap *soap, const char *tag, struct tt__OSDTextConfiguration *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_DateFormat = 1;
	size_t soap_flag_TimeFormat = 1;
	size_t soap_flag_FontSize = 1;
	size_t soap_flag_FontColor = 1;
	size_t soap_flag_BackgroundColor = 1;
	size_t soap_flag_PlainText = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDTextConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDTextConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_DateFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DateFormat", (char**)&a->DateFormat, "xsd:string"))
				{	soap_flag_DateFormat--;
					continue;
				}
			if (soap_flag_TimeFormat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:TimeFormat", (char**)&a->TimeFormat, "xsd:string"))
				{	soap_flag_TimeFormat--;
					continue;
				}
			if (soap_flag_FontSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:FontSize", &a->FontSize, "xsd:int"))
				{	soap_flag_FontSize--;
					continue;
				}
			if (soap_flag_FontColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDColor(soap, "tt:FontColor", &a->FontColor, "tt:OSDColor"))
				{	soap_flag_FontColor--;
					continue;
				}
			if (soap_flag_BackgroundColor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDColor(soap, "tt:BackgroundColor", &a->BackgroundColor, "tt:OSDColor"))
				{	soap_flag_BackgroundColor--;
					continue;
				}
			if (soap_flag_PlainText && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:PlainText", (char**)&a->PlainText, "xsd:string"))
				{	soap_flag_PlainText--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDTextConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfiguration, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_new_tt__OSDTextConfiguration(struct soap *soap, int n)
{
	struct tt__OSDTextConfiguration *p;
	struct tt__OSDTextConfiguration *a = (struct tt__OSDTextConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDTextConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDTextConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDTextConfiguration(struct soap *soap, const struct tt__OSDTextConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration * SOAP_FMAC4 soap_get_tt__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDColor(struct soap *soap, struct tt__OSDColor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Transparent = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDColor(struct soap *soap, const struct tt__OSDColor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &a->Color);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColor(struct soap *soap, const char *tag, int id, const struct tt__OSDColor *a, const char *type)
{
	if (a->Transparent)
		soap_set_attr(soap, "Transparent", soap_int2s(soap, *a->Transparent), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColor), type))
		return soap->error;
	if (!a->Color)
	{	if (soap_element_nil(soap, "tt:Color"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_in_tt__OSDColor(struct soap *soap, const char *tag, struct tt__OSDColor *a, const char *type)
{
	size_t soap_flag_Color = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDColor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDColor(soap, a);
	{	const char *t = soap_attr_value(soap, "Transparent", 0);
		if (t)
		{
			if (!(a->Transparent = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Transparent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Color(soap, "tt:Color", &a->Color, "tt:Color"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Color > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDColor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColor, SOAP_TYPE_tt__OSDColor, sizeof(struct tt__OSDColor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_new_tt__OSDColor(struct soap *soap, int n)
{
	struct tt__OSDColor *p;
	struct tt__OSDColor *a = (struct tt__OSDColor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDColor));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDColor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDColor(struct soap *soap, const struct tt__OSDColor *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDColor * SOAP_FMAC4 soap_get_tt__OSDColor(struct soap *soap, struct tt__OSDColor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDPosConfigurationExtension(struct soap *soap, const struct tt__OSDPosConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__OSDPosConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDPosConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDPosConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDPosConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfigurationExtension, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(struct tt__OSDPosConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_new_tt__OSDPosConfigurationExtension(struct soap *soap, int n)
{
	struct tt__OSDPosConfigurationExtension *p;
	struct tt__OSDPosConfigurationExtension *a = (struct tt__OSDPosConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDPosConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDPosConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDPosConfigurationExtension(struct soap *soap, const struct tt__OSDPosConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDPosConfigurationExtension(struct soap *soap, struct tt__OSDPosConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	a->Pos = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDPosConfiguration(struct soap *soap, const struct tt__OSDPosConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_PointerTott__Vector(soap, &a->Pos);
	soap_serialize_PointerTott__OSDPosConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDPosConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfiguration), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_nil(soap, "tt:Type"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Pos", -1, &a->Pos, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_in_tt__OSDPosConfiguration(struct soap *soap, const char *tag, struct tt__OSDPosConfiguration *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Pos = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDPosConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDPosConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Pos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Pos", &a->Pos, "tt:Vector"))
				{	soap_flag_Pos--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDPosConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfiguration, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_new_tt__OSDPosConfiguration(struct soap *soap, int n)
{
	struct tt__OSDPosConfiguration *p;
	struct tt__OSDPosConfiguration *a = (struct tt__OSDPosConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDPosConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDPosConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDPosConfiguration(struct soap *soap, const struct tt__OSDPosConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration * SOAP_FMAC4 soap_get_tt__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileStatusExtension(struct soap *soap, const struct tt__ProfileStatusExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatusExtension(struct soap *soap, const char *tag, int id, const struct tt__ProfileStatusExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatusExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_in_tt__ProfileStatusExtension(struct soap *soap, const char *tag, struct tt__ProfileStatusExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileStatusExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileStatusExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatusExtension, SOAP_TYPE_tt__ProfileStatusExtension, sizeof(struct tt__ProfileStatusExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_new_tt__ProfileStatusExtension(struct soap *soap, int n)
{
	struct tt__ProfileStatusExtension *p;
	struct tt__ProfileStatusExtension *a = (struct tt__ProfileStatusExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileStatusExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileStatusExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileStatusExtension(struct soap *soap, const struct tt__ProfileStatusExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileStatusExtension(soap, tag ? tag : "tt:ProfileStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatusExtension * SOAP_FMAC4 soap_get_tt__ProfileStatusExtension(struct soap *soap, struct tt__ProfileStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileStatus(struct soap *soap, struct tt__ProfileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActiveConnections = 0;
	a->ActiveConnections = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileStatus(struct soap *soap, const struct tt__ProfileStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActiveConnections)
	{	int i;
		for (i = 0; i < (int)a->__sizeActiveConnections; i++)
		{
			soap_embedded(soap, a->ActiveConnections + i, SOAP_TYPE_tt__ActiveConnection);
			soap_serialize_tt__ActiveConnection(soap, a->ActiveConnections + i);
		}
	}
	soap_serialize_PointerTott__ProfileStatusExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileStatus(struct soap *soap, const char *tag, int id, const struct tt__ProfileStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileStatus), type))
		return soap->error;
	if (a->ActiveConnections)
	{	int i;
		for (i = 0; i < (int)a->__sizeActiveConnections; i++)
			if (soap_out_tt__ActiveConnection(soap, "tt:ActiveConnections", -1, a->ActiveConnections + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ProfileStatusExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_in_tt__ProfileStatus(struct soap *soap, const char *tag, struct tt__ProfileStatus *a, const char *type)
{
	struct soap_blist *soap_blist_ActiveConnections = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ActiveConnections", 1, NULL))
			{	if (a->ActiveConnections == NULL)
				{	if (soap_blist_ActiveConnections == NULL)
						soap_blist_ActiveConnections = soap_alloc_block(soap);
					a->ActiveConnections = (struct tt__ActiveConnection *)soap_push_block_max(soap, soap_blist_ActiveConnections, sizeof(struct tt__ActiveConnection));
					if (a->ActiveConnections == NULL)
						return NULL;
					soap_default_tt__ActiveConnection(soap, a->ActiveConnections);
				}
				soap_revert(soap);
				if (soap_in_tt__ActiveConnection(soap, "tt:ActiveConnections", a->ActiveConnections, "tt:ActiveConnection"))
				{	a->__sizeActiveConnections++;
					a->ActiveConnections = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileStatusExtension(soap, "tt:Extension", &a->Extension, "tt:ProfileStatusExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActiveConnections)
			soap_pop_block(soap, soap_blist_ActiveConnections);
		if (a->__sizeActiveConnections)
		{	a->ActiveConnections = (struct tt__ActiveConnection *)soap_save_block(soap, soap_blist_ActiveConnections, NULL, 1);
		}
		else
		{	a->ActiveConnections = NULL;
			if (soap_blist_ActiveConnections)
				soap_end_block(soap, soap_blist_ActiveConnections);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileStatus, SOAP_TYPE_tt__ProfileStatus, sizeof(struct tt__ProfileStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_new_tt__ProfileStatus(struct soap *soap, int n)
{
	struct tt__ProfileStatus *p;
	struct tt__ProfileStatus *a = (struct tt__ProfileStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileStatus(struct soap *soap, const struct tt__ProfileStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileStatus(soap, tag ? tag : "tt:ProfileStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileStatus * SOAP_FMAC4 soap_get_tt__ProfileStatus(struct soap *soap, struct tt__ProfileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->CurrentBitrate);
	soap_default_float(soap, &a->CurrentFps);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActiveConnection(struct soap *soap, const struct tt__ActiveConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CurrentBitrate, SOAP_TYPE_float);
	soap_embedded(soap, &a->CurrentFps, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActiveConnection(struct soap *soap, const char *tag, int id, const struct tt__ActiveConnection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActiveConnection), type))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentBitrate", -1, &a->CurrentBitrate, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CurrentFps", -1, &a->CurrentFps, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_in_tt__ActiveConnection(struct soap *soap, const char *tag, struct tt__ActiveConnection *a, const char *type)
{
	size_t soap_flag_CurrentBitrate = 1;
	size_t soap_flag_CurrentFps = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ActiveConnection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActiveConnection(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:CurrentBitrate", &a->CurrentBitrate, "xsd:float"))
				{	soap_flag_CurrentBitrate--;
					continue;
				}
			if (soap_flag_CurrentFps && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:CurrentFps", &a->CurrentFps, "xsd:float"))
				{	soap_flag_CurrentFps--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentBitrate > 0 || soap_flag_CurrentFps > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ActiveConnection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_tt__ActiveConnection, sizeof(struct tt__ActiveConnection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_new_tt__ActiveConnection(struct soap *soap, int n)
{
	struct tt__ActiveConnection *p;
	struct tt__ActiveConnection *a = (struct tt__ActiveConnection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActiveConnection));
	for (p = a; p && n--; p++)
		soap_default_tt__ActiveConnection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActiveConnection(struct soap *soap, const struct tt__ActiveConnection *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActiveConnection(soap, tag ? tag : "tt:ActiveConnection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActiveConnection * SOAP_FMAC4 soap_get_tt__ActiveConnection(struct soap *soap, struct tt__ActiveConnection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActiveConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassDescriptorExtension(struct soap *soap, const struct tt__AudioClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioClassDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__AudioClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__AudioClassDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioClassDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptorExtension, SOAP_TYPE_tt__AudioClassDescriptorExtension, sizeof(struct tt__AudioClassDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_new_tt__AudioClassDescriptorExtension(struct soap *soap, int n)
{
	struct tt__AudioClassDescriptorExtension *p;
	struct tt__AudioClassDescriptorExtension *a = (struct tt__AudioClassDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassDescriptorExtension(struct soap *soap, const struct tt__AudioClassDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassDescriptorExtension(soap, tag ? tag : "tt:AudioClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__AudioClassDescriptorExtension(struct soap *soap, struct tt__AudioClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassDescriptor(struct soap *soap, struct tt__AudioClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassDescriptor(struct soap *soap, const struct tt__AudioClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE_tt__AudioClassCandidate);
			soap_serialize_tt__AudioClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTott__AudioClassDescriptorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassDescriptor(struct soap *soap, const char *tag, int id, const struct tt__AudioClassDescriptor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
			if (soap_out_tt__AudioClassCandidate(soap, "tt:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_in_tt__AudioClassDescriptor(struct soap *soap, const char *tag, struct tt__AudioClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioClassDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassDescriptor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_alloc_block(soap);
					a->ClassCandidate = (struct tt__AudioClassCandidate *)soap_push_block_max(soap, soap_blist_ClassCandidate, sizeof(struct tt__AudioClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default_tt__AudioClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioClassCandidate(soap, "tt:ClassCandidate", a->ClassCandidate, "tt:AudioClassCandidate"))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioClassDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:AudioClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
		{	a->ClassCandidate = (struct tt__AudioClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		}
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassDescriptor, SOAP_TYPE_tt__AudioClassDescriptor, sizeof(struct tt__AudioClassDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_new_tt__AudioClassDescriptor(struct soap *soap, int n)
{
	struct tt__AudioClassDescriptor *p;
	struct tt__AudioClassDescriptor *a = (struct tt__AudioClassDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassDescriptor(struct soap *soap, const struct tt__AudioClassDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassDescriptor(soap, tag ? tag : "tt:AudioClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassDescriptor * SOAP_FMAC4 soap_get_tt__AudioClassDescriptor(struct soap *soap, struct tt__AudioClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AudioClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioClassCandidate(struct soap *soap, const struct tt__AudioClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AudioClassType(soap, (char*const*)&a->Type);
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioClassCandidate(struct soap *soap, const char *tag, int id, const struct tt__AudioClassCandidate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioClassCandidate), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_nil(soap, "tt:Type"))
			return soap->error;
	}
	else
	if (soap_out_tt__AudioClassType(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_in_tt__AudioClassCandidate(struct soap *soap, const char *tag, struct tt__AudioClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioClassCandidate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioClassCandidate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AudioClassType(soap, "tt:Type", (char**)&a->Type, "tt:AudioClassType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_tt__AudioClassCandidate, sizeof(struct tt__AudioClassCandidate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_new_tt__AudioClassCandidate(struct soap *soap, int n)
{
	struct tt__AudioClassCandidate *p;
	struct tt__AudioClassCandidate *a = (struct tt__AudioClassCandidate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioClassCandidate));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioClassCandidate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioClassCandidate(struct soap *soap, const struct tt__AudioClassCandidate *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioClassCandidate(soap, tag ? tag : "tt:AudioClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioClassCandidate * SOAP_FMAC4 soap_get_tt__AudioClassCandidate(struct soap *soap, struct tt__AudioClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActionEngineEventPayloadExtension(struct soap *soap, const struct tt__ActionEngineEventPayloadExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, const struct tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayloadExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ActionEngineEventPayloadExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActionEngineEventPayloadExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayloadExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_new_tt__ActionEngineEventPayloadExtension(struct soap *soap, int n)
{
	struct tt__ActionEngineEventPayloadExtension *p;
	struct tt__ActionEngineEventPayloadExtension *a = (struct tt__ActionEngineEventPayloadExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActionEngineEventPayloadExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ActionEngineEventPayloadExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActionEngineEventPayloadExtension(struct soap *soap, const struct tt__ActionEngineEventPayloadExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActionEngineEventPayloadExtension(soap, tag ? tag : "tt:ActionEngineEventPayloadExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ActionEngineEventPayload(struct soap *soap, struct tt__ActionEngineEventPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RequestInfo = NULL;
	a->ResponseInfo = NULL;
	a->Fault = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ActionEngineEventPayload(struct soap *soap, const struct tt__ActionEngineEventPayload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &a->RequestInfo);
	soap_serialize_PointerToSOAP_ENV__Envelope(soap, &a->ResponseInfo);
	soap_serialize_PointerToSOAP_ENV__Fault(soap, &a->Fault);
	soap_serialize_PointerTott__ActionEngineEventPayloadExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, int id, const struct tt__ActionEngineEventPayload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ActionEngineEventPayload), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", -1, &a->RequestInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", -1, &a->ResponseInfo, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Fault(soap, "tt:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_in_tt__ActionEngineEventPayload(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayload *a, const char *type)
{
	size_t soap_flag_RequestInfo = 1;
	size_t soap_flag_ResponseInfo = 1;
	size_t soap_flag_Fault = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ActionEngineEventPayload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ActionEngineEventPayload(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RequestInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:RequestInfo", &a->RequestInfo, ""))
				{	soap_flag_RequestInfo--;
					continue;
				}
			if (soap_flag_ResponseInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Envelope(soap, "tt:ResponseInfo", &a->ResponseInfo, ""))
				{	soap_flag_ResponseInfo--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Fault(soap, "tt:Fault", &a->Fault, ""))
				{	soap_flag_Fault--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, "tt:Extension", &a->Extension, "tt:ActionEngineEventPayloadExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ActionEngineEventPayload, SOAP_TYPE_tt__ActionEngineEventPayload, sizeof(struct tt__ActionEngineEventPayload), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_new_tt__ActionEngineEventPayload(struct soap *soap, int n)
{
	struct tt__ActionEngineEventPayload *p;
	struct tt__ActionEngineEventPayload *a = (struct tt__ActionEngineEventPayload*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ActionEngineEventPayload));
	for (p = a; p && n--; p++)
		soap_default_tt__ActionEngineEventPayload(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ActionEngineEventPayload(struct soap *soap, const struct tt__ActionEngineEventPayload *a, const char *tag, const char *type)
{
	if (soap_out_tt__ActionEngineEventPayload(soap, tag ? tag : "tt:ActionEngineEventPayload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayload * SOAP_FMAC4 soap_get_tt__ActionEngineEventPayload(struct soap *soap, struct tt__ActionEngineEventPayload *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ActionEngineEventPayload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Error);
	soap_default_string(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_serialize_string(soap, (char*const*)&a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsState(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsState), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_nil(soap, "tt:State"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_in_tt__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState *a, const char *type)
{
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:State", (char**)&a->State, "xsd:string"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsState, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_new_tt__AnalyticsState(struct soap *soap, int n)
{
	struct tt__AnalyticsState *p;
	struct tt__AnalyticsState *a = (struct tt__AnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsState));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsState(soap, tag ? tag : "tt:AnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_get_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
	soap_serialize_PointerTott__AnalyticsState(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsStateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsStateInformation), type))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_nil(soap, "tt:AnalyticsEngineControlToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_nil(soap, "tt:State"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_in_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, struct tt__AnalyticsStateInformation *a, const char *type)
{
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsStateInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsState(soap, "tt:State", &a->State, "tt:AnalyticsState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AnalyticsEngineControlToken > 0 || soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsStateInformation, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_new_tt__AnalyticsStateInformation(struct soap *soap, int n)
{
	struct tt__AnalyticsStateInformation *p;
	struct tt__AnalyticsStateInformation *a = (struct tt__AnalyticsStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsStateInformation(soap, tag ? tag : "tt:AnalyticsStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_get_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInputExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataInputExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInputExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_in_tt__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataInputExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInputExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInputExtension, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_new_tt__MetadataInputExtension(struct soap *soap, int n)
{
	struct tt__MetadataInputExtension *p;
	struct tt__MetadataInputExtension *a = (struct tt__MetadataInputExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataInputExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataInputExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataInputExtension(soap, tag ? tag : "tt:MetadataInputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_get_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMetadataConfig = 0;
	a->MetadataConfig = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < (int)a->__sizeMetadataConfig; i++)
		{
			soap_embedded(soap, a->MetadataConfig + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->MetadataConfig + i);
		}
	}
	soap_serialize_PointerTott__MetadataInputExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInput(struct soap *soap, const char *tag, int id, const struct tt__MetadataInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInput), type))
		return soap->error;
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < (int)a->__sizeMetadataConfig; i++)
			if (soap_out_tt__Config(soap, "tt:MetadataConfig", -1, a->MetadataConfig + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MetadataInputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_in_tt__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput *a, const char *type)
{
	struct soap_blist *soap_blist_MetadataConfig = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:MetadataConfig", 1, NULL))
			{	if (a->MetadataConfig == NULL)
				{	if (soap_blist_MetadataConfig == NULL)
						soap_blist_MetadataConfig = soap_alloc_block(soap);
					a->MetadataConfig = (struct tt__Config *)soap_push_block_max(soap, soap_blist_MetadataConfig, sizeof(struct tt__Config));
					if (a->MetadataConfig == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->MetadataConfig);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:MetadataConfig", a->MetadataConfig, "tt:Config"))
				{	a->__sizeMetadataConfig++;
					a->MetadataConfig = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataInputExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataInputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MetadataConfig)
			soap_pop_block(soap, soap_blist_MetadataConfig);
		if (a->__sizeMetadataConfig)
		{	a->MetadataConfig = (struct tt__Config *)soap_save_block(soap, soap_blist_MetadataConfig, NULL, 1);
		}
		else
		{	a->MetadataConfig = NULL;
			if (soap_blist_MetadataConfig)
				soap_end_block(soap, soap_blist_MetadataConfig);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInput, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_new_tt__MetadataInput(struct soap *soap, int n)
{
	struct tt__MetadataInput *p;
	struct tt__MetadataInput *a = (struct tt__MetadataInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataInput));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_get_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentificationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentificationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_in_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SourceIdentificationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentificationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentificationExtension, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_new_tt__SourceIdentificationExtension(struct soap *soap, int n)
{
	struct tt__SourceIdentificationExtension *p;
	struct tt__SourceIdentificationExtension *a = (struct tt__SourceIdentificationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceIdentificationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceIdentificationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceIdentificationExtension(soap, tag ? tag : "tt:SourceIdentificationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_get_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->__sizeToken = 0;
	a->Token = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
	soap_serialize_PointerTott__SourceIdentificationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentification(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentification), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "tt:Token", -1, (char*const*)(a->Token + i), "");
	}
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_in_tt__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification *a, const char *type)
{
	size_t soap_flag_Name = 1;
	struct soap_blist *soap_blist_Token = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SourceIdentification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentification(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", (char**)a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", &a->Extension, "tt:SourceIdentificationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentification, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_new_tt__SourceIdentification(struct soap *soap, int n)
{
	struct tt__SourceIdentification *p;
	struct tt__SourceIdentification *a = (struct tt__SourceIdentification*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SourceIdentification));
	for (p = a; p && n--; p++)
		soap_default_tt__SourceIdentification(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a, const char *tag, const char *type)
{
	if (soap_out_tt__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_get_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfoExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInputInfoExtension *p;
	struct tt__AnalyticsEngineInputInfoExtension *a = (struct tt__AnalyticsEngineInputInfoExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInputInfoExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInputInfoExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag ? tag : "tt:AnalyticsEngineInputInfoExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputInfo = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Config(soap, &a->InputInfo);
	soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo), type))
		return soap->error;
	if (soap_out_PointerTott__Config(soap, "tt:InputInfo", -1, &a->InputInfo, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	size_t soap_flag_InputInfo = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Config(soap, "tt:InputInfo", &a->InputInfo, "tt:Config"))
				{	soap_flag_InputInfo--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineInputInfoExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfo, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInputInfo(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInputInfo *p;
	struct tt__AnalyticsEngineInputInfo *a = (struct tt__AnalyticsEngineInputInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInputInfo));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInputInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInputInfo(soap, tag ? tag : "tt:AnalyticsEngineInputInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceEngineConfigurationExtension *p;
	struct tt__AnalyticsDeviceEngineConfigurationExtension *a = (struct tt__AnalyticsDeviceEngineConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoAnalyticsConfiguration = NULL;
	a->AnalyticsEngineInputInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EngineConfiguration(struct soap *soap, const struct tt__EngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__AnalyticsEngineInputInfo(soap, &a->AnalyticsEngineInputInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__EngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EngineConfiguration), type))
		return soap->error;
	if (!a->VideoAnalyticsConfiguration)
	{	if (soap_element_nil(soap, "tt:VideoAnalyticsConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (!a->AnalyticsEngineInputInfo)
	{	if (soap_element_nil(soap, "tt:AnalyticsEngineInputInfo"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", -1, &a->AnalyticsEngineInputInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_in_tt__EngineConfiguration(struct soap *soap, const char *tag, struct tt__EngineConfiguration *a, const char *type)
{
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_AnalyticsEngineInputInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EngineConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration--;
					continue;
				}
			if (soap_flag_AnalyticsEngineInputInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", &a->AnalyticsEngineInputInfo, "tt:AnalyticsEngineInputInfo"))
				{	soap_flag_AnalyticsEngineInputInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoAnalyticsConfiguration > 0 || soap_flag_AnalyticsEngineInputInfo > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__EngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EngineConfiguration, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_new_tt__EngineConfiguration(struct soap *soap, int n)
{
	struct tt__EngineConfiguration *p;
	struct tt__EngineConfiguration *a = (struct tt__EngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__EngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EngineConfiguration(struct soap *soap, const struct tt__EngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__EngineConfiguration(soap, tag ? tag : "tt:EngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_get_tt__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEngineConfiguration = 0;
	a->EngineConfiguration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EngineConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizeEngineConfiguration; i++)
		{
			soap_embedded(soap, a->EngineConfiguration + i, SOAP_TYPE_tt__EngineConfiguration);
			soap_serialize_tt__EngineConfiguration(soap, a->EngineConfiguration + i);
		}
	}
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration), type))
		return soap->error;
	if (a->EngineConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizeEngineConfiguration; i++)
			if (soap_out_tt__EngineConfiguration(soap, "tt:EngineConfiguration", -1, a->EngineConfiguration + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_EngineConfiguration = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceEngineConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:EngineConfiguration", 1, NULL))
			{	if (a->EngineConfiguration == NULL)
				{	if (soap_blist_EngineConfiguration == NULL)
						soap_blist_EngineConfiguration = soap_alloc_block(soap);
					a->EngineConfiguration = (struct tt__EngineConfiguration *)soap_push_block_max(soap, soap_blist_EngineConfiguration, sizeof(struct tt__EngineConfiguration));
					if (a->EngineConfiguration == NULL)
						return NULL;
					soap_default_tt__EngineConfiguration(soap, a->EngineConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__EngineConfiguration(soap, "tt:EngineConfiguration", a->EngineConfiguration, "tt:EngineConfiguration"))
				{	a->__sizeEngineConfiguration++;
					a->EngineConfiguration = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsDeviceEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EngineConfiguration)
			soap_pop_block(soap, soap_blist_EngineConfiguration);
		if (a->__sizeEngineConfiguration)
		{	a->EngineConfiguration = (struct tt__EngineConfiguration *)soap_save_block(soap, soap_blist_EngineConfiguration, NULL, 1);
		}
		else
		{	a->EngineConfiguration = NULL;
			if (soap_blist_EngineConfiguration)
				soap_end_block(soap, soap_blist_EngineConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEngineConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceEngineConfiguration *p;
	struct tt__AnalyticsDeviceEngineConfiguration *a = (struct tt__AnalyticsDeviceEngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceEngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceEngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->SessionTimeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReplayConfiguration(struct soap *soap, const struct tt__ReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SessionTimeout, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayConfiguration(struct soap *soap, const char *tag, int id, const struct tt__ReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayConfiguration), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_in_tt__ReplayConfiguration(struct soap *soap, const char *tag, struct tt__ReplayConfiguration *a, const char *type)
{
	size_t soap_flag_SessionTimeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReplayConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SessionTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SessionTimeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayConfiguration, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_new_tt__ReplayConfiguration(struct soap *soap, int n)
{
	struct tt__ReplayConfiguration *p;
	struct tt__ReplayConfiguration *a = (struct tt__ReplayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReplayConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__ReplayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReplayConfiguration(struct soap *soap, const struct tt__ReplayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReplayConfiguration(soap, tag ? tag : "tt:ReplayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_get_tt__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetRecordingJobsResponseItem(struct soap *soap, const struct tt__GetRecordingJobsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingJobReference(soap, (char*const*)&a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetRecordingJobsResponseItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem), type))
		return soap->error;
	if (!a->JobToken)
	{	if (soap_element_nil(soap, "tt:JobToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobReference(soap, "tt:JobToken", -1, (char*const*)&a->JobToken, ""))
		return soap->error;
	if (!a->JobConfiguration)
	{	if (soap_element_nil(soap, "tt:JobConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", -1, &a->JobConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingJobsResponseItem *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetRecordingJobsResponseItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "tt:JobToken", (char**)&a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_JobConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingJobsResponseItem, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_new_tt__GetRecordingJobsResponseItem(struct soap *soap, int n)
{
	struct tt__GetRecordingJobsResponseItem *p;
	struct tt__GetRecordingJobsResponseItem *a = (struct tt__GetRecordingJobsResponseItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GetRecordingJobsResponseItem));
	for (p = a; p && n--; p++)
		soap_default_tt__GetRecordingJobsResponseItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetRecordingJobsResponseItem(struct soap *soap, const struct tt__GetRecordingJobsResponseItem *a, const char *tag, const char *type)
{
	if (soap_out_tt__GetRecordingJobsResponseItem(soap, tag ? tag : "tt:GetRecordingJobsResponseItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingJobsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceTag);
	soap_default_tt__TrackReference(soap, &a->Destination);
	soap_default_string(soap, &a->Error);
	soap_default_tt__RecordingJobState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateTrack(struct soap *soap, const struct tt__RecordingJobStateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SourceTag);
	soap_serialize_tt__TrackReference(soap, (char*const*)&a->Destination);
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_serialize_tt__RecordingJobState(soap, (char*const*)&a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTrack), type))
		return soap->error;
	if (!a->SourceTag)
	{	if (soap_element_nil(soap, "tt:SourceTag"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:SourceTag", -1, (char*const*)&a->SourceTag, ""))
		return soap->error;
	if (!a->Destination)
	{	if (soap_element_nil(soap, "tt:Destination"))
			return soap->error;
	}
	else
	if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, (char*const*)&a->Destination, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_nil(soap, "tt:State"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_in_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, struct tt__RecordingJobStateTrack *a, const char *type)
{
	size_t soap_flag_SourceTag = 1;
	size_t soap_flag_Destination = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateTrack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SourceTag", (char**)&a->SourceTag, "xsd:string"))
				{	soap_flag_SourceTag--;
					continue;
				}
			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:Destination", (char**)&a->Destination, "tt:TrackReference"))
				{	soap_flag_Destination--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobState(soap, "tt:State", (char**)&a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceTag > 0 || soap_flag_Destination > 0 || soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTrack, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_new_tt__RecordingJobStateTrack(struct soap *soap, int n)
{
	struct tt__RecordingJobStateTrack *p;
	struct tt__RecordingJobStateTrack *a = (struct tt__RecordingJobStateTrack*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateTrack));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateTrack(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateTrack(struct soap *soap, const struct tt__RecordingJobStateTrack *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateTrack(soap, tag ? tag : "tt:RecordingJobStateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_get_tt__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTrack = 0;
	a->Track = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateTracks(struct soap *soap, const struct tt__RecordingJobStateTracks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__RecordingJobStateTrack);
			soap_serialize_tt__RecordingJobStateTrack(soap, a->Track + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateTracks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTracks), type))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < (int)a->__sizeTrack; i++)
			if (soap_out_tt__RecordingJobStateTrack(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_in_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, struct tt__RecordingJobStateTracks *a, const char *type)
{
	struct soap_blist *soap_blist_Track = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateTracks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateTracks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_alloc_block(soap);
					a->Track = (struct tt__RecordingJobStateTrack *)soap_push_block_max(soap, soap_blist_Track, sizeof(struct tt__RecordingJobStateTrack));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__RecordingJobStateTrack(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobStateTrack(soap, "tt:Track", a->Track, "tt:RecordingJobStateTrack"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
		{	a->Track = (struct tt__RecordingJobStateTrack *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		}
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTracks, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_new_tt__RecordingJobStateTracks(struct soap *soap, int n)
{
	struct tt__RecordingJobStateTracks *p;
	struct tt__RecordingJobStateTracks *a = (struct tt__RecordingJobStateTracks*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateTracks));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateTracks(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateTracks(struct soap *soap, const struct tt__RecordingJobStateTracks *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateTracks(soap, tag ? tag : "tt:RecordingJobStateTracks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_get_tt__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateInformationExtension(struct soap *soap, const struct tt__RecordingJobStateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformationExtension, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_new_tt__RecordingJobStateInformationExtension(struct soap *soap, int n)
{
	struct tt__RecordingJobStateInformationExtension *p;
	struct tt__RecordingJobStateInformationExtension *a = (struct tt__RecordingJobStateInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateInformationExtension(struct soap *soap, const struct tt__RecordingJobStateInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateInformationExtension(soap, tag ? tag : "tt:RecordingJobStateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SourceToken = NULL;
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->Tracks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateSource(struct soap *soap, const struct tt__RecordingJobStateSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SourceReference(soap, &a->SourceToken);
	soap_serialize_tt__RecordingJobState(soap, (char*const*)&a->State);
	soap_serialize_PointerTott__RecordingJobStateTracks(soap, &a->Tracks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateSource(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateSource), type))
		return soap->error;
	if (!a->SourceToken)
	{	if (soap_element_nil(soap, "tt:SourceToken"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_nil(soap, "tt:State"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	if (!a->Tracks)
	{	if (soap_element_nil(soap, "tt:Tracks"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", -1, &a->Tracks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_in_tt__RecordingJobStateSource(struct soap *soap, const char *tag, struct tt__RecordingJobStateSource *a, const char *type)
{
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_State = 1;
	size_t soap_flag_Tracks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateSource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobState(soap, "tt:State", (char**)&a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", &a->Tracks, "tt:RecordingJobStateTracks"))
				{	soap_flag_Tracks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceToken > 0 || soap_flag_State > 0 || soap_flag_Tracks > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateSource, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_new_tt__RecordingJobStateSource(struct soap *soap, int n)
{
	struct tt__RecordingJobStateSource *p;
	struct tt__RecordingJobStateSource *a = (struct tt__RecordingJobStateSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateSource));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateSource(struct soap *soap, const struct tt__RecordingJobStateSource *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateSource(soap, tag ? tag : "tt:RecordingJobStateSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_get_tt__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->__sizeSources = 0;
	a->Sources = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateInformation(struct soap *soap, const struct tt__RecordingJobStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
	soap_serialize_tt__RecordingJobState(soap, (char*const*)&a->State);
	if (a->Sources)
	{	int i;
		for (i = 0; i < (int)a->__sizeSources; i++)
		{
			soap_embedded(soap, a->Sources + i, SOAP_TYPE_tt__RecordingJobStateSource);
			soap_serialize_tt__RecordingJobStateSource(soap, a->Sources + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobStateInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformation), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tt:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	if (!a->State)
	{	if (soap_element_nil(soap, "tt:State"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, (char*const*)&a->State, ""))
		return soap->error;
	if (a->Sources)
	{	int i;
		for (i = 0; i < (int)a->__sizeSources; i++)
			if (soap_out_tt__RecordingJobStateSource(soap, "tt:Sources", -1, a->Sources + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist_Sources = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobState(soap, "tt:State", (char**)&a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Sources", 1, NULL))
			{	if (a->Sources == NULL)
				{	if (soap_blist_Sources == NULL)
						soap_blist_Sources = soap_alloc_block(soap);
					a->Sources = (struct tt__RecordingJobStateSource *)soap_push_block_max(soap, soap_blist_Sources, sizeof(struct tt__RecordingJobStateSource));
					if (a->Sources == NULL)
						return NULL;
					soap_default_tt__RecordingJobStateSource(soap, a->Sources);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobStateSource(soap, "tt:Sources", a->Sources, "tt:RecordingJobStateSource"))
				{	a->__sizeSources++;
					a->Sources = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobStateInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Sources)
			soap_pop_block(soap, soap_blist_Sources);
		if (a->__sizeSources)
		{	a->Sources = (struct tt__RecordingJobStateSource *)soap_save_block(soap, soap_blist_Sources, NULL, 1);
		}
		else
		{	a->Sources = NULL;
			if (soap_blist_Sources)
				soap_end_block(soap, soap_blist_Sources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformation, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_new_tt__RecordingJobStateInformation(struct soap *soap, int n)
{
	struct tt__RecordingJobStateInformation *p;
	struct tt__RecordingJobStateInformation *a = (struct tt__RecordingJobStateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobStateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobStateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateInformation(struct soap *soap, const struct tt__RecordingJobStateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobStateInformation(soap, tag ? tag : "tt:RecordingJobStateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobSourceExtension(struct soap *soap, const struct tt__RecordingJobSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobSourceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSourceExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_in_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, struct tt__RecordingJobSourceExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobSourceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSourceExtension, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_new_tt__RecordingJobSourceExtension(struct soap *soap, int n)
{
	struct tt__RecordingJobSourceExtension *p;
	struct tt__RecordingJobSourceExtension *a = (struct tt__RecordingJobSourceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingJobSourceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingJobSourceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobSourceExtension(struct soap *soap, const struct tt__RecordingJobSourceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingJobSourceExtension(soap, tag ? tag : "tt:RecordingJobSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_get_tt__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
