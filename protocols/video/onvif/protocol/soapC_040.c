/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__DeleteActionsResponse(struct soap *soap, struct _ns4__DeleteActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__DeleteActionsResponse(struct soap *soap, const struct _ns4__DeleteActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__DeleteActionsResponse(struct soap *soap, const char *tag, int id, const struct _ns4__DeleteActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__DeleteActionsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__DeleteActionsResponse * SOAP_FMAC4 soap_in__ns4__DeleteActionsResponse(struct soap *soap, const char *tag, struct _ns4__DeleteActionsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__DeleteActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DeleteActionsResponse, sizeof(struct _ns4__DeleteActionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__DeleteActionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__DeleteActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DeleteActionsResponse, SOAP_TYPE__ns4__DeleteActionsResponse, sizeof(struct _ns4__DeleteActionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__DeleteActionsResponse * SOAP_FMAC4 soap_new__ns4__DeleteActionsResponse(struct soap *soap, int n)
{
	struct _ns4__DeleteActionsResponse *p;
	struct _ns4__DeleteActionsResponse *a = (struct _ns4__DeleteActionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__DeleteActionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__DeleteActionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__DeleteActionsResponse(struct soap *soap, const struct _ns4__DeleteActionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__DeleteActionsResponse(soap, tag ? tag : "ns4:DeleteActionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__DeleteActionsResponse * SOAP_FMAC4 soap_get__ns4__DeleteActionsResponse(struct soap *soap, struct _ns4__DeleteActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__DeleteActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__DeleteActions(struct soap *soap, struct _ns4__DeleteActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__DeleteActions(struct soap *soap, const struct _ns4__DeleteActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__DeleteActions(struct soap *soap, const char *tag, int id, const struct _ns4__DeleteActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__DeleteActions), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns4:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__DeleteActions * SOAP_FMAC4 soap_in__ns4__DeleteActions(struct soap *soap, const char *tag, struct _ns4__DeleteActions *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__DeleteActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__DeleteActions, sizeof(struct _ns4__DeleteActions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__DeleteActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "ns4:Token", (char**)a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__DeleteActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__DeleteActions, SOAP_TYPE__ns4__DeleteActions, sizeof(struct _ns4__DeleteActions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__DeleteActions * SOAP_FMAC4 soap_new__ns4__DeleteActions(struct soap *soap, int n)
{
	struct _ns4__DeleteActions *p;
	struct _ns4__DeleteActions *a = (struct _ns4__DeleteActions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__DeleteActions));
	for (p = a; p && n--; p++)
		soap_default__ns4__DeleteActions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__DeleteActions(struct soap *soap, const struct _ns4__DeleteActions *a, const char *tag, const char *type)
{
	if (soap_out__ns4__DeleteActions(soap, tag ? tag : "ns4:DeleteActions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__DeleteActions * SOAP_FMAC4 soap_get__ns4__DeleteActions(struct soap *soap, struct _ns4__DeleteActions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__DeleteActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__CreateActionsResponse(struct soap *soap, struct _ns4__CreateActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->Action = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__CreateActionsResponse(struct soap *soap, const struct _ns4__CreateActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->Action + i, SOAP_TYPE_ns4__Action);
			soap_serialize_ns4__Action(soap, a->Action + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__CreateActionsResponse(struct soap *soap, const char *tag, int id, const struct _ns4__CreateActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__CreateActionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAction");
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_ns4__Action(soap, "ns4:Action", -1, a->Action + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__CreateActionsResponse * SOAP_FMAC4 soap_in__ns4__CreateActionsResponse(struct soap *soap, const char *tag, struct _ns4__CreateActionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Action = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__CreateActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__CreateActionsResponse, sizeof(struct _ns4__CreateActionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__CreateActionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Action", 1, NULL))
			{	if (a->Action == NULL)
				{	if (soap_blist_Action == NULL)
						soap_blist_Action = soap_alloc_block(soap);
					a->Action = (struct ns4__Action *)soap_push_block_max(soap, soap_blist_Action, sizeof(struct ns4__Action));
					if (a->Action == NULL)
						return NULL;
					soap_default_ns4__Action(soap, a->Action);
				}
				soap_revert(soap);
				if (soap_in_ns4__Action(soap, "ns4:Action", a->Action, "ns4:Action"))
				{	a->__sizeAction++;
					a->Action = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAction");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Action)
			soap_pop_block(soap, soap_blist_Action);
		if (a->__sizeAction)
		{	a->Action = (struct ns4__Action *)soap_save_block(soap, soap_blist_Action, NULL, 1);
		}
		else
		{	a->Action = NULL;
			if (soap_blist_Action)
				soap_end_block(soap, soap_blist_Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__CreateActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__CreateActionsResponse, SOAP_TYPE__ns4__CreateActionsResponse, sizeof(struct _ns4__CreateActionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__CreateActionsResponse * SOAP_FMAC4 soap_new__ns4__CreateActionsResponse(struct soap *soap, int n)
{
	struct _ns4__CreateActionsResponse *p;
	struct _ns4__CreateActionsResponse *a = (struct _ns4__CreateActionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__CreateActionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__CreateActionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__CreateActionsResponse(struct soap *soap, const struct _ns4__CreateActionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__CreateActionsResponse(soap, tag ? tag : "ns4:CreateActionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__CreateActionsResponse * SOAP_FMAC4 soap_get__ns4__CreateActionsResponse(struct soap *soap, struct _ns4__CreateActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__CreateActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__CreateActions(struct soap *soap, struct _ns4__CreateActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->Action = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__CreateActions(struct soap *soap, const struct _ns4__CreateActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->Action + i, SOAP_TYPE_ns4__ActionConfiguration);
			soap_serialize_ns4__ActionConfiguration(soap, a->Action + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__CreateActions(struct soap *soap, const char *tag, int id, const struct _ns4__CreateActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__CreateActions), type))
		return soap->error;
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_ns4__ActionConfiguration(soap, "ns4:Action", -1, a->Action + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__CreateActions * SOAP_FMAC4 soap_in__ns4__CreateActions(struct soap *soap, const char *tag, struct _ns4__CreateActions *a, const char *type)
{
	struct soap_blist *soap_blist_Action = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__CreateActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__CreateActions, sizeof(struct _ns4__CreateActions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__CreateActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Action", 1, NULL))
			{	if (a->Action == NULL)
				{	if (soap_blist_Action == NULL)
						soap_blist_Action = soap_alloc_block(soap);
					a->Action = (struct ns4__ActionConfiguration *)soap_push_block_max(soap, soap_blist_Action, sizeof(struct ns4__ActionConfiguration));
					if (a->Action == NULL)
						return NULL;
					soap_default_ns4__ActionConfiguration(soap, a->Action);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionConfiguration(soap, "ns4:Action", a->Action, "ns4:ActionConfiguration"))
				{	a->__sizeAction++;
					a->Action = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Action)
			soap_pop_block(soap, soap_blist_Action);
		if (a->__sizeAction)
		{	a->Action = (struct ns4__ActionConfiguration *)soap_save_block(soap, soap_blist_Action, NULL, 1);
		}
		else
		{	a->Action = NULL;
			if (soap_blist_Action)
				soap_end_block(soap, soap_blist_Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__CreateActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__CreateActions, SOAP_TYPE__ns4__CreateActions, sizeof(struct _ns4__CreateActions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__CreateActions * SOAP_FMAC4 soap_new__ns4__CreateActions(struct soap *soap, int n)
{
	struct _ns4__CreateActions *p;
	struct _ns4__CreateActions *a = (struct _ns4__CreateActions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__CreateActions));
	for (p = a; p && n--; p++)
		soap_default__ns4__CreateActions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__CreateActions(struct soap *soap, const struct _ns4__CreateActions *a, const char *tag, const char *type)
{
	if (soap_out__ns4__CreateActions(soap, tag ? tag : "ns4:CreateActions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__CreateActions * SOAP_FMAC4 soap_get__ns4__CreateActions(struct soap *soap, struct _ns4__CreateActions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__CreateActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetActionsResponse(struct soap *soap, struct _ns4__GetActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->Action = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetActionsResponse(struct soap *soap, const struct _ns4__GetActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->Action + i, SOAP_TYPE_ns4__Action);
			soap_serialize_ns4__Action(soap, a->Action + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetActionsResponse(struct soap *soap, const char *tag, int id, const struct _ns4__GetActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetActionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAction");
	if (a->Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_ns4__Action(soap, "ns4:Action", -1, a->Action + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetActionsResponse * SOAP_FMAC4 soap_in__ns4__GetActionsResponse(struct soap *soap, const char *tag, struct _ns4__GetActionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Action = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetActionsResponse, sizeof(struct _ns4__GetActionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetActionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:Action", 1, NULL))
			{	if (a->Action == NULL)
				{	if (soap_blist_Action == NULL)
						soap_blist_Action = soap_alloc_block(soap);
					a->Action = (struct ns4__Action *)soap_push_block_max(soap, soap_blist_Action, sizeof(struct ns4__Action));
					if (a->Action == NULL)
						return NULL;
					soap_default_ns4__Action(soap, a->Action);
				}
				soap_revert(soap);
				if (soap_in_ns4__Action(soap, "ns4:Action", a->Action, "ns4:Action"))
				{	a->__sizeAction++;
					a->Action = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAction");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Action)
			soap_pop_block(soap, soap_blist_Action);
		if (a->__sizeAction)
		{	a->Action = (struct ns4__Action *)soap_save_block(soap, soap_blist_Action, NULL, 1);
		}
		else
		{	a->Action = NULL;
			if (soap_blist_Action)
				soap_end_block(soap, soap_blist_Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetActionsResponse, SOAP_TYPE__ns4__GetActionsResponse, sizeof(struct _ns4__GetActionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetActionsResponse * SOAP_FMAC4 soap_new__ns4__GetActionsResponse(struct soap *soap, int n)
{
	struct _ns4__GetActionsResponse *p;
	struct _ns4__GetActionsResponse *a = (struct _ns4__GetActionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetActionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetActionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetActionsResponse(struct soap *soap, const struct _ns4__GetActionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetActionsResponse(soap, tag ? tag : "ns4:GetActionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetActionsResponse * SOAP_FMAC4 soap_get__ns4__GetActionsResponse(struct soap *soap, struct _ns4__GetActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetActions(struct soap *soap, struct _ns4__GetActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetActions(struct soap *soap, const struct _ns4__GetActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetActions(struct soap *soap, const char *tag, int id, const struct _ns4__GetActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetActions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetActions * SOAP_FMAC4 soap_in__ns4__GetActions(struct soap *soap, const char *tag, struct _ns4__GetActions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetActions, sizeof(struct _ns4__GetActions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetActions, SOAP_TYPE__ns4__GetActions, sizeof(struct _ns4__GetActions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetActions * SOAP_FMAC4 soap_new__ns4__GetActions(struct soap *soap, int n)
{
	struct _ns4__GetActions *p;
	struct _ns4__GetActions *a = (struct _ns4__GetActions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetActions));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetActions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetActions(struct soap *soap, const struct _ns4__GetActions *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetActions(soap, tag ? tag : "ns4:GetActions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetActions * SOAP_FMAC4 soap_get__ns4__GetActions(struct soap *soap, struct _ns4__GetActions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetSupportedActionsResponse(struct soap *soap, struct _ns4__GetSupportedActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportedActions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetSupportedActionsResponse(struct soap *soap, const struct _ns4__GetSupportedActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__SupportedActions(soap, &a->SupportedActions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetSupportedActionsResponse(struct soap *soap, const char *tag, int id, const struct _ns4__GetSupportedActionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetSupportedActionsResponse), type))
		return soap->error;
	if (a->SupportedActions)
		soap_element_result(soap, "ns4:SupportedActions");
	if (!a->SupportedActions)
	{	if (soap_element_nil(soap, "ns4:SupportedActions"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__SupportedActions(soap, "ns4:SupportedActions", -1, &a->SupportedActions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetSupportedActionsResponse * SOAP_FMAC4 soap_in__ns4__GetSupportedActionsResponse(struct soap *soap, const char *tag, struct _ns4__GetSupportedActionsResponse *a, const char *type)
{
	size_t soap_flag_SupportedActions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetSupportedActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetSupportedActionsResponse, sizeof(struct _ns4__GetSupportedActionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetSupportedActionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedActions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SupportedActions(soap, "ns4:SupportedActions", &a->SupportedActions, "ns4:SupportedActions"))
				{	soap_flag_SupportedActions--;
					continue;
				}
			soap_check_result(soap, "ns4:SupportedActions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedActions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns4__GetSupportedActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetSupportedActionsResponse, SOAP_TYPE__ns4__GetSupportedActionsResponse, sizeof(struct _ns4__GetSupportedActionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetSupportedActionsResponse * SOAP_FMAC4 soap_new__ns4__GetSupportedActionsResponse(struct soap *soap, int n)
{
	struct _ns4__GetSupportedActionsResponse *p;
	struct _ns4__GetSupportedActionsResponse *a = (struct _ns4__GetSupportedActionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetSupportedActionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetSupportedActionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetSupportedActionsResponse(struct soap *soap, const struct _ns4__GetSupportedActionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetSupportedActionsResponse(soap, tag ? tag : "ns4:GetSupportedActionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetSupportedActionsResponse * SOAP_FMAC4 soap_get__ns4__GetSupportedActionsResponse(struct soap *soap, struct _ns4__GetSupportedActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetSupportedActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns4__GetSupportedActions(struct soap *soap, struct _ns4__GetSupportedActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__GetSupportedActions(struct soap *soap, const struct _ns4__GetSupportedActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__GetSupportedActions(struct soap *soap, const char *tag, int id, const struct _ns4__GetSupportedActions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__GetSupportedActions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns4__GetSupportedActions * SOAP_FMAC4 soap_in__ns4__GetSupportedActions(struct soap *soap, const char *tag, struct _ns4__GetSupportedActions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns4__GetSupportedActions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__GetSupportedActions, sizeof(struct _ns4__GetSupportedActions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns4__GetSupportedActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns4__GetSupportedActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__GetSupportedActions, SOAP_TYPE__ns4__GetSupportedActions, sizeof(struct _ns4__GetSupportedActions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns4__GetSupportedActions * SOAP_FMAC4 soap_new__ns4__GetSupportedActions(struct soap *soap, int n)
{
	struct _ns4__GetSupportedActions *p;
	struct _ns4__GetSupportedActions *a = (struct _ns4__GetSupportedActions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns4__GetSupportedActions));
	for (p = a; p && n--; p++)
		soap_default__ns4__GetSupportedActions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns4__GetSupportedActions(struct soap *soap, const struct _ns4__GetSupportedActions *a, const char *tag, const char *type)
{
	if (soap_out__ns4__GetSupportedActions(soap, tag ? tag : "ns4:GetSupportedActions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns4__GetSupportedActions * SOAP_FMAC4 soap_get__ns4__GetSupportedActions(struct soap *soap, struct _ns4__GetSupportedActions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__GetSupportedActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__RecordingActionConfiguration(struct soap *soap, struct ns4__RecordingActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__RecordingActionConfiguration(struct soap *soap, const struct ns4__RecordingActionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__TriggeredRecordingConfiguration(soap, &a->RecordConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__RecordingActionConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__RecordingActionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__RecordingActionConfiguration), type))
		return soap->error;
	if (!a->RecordConfig)
	{	if (soap_element_nil(soap, "ns4:RecordConfig"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__TriggeredRecordingConfiguration(soap, "ns4:RecordConfig", -1, &a->RecordConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__RecordingActionConfiguration * SOAP_FMAC4 soap_in_ns4__RecordingActionConfiguration(struct soap *soap, const char *tag, struct ns4__RecordingActionConfiguration *a, const char *type)
{
	size_t soap_flag_RecordConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__RecordingActionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__RecordingActionConfiguration, sizeof(struct ns4__RecordingActionConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__RecordingActionConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TriggeredRecordingConfiguration(soap, "ns4:RecordConfig", &a->RecordConfig, "ns4:TriggeredRecordingConfiguration"))
				{	soap_flag_RecordConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordConfig > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__RecordingActionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__RecordingActionConfiguration, SOAP_TYPE_ns4__RecordingActionConfiguration, sizeof(struct ns4__RecordingActionConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__RecordingActionConfiguration * SOAP_FMAC4 soap_new_ns4__RecordingActionConfiguration(struct soap *soap, int n)
{
	struct ns4__RecordingActionConfiguration *p;
	struct ns4__RecordingActionConfiguration *a = (struct ns4__RecordingActionConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__RecordingActionConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__RecordingActionConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__RecordingActionConfiguration(struct soap *soap, const struct ns4__RecordingActionConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__RecordingActionConfiguration(soap, tag ? tag : "ns4:RecordingActionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__RecordingActionConfiguration * SOAP_FMAC4 soap_get_ns4__RecordingActionConfiguration(struct soap *soap, struct ns4__RecordingActionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__RecordingActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__TriggeredRecordingConfiguration(struct soap *soap, struct ns4__TriggeredRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->PreRecordDuration);
	soap_default_xsd__duration(soap, &a->PostRecordDuration);
	soap_default_xsd__duration(soap, &a->RecordDuration);
	soap_default_xsd__positiveInteger(soap, &a->RecordFrameRate);
	soap_default_xsd__boolean(soap, &a->DoRecordAudio);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__TriggeredRecordingConfiguration(struct soap *soap, const struct ns4__TriggeredRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->PreRecordDuration, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->PostRecordDuration, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->RecordDuration, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__positiveInteger(soap, (char*const*)&a->RecordFrameRate);
	soap_embedded(soap, &a->DoRecordAudio, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TriggeredRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__TriggeredRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TriggeredRecordingConfiguration), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns4:PreRecordDuration", -1, &a->PreRecordDuration, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns4:PostRecordDuration", -1, &a->PostRecordDuration, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns4:RecordDuration", -1, &a->RecordDuration, ""))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "ns4:RecordFrameRate", -1, (char*const*)&a->RecordFrameRate, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns4:DoRecordAudio", -1, &a->DoRecordAudio, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__TriggeredRecordingConfiguration * SOAP_FMAC4 soap_in_ns4__TriggeredRecordingConfiguration(struct soap *soap, const char *tag, struct ns4__TriggeredRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_PreRecordDuration = 1;
	size_t soap_flag_PostRecordDuration = 1;
	size_t soap_flag_RecordDuration = 1;
	size_t soap_flag_RecordFrameRate = 1;
	size_t soap_flag_DoRecordAudio = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__TriggeredRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TriggeredRecordingConfiguration, sizeof(struct ns4__TriggeredRecordingConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__TriggeredRecordingConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PreRecordDuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns4:PreRecordDuration", &a->PreRecordDuration, "xsd:duration"))
				{	soap_flag_PreRecordDuration--;
					continue;
				}
			if (soap_flag_PostRecordDuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns4:PostRecordDuration", &a->PostRecordDuration, "xsd:duration"))
				{	soap_flag_PostRecordDuration--;
					continue;
				}
			if (soap_flag_RecordDuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns4:RecordDuration", &a->RecordDuration, "xsd:duration"))
				{	soap_flag_RecordDuration--;
					continue;
				}
			if (soap_flag_RecordFrameRate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns4:RecordFrameRate", (char**)&a->RecordFrameRate, "xsd:positiveInteger"))
				{	soap_flag_RecordFrameRate--;
					continue;
				}
			if (soap_flag_DoRecordAudio && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns4:DoRecordAudio", &a->DoRecordAudio, "xsd:boolean"))
				{	soap_flag_DoRecordAudio--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PreRecordDuration > 0 || soap_flag_PostRecordDuration > 0 || soap_flag_RecordDuration > 0 || soap_flag_DoRecordAudio > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__TriggeredRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TriggeredRecordingConfiguration, SOAP_TYPE_ns4__TriggeredRecordingConfiguration, sizeof(struct ns4__TriggeredRecordingConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__TriggeredRecordingConfiguration * SOAP_FMAC4 soap_new_ns4__TriggeredRecordingConfiguration(struct soap *soap, int n)
{
	struct ns4__TriggeredRecordingConfiguration *p;
	struct ns4__TriggeredRecordingConfiguration *a = (struct ns4__TriggeredRecordingConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__TriggeredRecordingConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__TriggeredRecordingConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__TriggeredRecordingConfiguration(struct soap *soap, const struct ns4__TriggeredRecordingConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__TriggeredRecordingConfiguration(soap, tag ? tag : "ns4:TriggeredRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__TriggeredRecordingConfiguration * SOAP_FMAC4 soap_get_ns4__TriggeredRecordingConfiguration(struct soap *soap, struct ns4__TriggeredRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TriggeredRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SMSMessage(struct soap *soap, struct ns4__SMSMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SMSMessage(struct soap *soap, const struct ns4__SMSMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SMSMessage(struct soap *soap, const char *tag, int id, const struct ns4__SMSMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SMSMessage), type))
		return soap->error;
	if (!a->Text)
	{	if (soap_element_nil(soap, "ns4:Text"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:Text", -1, (char*const*)&a->Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SMSMessage * SOAP_FMAC4 soap_in_ns4__SMSMessage(struct soap *soap, const char *tag, struct ns4__SMSMessage *a, const char *type)
{
	size_t soap_flag_Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SMSMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SMSMessage, sizeof(struct ns4__SMSMessage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SMSMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Text", (char**)&a->Text, "xsd:string"))
				{	soap_flag_Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Text > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SMSMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SMSMessage, SOAP_TYPE_ns4__SMSMessage, sizeof(struct ns4__SMSMessage), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__SMSMessage * SOAP_FMAC4 soap_new_ns4__SMSMessage(struct soap *soap, int n)
{
	struct ns4__SMSMessage *p;
	struct ns4__SMSMessage *a = (struct ns4__SMSMessage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__SMSMessage));
	for (p = a; p && n--; p++)
		soap_default_ns4__SMSMessage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SMSMessage(struct soap *soap, const struct ns4__SMSMessage *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SMSMessage(soap, tag ? tag : "ns4:SMSMessage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SMSMessage * SOAP_FMAC4 soap_get_ns4__SMSMessage(struct soap *soap, struct ns4__SMSMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SMSMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SMSSenderConfiguration(struct soap *soap, struct ns4__SMSSenderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->EMail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SMSSenderConfiguration(struct soap *soap, const struct ns4__SMSSenderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->EMail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SMSSenderConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__SMSSenderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SMSSenderConfiguration), type))
		return soap->error;
	if (!a->EMail)
	{	if (soap_element_nil(soap, "ns4:EMail"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:EMail", -1, (char*const*)&a->EMail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SMSSenderConfiguration * SOAP_FMAC4 soap_in_ns4__SMSSenderConfiguration(struct soap *soap, const char *tag, struct ns4__SMSSenderConfiguration *a, const char *type)
{
	size_t soap_flag_EMail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SMSSenderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SMSSenderConfiguration, sizeof(struct ns4__SMSSenderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SMSSenderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EMail && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:EMail", (char**)&a->EMail, "xsd:string"))
				{	soap_flag_EMail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EMail > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SMSSenderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SMSSenderConfiguration, SOAP_TYPE_ns4__SMSSenderConfiguration, sizeof(struct ns4__SMSSenderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__SMSSenderConfiguration * SOAP_FMAC4 soap_new_ns4__SMSSenderConfiguration(struct soap *soap, int n)
{
	struct ns4__SMSSenderConfiguration *p;
	struct ns4__SMSSenderConfiguration *a = (struct ns4__SMSSenderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__SMSSenderConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__SMSSenderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SMSSenderConfiguration(struct soap *soap, const struct ns4__SMSSenderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SMSSenderConfiguration(soap, tag ? tag : "ns4:SMSSenderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SMSSenderConfiguration * SOAP_FMAC4 soap_get_ns4__SMSSenderConfiguration(struct soap *soap, struct ns4__SMSSenderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SMSSenderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SMSProviderConfiguration(struct soap *soap, struct ns4__SMSProviderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->ProviderURL);
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SMSProviderConfiguration(struct soap *soap, const struct ns4__SMSProviderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->ProviderURL);
	soap_serialize_PointerTons4__UserCredentials(soap, &a->User);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SMSProviderConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__SMSProviderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SMSProviderConfiguration), type))
		return soap->error;
	if (!a->ProviderURL)
	{	if (soap_element_nil(soap, "ns4:ProviderURL"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "ns4:ProviderURL", -1, (char*const*)&a->ProviderURL, ""))
		return soap->error;
	if (!a->User)
	{	if (soap_element_nil(soap, "ns4:User"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__UserCredentials(soap, "ns4:User", -1, &a->User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SMSProviderConfiguration * SOAP_FMAC4 soap_in_ns4__SMSProviderConfiguration(struct soap *soap, const char *tag, struct ns4__SMSProviderConfiguration *a, const char *type)
{
	size_t soap_flag_ProviderURL = 1;
	size_t soap_flag_User = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SMSProviderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SMSProviderConfiguration, sizeof(struct ns4__SMSProviderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SMSProviderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProviderURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns4:ProviderURL", (char**)&a->ProviderURL, "xsd:anyURI"))
				{	soap_flag_ProviderURL--;
					continue;
				}
			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserCredentials(soap, "ns4:User", &a->User, "ns4:UserCredentials"))
				{	soap_flag_User--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProviderURL > 0 || soap_flag_User > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SMSProviderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SMSProviderConfiguration, SOAP_TYPE_ns4__SMSProviderConfiguration, sizeof(struct ns4__SMSProviderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__SMSProviderConfiguration * SOAP_FMAC4 soap_new_ns4__SMSProviderConfiguration(struct soap *soap, int n)
{
	struct ns4__SMSProviderConfiguration *p;
	struct ns4__SMSProviderConfiguration *a = (struct ns4__SMSProviderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__SMSProviderConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__SMSProviderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SMSProviderConfiguration(struct soap *soap, const struct ns4__SMSProviderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SMSProviderConfiguration(soap, tag ? tag : "ns4:SMSProviderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SMSProviderConfiguration * SOAP_FMAC4 soap_get_ns4__SMSProviderConfiguration(struct soap *soap, struct ns4__SMSProviderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SMSProviderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpContentConfigurationUploadFile(struct soap *soap, struct ns4__FtpContentConfigurationUploadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sourceFileName);
	soap_default_string(soap, &a->destinationFileName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpContentConfigurationUploadFile(struct soap *soap, const struct ns4__FtpContentConfigurationUploadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->sourceFileName);
	soap_serialize_string(soap, (char*const*)&a->destinationFileName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpContentConfigurationUploadFile(struct soap *soap, const char *tag, int id, const struct ns4__FtpContentConfigurationUploadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpContentConfigurationUploadFile), type))
		return soap->error;
	if (!a->sourceFileName)
	{	if (soap_element_nil(soap, "ns4:sourceFileName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:sourceFileName", -1, (char*const*)&a->sourceFileName, ""))
		return soap->error;
	if (!a->destinationFileName)
	{	if (soap_element_nil(soap, "ns4:destinationFileName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:destinationFileName", -1, (char*const*)&a->destinationFileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpContentConfigurationUploadFile * SOAP_FMAC4 soap_in_ns4__FtpContentConfigurationUploadFile(struct soap *soap, const char *tag, struct ns4__FtpContentConfigurationUploadFile *a, const char *type)
{
	size_t soap_flag_sourceFileName = 1;
	size_t soap_flag_destinationFileName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpContentConfigurationUploadFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpContentConfigurationUploadFile, sizeof(struct ns4__FtpContentConfigurationUploadFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpContentConfigurationUploadFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sourceFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:sourceFileName", (char**)&a->sourceFileName, "xsd:string"))
				{	soap_flag_sourceFileName--;
					continue;
				}
			if (soap_flag_destinationFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:destinationFileName", (char**)&a->destinationFileName, "xsd:string"))
				{	soap_flag_destinationFileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sourceFileName > 0 || soap_flag_destinationFileName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpContentConfigurationUploadFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpContentConfigurationUploadFile, SOAP_TYPE_ns4__FtpContentConfigurationUploadFile, sizeof(struct ns4__FtpContentConfigurationUploadFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpContentConfigurationUploadFile * SOAP_FMAC4 soap_new_ns4__FtpContentConfigurationUploadFile(struct soap *soap, int n)
{
	struct ns4__FtpContentConfigurationUploadFile *p;
	struct ns4__FtpContentConfigurationUploadFile *a = (struct ns4__FtpContentConfigurationUploadFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpContentConfigurationUploadFile));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpContentConfigurationUploadFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpContentConfigurationUploadFile(struct soap *soap, const struct ns4__FtpContentConfigurationUploadFile *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpContentConfigurationUploadFile(soap, tag ? tag : "ns4:FtpContentConfigurationUploadFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpContentConfigurationUploadFile * SOAP_FMAC4 soap_get_ns4__FtpContentConfigurationUploadFile(struct soap *soap, struct ns4__FtpContentConfigurationUploadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpContentConfigurationUploadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpContentConfigurationUploadImages(struct soap *soap, struct ns4__FtpContentConfigurationUploadImages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->HowLong);
	soap_default_xsd__duration(soap, &a->SampleInterval);
	a->FileName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpContentConfigurationUploadImages(struct soap *soap, const struct ns4__FtpContentConfigurationUploadImages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->HowLong, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->SampleInterval, SOAP_TYPE_xsd__duration);
	soap_serialize_PointerTons4__FtpFileNameConfigurations(soap, &a->FileName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpContentConfigurationUploadImages(struct soap *soap, const char *tag, int id, const struct ns4__FtpContentConfigurationUploadImages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpContentConfigurationUploadImages), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns4:HowLong", -1, &a->HowLong, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "ns4:SampleInterval", -1, &a->SampleInterval, ""))
		return soap->error;
	if (!a->FileName)
	{	if (soap_element_nil(soap, "ns4:FileName"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__FtpFileNameConfigurations(soap, "ns4:FileName", -1, &a->FileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpContentConfigurationUploadImages * SOAP_FMAC4 soap_in_ns4__FtpContentConfigurationUploadImages(struct soap *soap, const char *tag, struct ns4__FtpContentConfigurationUploadImages *a, const char *type)
{
	size_t soap_flag_HowLong = 1;
	size_t soap_flag_SampleInterval = 1;
	size_t soap_flag_FileName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpContentConfigurationUploadImages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpContentConfigurationUploadImages, sizeof(struct ns4__FtpContentConfigurationUploadImages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpContentConfigurationUploadImages(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HowLong && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns4:HowLong", &a->HowLong, "xsd:duration"))
				{	soap_flag_HowLong--;
					continue;
				}
			if (soap_flag_SampleInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "ns4:SampleInterval", &a->SampleInterval, "xsd:duration"))
				{	soap_flag_SampleInterval--;
					continue;
				}
			if (soap_flag_FileName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpFileNameConfigurations(soap, "ns4:FileName", &a->FileName, "ns4:FtpFileNameConfigurations"))
				{	soap_flag_FileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HowLong > 0 || soap_flag_SampleInterval > 0 || soap_flag_FileName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpContentConfigurationUploadImages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpContentConfigurationUploadImages, SOAP_TYPE_ns4__FtpContentConfigurationUploadImages, sizeof(struct ns4__FtpContentConfigurationUploadImages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpContentConfigurationUploadImages * SOAP_FMAC4 soap_new_ns4__FtpContentConfigurationUploadImages(struct soap *soap, int n)
{
	struct ns4__FtpContentConfigurationUploadImages *p;
	struct ns4__FtpContentConfigurationUploadImages *a = (struct ns4__FtpContentConfigurationUploadImages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpContentConfigurationUploadImages));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpContentConfigurationUploadImages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpContentConfigurationUploadImages(struct soap *soap, const struct ns4__FtpContentConfigurationUploadImages *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpContentConfigurationUploadImages(soap, tag ? tag : "ns4:FtpContentConfigurationUploadImages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpContentConfigurationUploadImages * SOAP_FMAC4 soap_get_ns4__FtpContentConfigurationUploadImages(struct soap *soap, struct ns4__FtpContentConfigurationUploadImages *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpContentConfigurationUploadImages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpFileNameConfigurations(struct soap *soap, struct ns4__FtpFileNameConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->file_USCOREname);
	a->suffix = (enum ns4__FileSuffixType)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpFileNameConfigurations(struct soap *soap, const struct ns4__FtpFileNameConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpFileNameConfigurations(struct soap *soap, const char *tag, int id, const struct ns4__FtpFileNameConfigurations *a, const char *type)
{
	if (a->file_USCOREname)
		soap_set_attr(soap, "file_name", soap_string2s(soap, a->file_USCOREname), 1);
	soap_set_attr(soap, "suffix", soap_ns4__FileSuffixType2s(soap, a->suffix), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpFileNameConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpFileNameConfigurations * SOAP_FMAC4 soap_in_ns4__FtpFileNameConfigurations(struct soap *soap, const char *tag, struct ns4__FtpFileNameConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpFileNameConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpFileNameConfigurations, sizeof(struct ns4__FtpFileNameConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpFileNameConfigurations(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "file_name", 0), &a->file_USCOREname))
		return NULL;
	if (soap_s2ns4__FileSuffixType(soap, soap_attr_value(soap, "suffix", 0), &a->suffix))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FtpFileNameConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpFileNameConfigurations, SOAP_TYPE_ns4__FtpFileNameConfigurations, sizeof(struct ns4__FtpFileNameConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpFileNameConfigurations * SOAP_FMAC4 soap_new_ns4__FtpFileNameConfigurations(struct soap *soap, int n)
{
	struct ns4__FtpFileNameConfigurations *p;
	struct ns4__FtpFileNameConfigurations *a = (struct ns4__FtpFileNameConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpFileNameConfigurations));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpFileNameConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpFileNameConfigurations(struct soap *soap, const struct ns4__FtpFileNameConfigurations *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpFileNameConfigurations(soap, tag ? tag : "ns4:FtpFileNameConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpFileNameConfigurations * SOAP_FMAC4 soap_get_ns4__FtpFileNameConfigurations(struct soap *soap, struct ns4__FtpFileNameConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpFileNameConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpContentConfiguration(struct soap *soap, struct ns4__FtpContentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_FtpContentConfiguration = -1;
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpContentConfiguration(struct soap *soap, const struct ns4__FtpContentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns4__union_FtpContentConfiguration(soap, a->__union_FtpContentConfiguration, &a->union_FtpContentConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpContentConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__FtpContentConfiguration *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpContentConfiguration), type))
		return soap->error;
	if (soap_out__ns4__union_FtpContentConfiguration(soap, a->__union_FtpContentConfiguration, &a->union_FtpContentConfiguration))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpContentConfiguration * SOAP_FMAC4 soap_in_ns4__FtpContentConfiguration(struct soap *soap, const char *tag, struct ns4__FtpContentConfiguration *a, const char *type)
{
	size_t soap_flag_union_FtpContentConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpContentConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpContentConfiguration, sizeof(struct ns4__FtpContentConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpContentConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_FtpContentConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns4__union_FtpContentConfiguration(soap, &a->__union_FtpContentConfiguration, &a->union_FtpContentConfiguration))
				{	soap_flag_union_FtpContentConfiguration = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_FtpContentConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpContentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpContentConfiguration, SOAP_TYPE_ns4__FtpContentConfiguration, sizeof(struct ns4__FtpContentConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpContentConfiguration * SOAP_FMAC4 soap_new_ns4__FtpContentConfiguration(struct soap *soap, int n)
{
	struct ns4__FtpContentConfiguration *p;
	struct ns4__FtpContentConfiguration *a = (struct ns4__FtpContentConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpContentConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpContentConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpContentConfiguration(struct soap *soap, const struct ns4__FtpContentConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpContentConfiguration(soap, tag ? tag : "ns4:FtpContentConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpContentConfiguration * SOAP_FMAC4 soap_get_ns4__FtpContentConfiguration(struct soap *soap, struct ns4__FtpContentConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpContentConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpContent(struct soap *soap, struct ns4__FtpContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FtpContentConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpContent(struct soap *soap, const struct ns4__FtpContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__FtpContentConfiguration(soap, &a->FtpContentConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpContent(struct soap *soap, const char *tag, int id, const struct ns4__FtpContent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpContent), type))
		return soap->error;
	if (!a->FtpContentConfig)
	{	if (soap_element_nil(soap, "ns4:FtpContentConfig"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__FtpContentConfiguration(soap, "ns4:FtpContentConfig", -1, &a->FtpContentConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpContent * SOAP_FMAC4 soap_in_ns4__FtpContent(struct soap *soap, const char *tag, struct ns4__FtpContent *a, const char *type)
{
	size_t soap_flag_FtpContentConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpContent, sizeof(struct ns4__FtpContent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FtpContentConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpContentConfiguration(soap, "ns4:FtpContentConfig", &a->FtpContentConfig, "ns4:FtpContentConfiguration"))
				{	soap_flag_FtpContentConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FtpContentConfig > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpContent, SOAP_TYPE_ns4__FtpContent, sizeof(struct ns4__FtpContent), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpContent * SOAP_FMAC4 soap_new_ns4__FtpContent(struct soap *soap, int n)
{
	struct ns4__FtpContent *p;
	struct ns4__FtpContent *a = (struct ns4__FtpContent*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpContent));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpContent(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpContent(struct soap *soap, const struct ns4__FtpContent *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpContent(soap, tag ? tag : "ns4:FtpContent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpContent * SOAP_FMAC4 soap_get_ns4__FtpContent(struct soap *soap, struct ns4__FtpContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, struct ns4__FtpAuthenticationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, const struct ns4__FtpAuthenticationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__FtpAuthenticationConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpAuthenticationConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpAuthenticationConfigurationExtension * SOAP_FMAC4 soap_in_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, struct ns4__FtpAuthenticationConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpAuthenticationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpAuthenticationConfigurationExtension, sizeof(struct ns4__FtpAuthenticationConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpAuthenticationConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FtpAuthenticationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpAuthenticationConfigurationExtension, SOAP_TYPE_ns4__FtpAuthenticationConfigurationExtension, sizeof(struct ns4__FtpAuthenticationConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpAuthenticationConfigurationExtension * SOAP_FMAC4 soap_new_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__FtpAuthenticationConfigurationExtension *p;
	struct ns4__FtpAuthenticationConfigurationExtension *a = (struct ns4__FtpAuthenticationConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpAuthenticationConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpAuthenticationConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, const struct ns4__FtpAuthenticationConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpAuthenticationConfigurationExtension(soap, tag ? tag : "ns4:FtpAuthenticationConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpAuthenticationConfigurationExtension * SOAP_FMAC4 soap_get_ns4__FtpAuthenticationConfigurationExtension(struct soap *soap, struct ns4__FtpAuthenticationConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpAuthenticationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpDestinationConfigurationExtension(struct soap *soap, struct ns4__FtpDestinationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpDestinationConfigurationExtension(struct soap *soap, const struct ns4__FtpDestinationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpDestinationConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__FtpDestinationConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpDestinationConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpDestinationConfigurationExtension * SOAP_FMAC4 soap_in_ns4__FtpDestinationConfigurationExtension(struct soap *soap, const char *tag, struct ns4__FtpDestinationConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpDestinationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpDestinationConfigurationExtension, sizeof(struct ns4__FtpDestinationConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpDestinationConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FtpDestinationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpDestinationConfigurationExtension, SOAP_TYPE_ns4__FtpDestinationConfigurationExtension, sizeof(struct ns4__FtpDestinationConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpDestinationConfigurationExtension * SOAP_FMAC4 soap_new_ns4__FtpDestinationConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__FtpDestinationConfigurationExtension *p;
	struct ns4__FtpDestinationConfigurationExtension *a = (struct ns4__FtpDestinationConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpDestinationConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpDestinationConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpDestinationConfigurationExtension(struct soap *soap, const struct ns4__FtpDestinationConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpDestinationConfigurationExtension(soap, tag ? tag : "ns4:FtpDestinationConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpDestinationConfigurationExtension * SOAP_FMAC4 soap_get_ns4__FtpDestinationConfigurationExtension(struct soap *soap, struct ns4__FtpDestinationConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpDestinationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpAuthenticationConfiguration(struct soap *soap, struct ns4__FtpAuthenticationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->User = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpAuthenticationConfiguration(struct soap *soap, const struct ns4__FtpAuthenticationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__UserCredentials(soap, &a->User);
	soap_serialize_PointerTons4__FtpAuthenticationConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpAuthenticationConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__FtpAuthenticationConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpAuthenticationConfiguration), type))
		return soap->error;
	if (soap_out_PointerTons4__UserCredentials(soap, "ns4:User", -1, &a->User, ""))
		return soap->error;
	if (soap_out_PointerTons4__FtpAuthenticationConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpAuthenticationConfiguration * SOAP_FMAC4 soap_in_ns4__FtpAuthenticationConfiguration(struct soap *soap, const char *tag, struct ns4__FtpAuthenticationConfiguration *a, const char *type)
{
	size_t soap_flag_User = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpAuthenticationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpAuthenticationConfiguration, sizeof(struct ns4__FtpAuthenticationConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpAuthenticationConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserCredentials(soap, "ns4:User", &a->User, "ns4:UserCredentials"))
				{	soap_flag_User--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpAuthenticationConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:FtpAuthenticationConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FtpAuthenticationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpAuthenticationConfiguration, SOAP_TYPE_ns4__FtpAuthenticationConfiguration, sizeof(struct ns4__FtpAuthenticationConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpAuthenticationConfiguration * SOAP_FMAC4 soap_new_ns4__FtpAuthenticationConfiguration(struct soap *soap, int n)
{
	struct ns4__FtpAuthenticationConfiguration *p;
	struct ns4__FtpAuthenticationConfiguration *a = (struct ns4__FtpAuthenticationConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpAuthenticationConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpAuthenticationConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpAuthenticationConfiguration(struct soap *soap, const struct ns4__FtpAuthenticationConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpAuthenticationConfiguration(soap, tag ? tag : "ns4:FtpAuthenticationConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpAuthenticationConfiguration * SOAP_FMAC4 soap_get_ns4__FtpAuthenticationConfiguration(struct soap *soap, struct ns4__FtpAuthenticationConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpAuthenticationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpHostAddress(struct soap *soap, struct ns4__FtpHostAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Value);
	soap_default_ns4__AddressFormatType(soap, &a->formatType);
	a->portNo = (char*)"21";
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpHostAddress(struct soap *soap, const struct ns4__FtpHostAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpHostAddress(struct soap *soap, const char *tag, int id, const struct ns4__FtpHostAddress *a, const char *type)
{
	soap_set_attr(soap, "formatType", soap_ns4__AddressFormatType2s(soap, a->formatType), 1);
	if (a->portNo)
		soap_set_attr(soap, "portNo", soap_xsd__integer2s(soap, a->portNo), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpHostAddress), type))
		return soap->error;
	if (!a->Value)
	{	if (soap_element_nil(soap, "ns4:Value"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:Value", -1, (char*const*)&a->Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpHostAddress * SOAP_FMAC4 soap_in_ns4__FtpHostAddress(struct soap *soap, const char *tag, struct ns4__FtpHostAddress *a, const char *type)
{
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpHostAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpHostAddress, sizeof(struct ns4__FtpHostAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpHostAddress(soap, a);
	if (soap_s2ns4__AddressFormatType(soap, soap_attr_value(soap, "formatType", 1), &a->formatType))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "portNo", 0), &a->portNo))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Value", (char**)&a->Value, "xsd:string"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpHostAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpHostAddress, SOAP_TYPE_ns4__FtpHostAddress, sizeof(struct ns4__FtpHostAddress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpHostAddress * SOAP_FMAC4 soap_new_ns4__FtpHostAddress(struct soap *soap, int n)
{
	struct ns4__FtpHostAddress *p;
	struct ns4__FtpHostAddress *a = (struct ns4__FtpHostAddress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpHostAddress));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpHostAddress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpHostAddress(struct soap *soap, const struct ns4__FtpHostAddress *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpHostAddress(soap, tag ? tag : "ns4:FtpHostAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpHostAddress * SOAP_FMAC4 soap_get_ns4__FtpHostAddress(struct soap *soap, struct ns4__FtpHostAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpHostAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpHostConfigurationsExtension(struct soap *soap, struct ns4__FtpHostConfigurationsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpHostConfigurationsExtension(struct soap *soap, const struct ns4__FtpHostConfigurationsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpHostConfigurationsExtension(struct soap *soap, const char *tag, int id, const struct ns4__FtpHostConfigurationsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpHostConfigurationsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpHostConfigurationsExtension * SOAP_FMAC4 soap_in_ns4__FtpHostConfigurationsExtension(struct soap *soap, const char *tag, struct ns4__FtpHostConfigurationsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpHostConfigurationsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpHostConfigurationsExtension, sizeof(struct ns4__FtpHostConfigurationsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpHostConfigurationsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__FtpHostConfigurationsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpHostConfigurationsExtension, SOAP_TYPE_ns4__FtpHostConfigurationsExtension, sizeof(struct ns4__FtpHostConfigurationsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpHostConfigurationsExtension * SOAP_FMAC4 soap_new_ns4__FtpHostConfigurationsExtension(struct soap *soap, int n)
{
	struct ns4__FtpHostConfigurationsExtension *p;
	struct ns4__FtpHostConfigurationsExtension *a = (struct ns4__FtpHostConfigurationsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpHostConfigurationsExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpHostConfigurationsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpHostConfigurationsExtension(struct soap *soap, const struct ns4__FtpHostConfigurationsExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpHostConfigurationsExtension(soap, tag ? tag : "ns4:FtpHostConfigurationsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpHostConfigurationsExtension * SOAP_FMAC4 soap_get_ns4__FtpHostConfigurationsExtension(struct soap *soap, struct ns4__FtpHostConfigurationsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpHostConfigurationsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpDestinationConfiguration(struct soap *soap, struct ns4__FtpDestinationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostAddress = NULL;
	soap_default_string(soap, &a->UploadPath);
	a->FtpAuthentication = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpDestinationConfiguration(struct soap *soap, const struct ns4__FtpDestinationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__FtpHostAddress(soap, &a->HostAddress);
	soap_serialize_string(soap, (char*const*)&a->UploadPath);
	soap_serialize_PointerTons4__FtpAuthenticationConfiguration(soap, &a->FtpAuthentication);
	soap_serialize_PointerTons4__FtpDestinationConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpDestinationConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__FtpDestinationConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpDestinationConfiguration), type))
		return soap->error;
	if (!a->HostAddress)
	{	if (soap_element_nil(soap, "ns4:HostAddress"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__FtpHostAddress(soap, "ns4:HostAddress", -1, &a->HostAddress, ""))
		return soap->error;
	if (!a->UploadPath)
	{	if (soap_element_nil(soap, "ns4:UploadPath"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:UploadPath", -1, (char*const*)&a->UploadPath, ""))
		return soap->error;
	if (!a->FtpAuthentication)
	{	if (soap_element_nil(soap, "ns4:FtpAuthentication"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__FtpAuthenticationConfiguration(soap, "ns4:FtpAuthentication", -1, &a->FtpAuthentication, ""))
		return soap->error;
	if (soap_out_PointerTons4__FtpDestinationConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpDestinationConfiguration * SOAP_FMAC4 soap_in_ns4__FtpDestinationConfiguration(struct soap *soap, const char *tag, struct ns4__FtpDestinationConfiguration *a, const char *type)
{
	size_t soap_flag_HostAddress = 1;
	size_t soap_flag_UploadPath = 1;
	size_t soap_flag_FtpAuthentication = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpDestinationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpDestinationConfiguration, sizeof(struct ns4__FtpDestinationConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpDestinationConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpHostAddress(soap, "ns4:HostAddress", &a->HostAddress, "ns4:FtpHostAddress"))
				{	soap_flag_HostAddress--;
					continue;
				}
			if (soap_flag_UploadPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:UploadPath", (char**)&a->UploadPath, "xsd:string"))
				{	soap_flag_UploadPath--;
					continue;
				}
			if (soap_flag_FtpAuthentication && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpAuthenticationConfiguration(soap, "ns4:FtpAuthentication", &a->FtpAuthentication, "ns4:FtpAuthenticationConfiguration"))
				{	soap_flag_FtpAuthentication--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpDestinationConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:FtpDestinationConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostAddress > 0 || soap_flag_UploadPath > 0 || soap_flag_FtpAuthentication > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpDestinationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpDestinationConfiguration, SOAP_TYPE_ns4__FtpDestinationConfiguration, sizeof(struct ns4__FtpDestinationConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpDestinationConfiguration * SOAP_FMAC4 soap_new_ns4__FtpDestinationConfiguration(struct soap *soap, int n)
{
	struct ns4__FtpDestinationConfiguration *p;
	struct ns4__FtpDestinationConfiguration *a = (struct ns4__FtpDestinationConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpDestinationConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpDestinationConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpDestinationConfiguration(struct soap *soap, const struct ns4__FtpDestinationConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpDestinationConfiguration(soap, tag ? tag : "ns4:FtpDestinationConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpDestinationConfiguration * SOAP_FMAC4 soap_get_ns4__FtpDestinationConfiguration(struct soap *soap, struct ns4__FtpDestinationConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpDestinationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__FtpHostConfigurations(struct soap *soap, struct ns4__FtpHostConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeFtpDestination = 0;
	a->FtpDestination = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__FtpHostConfigurations(struct soap *soap, const struct ns4__FtpHostConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->FtpDestination)
	{	int i;
		for (i = 0; i < (int)a->__sizeFtpDestination; i++)
		{
			soap_embedded(soap, a->FtpDestination + i, SOAP_TYPE_ns4__FtpDestinationConfiguration);
			soap_serialize_ns4__FtpDestinationConfiguration(soap, a->FtpDestination + i);
		}
	}
	soap_serialize_PointerTons4__FtpHostConfigurationsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FtpHostConfigurations(struct soap *soap, const char *tag, int id, const struct ns4__FtpHostConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FtpHostConfigurations), type))
		return soap->error;
	if (a->FtpDestination)
	{	int i;
		for (i = 0; i < (int)a->__sizeFtpDestination; i++)
			if (soap_out_ns4__FtpDestinationConfiguration(soap, "ns4:FtpDestination", -1, a->FtpDestination + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons4__FtpHostConfigurationsExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__FtpHostConfigurations * SOAP_FMAC4 soap_in_ns4__FtpHostConfigurations(struct soap *soap, const char *tag, struct ns4__FtpHostConfigurations *a, const char *type)
{
	struct soap_blist *soap_blist_FtpDestination = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__FtpHostConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FtpHostConfigurations, sizeof(struct ns4__FtpHostConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__FtpHostConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:FtpDestination", 1, NULL))
			{	if (a->FtpDestination == NULL)
				{	if (soap_blist_FtpDestination == NULL)
						soap_blist_FtpDestination = soap_alloc_block(soap);
					a->FtpDestination = (struct ns4__FtpDestinationConfiguration *)soap_push_block_max(soap, soap_blist_FtpDestination, sizeof(struct ns4__FtpDestinationConfiguration));
					if (a->FtpDestination == NULL)
						return NULL;
					soap_default_ns4__FtpDestinationConfiguration(soap, a->FtpDestination);
				}
				soap_revert(soap);
				if (soap_in_ns4__FtpDestinationConfiguration(soap, "ns4:FtpDestination", a->FtpDestination, "ns4:FtpDestinationConfiguration"))
				{	a->__sizeFtpDestination++;
					a->FtpDestination = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FtpHostConfigurationsExtension(soap, "ns4:Extension", &a->Extension, "ns4:FtpHostConfigurationsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->FtpDestination)
			soap_pop_block(soap, soap_blist_FtpDestination);
		if (a->__sizeFtpDestination)
		{	a->FtpDestination = (struct ns4__FtpDestinationConfiguration *)soap_save_block(soap, soap_blist_FtpDestination, NULL, 1);
		}
		else
		{	a->FtpDestination = NULL;
			if (soap_blist_FtpDestination)
				soap_end_block(soap, soap_blist_FtpDestination);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeFtpDestination < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__FtpHostConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FtpHostConfigurations, SOAP_TYPE_ns4__FtpHostConfigurations, sizeof(struct ns4__FtpHostConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__FtpHostConfigurations * SOAP_FMAC4 soap_new_ns4__FtpHostConfigurations(struct soap *soap, int n)
{
	struct ns4__FtpHostConfigurations *p;
	struct ns4__FtpHostConfigurations *a = (struct ns4__FtpHostConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__FtpHostConfigurations));
	for (p = a; p && n--; p++)
		soap_default_ns4__FtpHostConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FtpHostConfigurations(struct soap *soap, const struct ns4__FtpHostConfigurations *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FtpHostConfigurations(soap, tag ? tag : "ns4:FtpHostConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__FtpHostConfigurations * SOAP_FMAC4 soap_get_ns4__FtpHostConfigurations(struct soap *soap, struct ns4__FtpHostConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FtpHostConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__PostBodyConfiguration(struct soap *soap, struct ns4__PostBodyConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->formData);
	a->includeEvent = NULL;
	a->includeMedia = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__PostBodyConfiguration(struct soap *soap, const struct ns4__PostBodyConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PostBodyConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__PostBodyConfiguration *a, const char *type)
{
	if (a->formData)
		soap_set_attr(soap, "formData", soap_string2s(soap, a->formData), 1);
	if (a->includeEvent)
		soap_set_attr(soap, "includeEvent", soap_xsd__boolean2s(soap, *a->includeEvent), 1);
	if (a->includeMedia)
		soap_set_attr(soap, "includeMedia", soap_xsd__boolean2s(soap, *a->includeMedia), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__PostBodyConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__PostBodyConfiguration * SOAP_FMAC4 soap_in_ns4__PostBodyConfiguration(struct soap *soap, const char *tag, struct ns4__PostBodyConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__PostBodyConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__PostBodyConfiguration, sizeof(struct ns4__PostBodyConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__PostBodyConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "formData", 0), &a->formData))
		return NULL;
	{	const char *t = soap_attr_value(soap, "includeEvent", 0);
		if (t)
		{
			if (!(a->includeEvent = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->includeEvent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "includeMedia", 0);
		if (t)
		{
			if (!(a->includeMedia = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->includeMedia))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__PostBodyConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__PostBodyConfiguration, SOAP_TYPE_ns4__PostBodyConfiguration, sizeof(struct ns4__PostBodyConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__PostBodyConfiguration * SOAP_FMAC4 soap_new_ns4__PostBodyConfiguration(struct soap *soap, int n)
{
	struct ns4__PostBodyConfiguration *p;
	struct ns4__PostBodyConfiguration *a = (struct ns4__PostBodyConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__PostBodyConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__PostBodyConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__PostBodyConfiguration(struct soap *soap, const struct ns4__PostBodyConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__PostBodyConfiguration(soap, tag ? tag : "ns4:PostBodyConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__PostBodyConfiguration * SOAP_FMAC4 soap_get_ns4__PostBodyConfiguration(struct soap *soap, struct ns4__PostBodyConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PostBodyConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__PostContentConfiguration(struct soap *soap, struct ns4__PostContentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaReference = NULL;
	a->PostBody = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__PostContentConfiguration(struct soap *soap, const struct ns4__PostContentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__MediaSource(soap, &a->MediaReference);
	soap_serialize_PointerTons4__PostBodyConfiguration(soap, &a->PostBody);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PostContentConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__PostContentConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__PostContentConfiguration), type))
		return soap->error;
	if (soap_out_PointerTons4__MediaSource(soap, "ns4:MediaReference", -1, &a->MediaReference, ""))
		return soap->error;
	if (!a->PostBody)
	{	if (soap_element_nil(soap, "ns4:PostBody"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__PostBodyConfiguration(soap, "ns4:PostBody", -1, &a->PostBody, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__PostContentConfiguration * SOAP_FMAC4 soap_in_ns4__PostContentConfiguration(struct soap *soap, const char *tag, struct ns4__PostContentConfiguration *a, const char *type)
{
	size_t soap_flag_MediaReference = 1;
	size_t soap_flag_PostBody = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__PostContentConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__PostContentConfiguration, sizeof(struct ns4__PostContentConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__PostContentConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__MediaSource(soap, "ns4:MediaReference", &a->MediaReference, "ns4:MediaSource"))
				{	soap_flag_MediaReference--;
					continue;
				}
			if (soap_flag_PostBody && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PostBodyConfiguration(soap, "ns4:PostBody", &a->PostBody, "ns4:PostBodyConfiguration"))
				{	soap_flag_PostBody--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PostBody > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__PostContentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__PostContentConfiguration, SOAP_TYPE_ns4__PostContentConfiguration, sizeof(struct ns4__PostContentConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__PostContentConfiguration * SOAP_FMAC4 soap_new_ns4__PostContentConfiguration(struct soap *soap, int n)
{
	struct ns4__PostContentConfiguration *p;
	struct ns4__PostContentConfiguration *a = (struct ns4__PostContentConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__PostContentConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__PostContentConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__PostContentConfiguration(struct soap *soap, const struct ns4__PostContentConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__PostContentConfiguration(soap, tag ? tag : "ns4:PostContentConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__PostContentConfiguration * SOAP_FMAC4 soap_get_ns4__PostContentConfiguration(struct soap *soap, struct ns4__PostContentConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PostContentConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, struct ns4__HttpAuthenticationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, const struct ns4__HttpAuthenticationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__HttpAuthenticationConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpAuthenticationConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpAuthenticationConfigurationExtension * SOAP_FMAC4 soap_in_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, struct ns4__HttpAuthenticationConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpAuthenticationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpAuthenticationConfigurationExtension, sizeof(struct ns4__HttpAuthenticationConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpAuthenticationConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__HttpAuthenticationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpAuthenticationConfigurationExtension, SOAP_TYPE_ns4__HttpAuthenticationConfigurationExtension, sizeof(struct ns4__HttpAuthenticationConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpAuthenticationConfigurationExtension * SOAP_FMAC4 soap_new_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__HttpAuthenticationConfigurationExtension *p;
	struct ns4__HttpAuthenticationConfigurationExtension *a = (struct ns4__HttpAuthenticationConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpAuthenticationConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpAuthenticationConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, const struct ns4__HttpAuthenticationConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpAuthenticationConfigurationExtension(soap, tag ? tag : "ns4:HttpAuthenticationConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpAuthenticationConfigurationExtension * SOAP_FMAC4 soap_get_ns4__HttpAuthenticationConfigurationExtension(struct soap *soap, struct ns4__HttpAuthenticationConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpAuthenticationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpDestinationConfigurationExtension(struct soap *soap, struct ns4__HttpDestinationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpDestinationConfigurationExtension(struct soap *soap, const struct ns4__HttpDestinationConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpDestinationConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__HttpDestinationConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpDestinationConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpDestinationConfigurationExtension * SOAP_FMAC4 soap_in_ns4__HttpDestinationConfigurationExtension(struct soap *soap, const char *tag, struct ns4__HttpDestinationConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpDestinationConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpDestinationConfigurationExtension, sizeof(struct ns4__HttpDestinationConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpDestinationConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__HttpDestinationConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpDestinationConfigurationExtension, SOAP_TYPE_ns4__HttpDestinationConfigurationExtension, sizeof(struct ns4__HttpDestinationConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpDestinationConfigurationExtension * SOAP_FMAC4 soap_new_ns4__HttpDestinationConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__HttpDestinationConfigurationExtension *p;
	struct ns4__HttpDestinationConfigurationExtension *a = (struct ns4__HttpDestinationConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpDestinationConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpDestinationConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpDestinationConfigurationExtension(struct soap *soap, const struct ns4__HttpDestinationConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpDestinationConfigurationExtension(soap, tag ? tag : "ns4:HttpDestinationConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpDestinationConfigurationExtension * SOAP_FMAC4 soap_get_ns4__HttpDestinationConfigurationExtension(struct soap *soap, struct ns4__HttpDestinationConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpDestinationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpAuthenticationConfiguration(struct soap *soap, struct ns4__HttpAuthenticationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->User = NULL;
	a->Extension = NULL;
	a->method = (enum ns4__HttpAuthenticationMethodType)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpAuthenticationConfiguration(struct soap *soap, const struct ns4__HttpAuthenticationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__UserCredentials(soap, &a->User);
	soap_serialize_PointerTons4__HttpAuthenticationConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpAuthenticationConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__HttpAuthenticationConfiguration *a, const char *type)
{
	soap_set_attr(soap, "method", soap_ns4__HttpAuthenticationMethodType2s(soap, a->method), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpAuthenticationConfiguration), type))
		return soap->error;
	if (soap_out_PointerTons4__UserCredentials(soap, "ns4:User", -1, &a->User, ""))
		return soap->error;
	if (soap_out_PointerTons4__HttpAuthenticationConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpAuthenticationConfiguration * SOAP_FMAC4 soap_in_ns4__HttpAuthenticationConfiguration(struct soap *soap, const char *tag, struct ns4__HttpAuthenticationConfiguration *a, const char *type)
{
	size_t soap_flag_User = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpAuthenticationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpAuthenticationConfiguration, sizeof(struct ns4__HttpAuthenticationConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpAuthenticationConfiguration(soap, a);
	if (soap_s2ns4__HttpAuthenticationMethodType(soap, soap_attr_value(soap, "method", 0), &a->method))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserCredentials(soap, "ns4:User", &a->User, "ns4:UserCredentials"))
				{	soap_flag_User--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HttpAuthenticationConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:HttpAuthenticationConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__HttpAuthenticationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpAuthenticationConfiguration, SOAP_TYPE_ns4__HttpAuthenticationConfiguration, sizeof(struct ns4__HttpAuthenticationConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpAuthenticationConfiguration * SOAP_FMAC4 soap_new_ns4__HttpAuthenticationConfiguration(struct soap *soap, int n)
{
	struct ns4__HttpAuthenticationConfiguration *p;
	struct ns4__HttpAuthenticationConfiguration *a = (struct ns4__HttpAuthenticationConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpAuthenticationConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpAuthenticationConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpAuthenticationConfiguration(struct soap *soap, const struct ns4__HttpAuthenticationConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpAuthenticationConfiguration(soap, tag ? tag : "ns4:HttpAuthenticationConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpAuthenticationConfiguration * SOAP_FMAC4 soap_get_ns4__HttpAuthenticationConfiguration(struct soap *soap, struct ns4__HttpAuthenticationConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpAuthenticationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpHostAddress(struct soap *soap, struct ns4__HttpHostAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Value);
	soap_default_ns4__AddressFormatType(soap, &a->formatType);
	a->portNo = (char*)"80";
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpHostAddress(struct soap *soap, const struct ns4__HttpHostAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpHostAddress(struct soap *soap, const char *tag, int id, const struct ns4__HttpHostAddress *a, const char *type)
{
	soap_set_attr(soap, "formatType", soap_ns4__AddressFormatType2s(soap, a->formatType), 1);
	if (a->portNo)
		soap_set_attr(soap, "portNo", soap_xsd__integer2s(soap, a->portNo), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpHostAddress), type))
		return soap->error;
	if (!a->Value)
	{	if (soap_element_nil(soap, "ns4:Value"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:Value", -1, (char*const*)&a->Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpHostAddress * SOAP_FMAC4 soap_in_ns4__HttpHostAddress(struct soap *soap, const char *tag, struct ns4__HttpHostAddress *a, const char *type)
{
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpHostAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpHostAddress, sizeof(struct ns4__HttpHostAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpHostAddress(soap, a);
	if (soap_s2ns4__AddressFormatType(soap, soap_attr_value(soap, "formatType", 1), &a->formatType))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "portNo", 0), &a->portNo))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Value", (char**)&a->Value, "xsd:string"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__HttpHostAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpHostAddress, SOAP_TYPE_ns4__HttpHostAddress, sizeof(struct ns4__HttpHostAddress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpHostAddress * SOAP_FMAC4 soap_new_ns4__HttpHostAddress(struct soap *soap, int n)
{
	struct ns4__HttpHostAddress *p;
	struct ns4__HttpHostAddress *a = (struct ns4__HttpHostAddress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpHostAddress));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpHostAddress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpHostAddress(struct soap *soap, const struct ns4__HttpHostAddress *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpHostAddress(soap, tag ? tag : "ns4:HttpHostAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpHostAddress * SOAP_FMAC4 soap_get_ns4__HttpHostAddress(struct soap *soap, struct ns4__HttpHostAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpHostAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpHostConfigurationsExtension(struct soap *soap, struct ns4__HttpHostConfigurationsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpHostConfigurationsExtension(struct soap *soap, const struct ns4__HttpHostConfigurationsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpHostConfigurationsExtension(struct soap *soap, const char *tag, int id, const struct ns4__HttpHostConfigurationsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpHostConfigurationsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpHostConfigurationsExtension * SOAP_FMAC4 soap_in_ns4__HttpHostConfigurationsExtension(struct soap *soap, const char *tag, struct ns4__HttpHostConfigurationsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpHostConfigurationsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpHostConfigurationsExtension, sizeof(struct ns4__HttpHostConfigurationsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpHostConfigurationsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__HttpHostConfigurationsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpHostConfigurationsExtension, SOAP_TYPE_ns4__HttpHostConfigurationsExtension, sizeof(struct ns4__HttpHostConfigurationsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpHostConfigurationsExtension * SOAP_FMAC4 soap_new_ns4__HttpHostConfigurationsExtension(struct soap *soap, int n)
{
	struct ns4__HttpHostConfigurationsExtension *p;
	struct ns4__HttpHostConfigurationsExtension *a = (struct ns4__HttpHostConfigurationsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpHostConfigurationsExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpHostConfigurationsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpHostConfigurationsExtension(struct soap *soap, const struct ns4__HttpHostConfigurationsExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpHostConfigurationsExtension(soap, tag ? tag : "ns4:HttpHostConfigurationsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpHostConfigurationsExtension * SOAP_FMAC4 soap_get_ns4__HttpHostConfigurationsExtension(struct soap *soap, struct ns4__HttpHostConfigurationsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpHostConfigurationsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpDestinationConfiguration(struct soap *soap, struct ns4__HttpDestinationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostAddress = NULL;
	a->HttpAuthentication = NULL;
	a->Extension = NULL;
	a->uri = (char*)"/";
	a->protocol = (enum ns4__HttpProtocolType)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpDestinationConfiguration(struct soap *soap, const struct ns4__HttpDestinationConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__HttpHostAddress(soap, &a->HostAddress);
	soap_serialize_PointerTons4__HttpAuthenticationConfiguration(soap, &a->HttpAuthentication);
	soap_serialize_PointerTons4__HttpDestinationConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpDestinationConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__HttpDestinationConfiguration *a, const char *type)
{
	if (a->uri)
		soap_set_attr(soap, "uri", soap_string2s(soap, a->uri), 1);
	soap_set_attr(soap, "protocol", soap_ns4__HttpProtocolType2s(soap, a->protocol), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpDestinationConfiguration), type))
		return soap->error;
	if (!a->HostAddress)
	{	if (soap_element_nil(soap, "ns4:HostAddress"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__HttpHostAddress(soap, "ns4:HostAddress", -1, &a->HostAddress, ""))
		return soap->error;
	if (soap_out_PointerTons4__HttpAuthenticationConfiguration(soap, "ns4:HttpAuthentication", -1, &a->HttpAuthentication, ""))
		return soap->error;
	if (soap_out_PointerTons4__HttpDestinationConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpDestinationConfiguration * SOAP_FMAC4 soap_in_ns4__HttpDestinationConfiguration(struct soap *soap, const char *tag, struct ns4__HttpDestinationConfiguration *a, const char *type)
{
	size_t soap_flag_HostAddress = 1;
	size_t soap_flag_HttpAuthentication = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpDestinationConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpDestinationConfiguration, sizeof(struct ns4__HttpDestinationConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpDestinationConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "uri", 0), &a->uri))
		return NULL;
	if (soap_s2ns4__HttpProtocolType(soap, soap_attr_value(soap, "protocol", 0), &a->protocol))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HttpHostAddress(soap, "ns4:HostAddress", &a->HostAddress, "ns4:HttpHostAddress"))
				{	soap_flag_HostAddress--;
					continue;
				}
			if (soap_flag_HttpAuthentication && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HttpAuthenticationConfiguration(soap, "ns4:HttpAuthentication", &a->HttpAuthentication, "ns4:HttpAuthenticationConfiguration"))
				{	soap_flag_HttpAuthentication--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HttpDestinationConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:HttpDestinationConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostAddress > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__HttpDestinationConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpDestinationConfiguration, SOAP_TYPE_ns4__HttpDestinationConfiguration, sizeof(struct ns4__HttpDestinationConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpDestinationConfiguration * SOAP_FMAC4 soap_new_ns4__HttpDestinationConfiguration(struct soap *soap, int n)
{
	struct ns4__HttpDestinationConfiguration *p;
	struct ns4__HttpDestinationConfiguration *a = (struct ns4__HttpDestinationConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpDestinationConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpDestinationConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpDestinationConfiguration(struct soap *soap, const struct ns4__HttpDestinationConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpDestinationConfiguration(soap, tag ? tag : "ns4:HttpDestinationConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpDestinationConfiguration * SOAP_FMAC4 soap_get_ns4__HttpDestinationConfiguration(struct soap *soap, struct ns4__HttpDestinationConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpDestinationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HttpHostConfigurations(struct soap *soap, struct ns4__HttpHostConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeHttpDestination = 0;
	a->HttpDestination = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HttpHostConfigurations(struct soap *soap, const struct ns4__HttpHostConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->HttpDestination)
	{	int i;
		for (i = 0; i < (int)a->__sizeHttpDestination; i++)
		{
			soap_embedded(soap, a->HttpDestination + i, SOAP_TYPE_ns4__HttpDestinationConfiguration);
			soap_serialize_ns4__HttpDestinationConfiguration(soap, a->HttpDestination + i);
		}
	}
	soap_serialize_PointerTons4__HttpHostConfigurationsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpHostConfigurations(struct soap *soap, const char *tag, int id, const struct ns4__HttpHostConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpHostConfigurations), type))
		return soap->error;
	if (a->HttpDestination)
	{	int i;
		for (i = 0; i < (int)a->__sizeHttpDestination; i++)
			if (soap_out_ns4__HttpDestinationConfiguration(soap, "ns4:HttpDestination", -1, a->HttpDestination + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons4__HttpHostConfigurationsExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HttpHostConfigurations * SOAP_FMAC4 soap_in_ns4__HttpHostConfigurations(struct soap *soap, const char *tag, struct ns4__HttpHostConfigurations *a, const char *type)
{
	struct soap_blist *soap_blist_HttpDestination = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HttpHostConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpHostConfigurations, sizeof(struct ns4__HttpHostConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HttpHostConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:HttpDestination", 1, NULL))
			{	if (a->HttpDestination == NULL)
				{	if (soap_blist_HttpDestination == NULL)
						soap_blist_HttpDestination = soap_alloc_block(soap);
					a->HttpDestination = (struct ns4__HttpDestinationConfiguration *)soap_push_block_max(soap, soap_blist_HttpDestination, sizeof(struct ns4__HttpDestinationConfiguration));
					if (a->HttpDestination == NULL)
						return NULL;
					soap_default_ns4__HttpDestinationConfiguration(soap, a->HttpDestination);
				}
				soap_revert(soap);
				if (soap_in_ns4__HttpDestinationConfiguration(soap, "ns4:HttpDestination", a->HttpDestination, "ns4:HttpDestinationConfiguration"))
				{	a->__sizeHttpDestination++;
					a->HttpDestination = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HttpHostConfigurationsExtension(soap, "ns4:Extension", &a->Extension, "ns4:HttpHostConfigurationsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->HttpDestination)
			soap_pop_block(soap, soap_blist_HttpDestination);
		if (a->__sizeHttpDestination)
		{	a->HttpDestination = (struct ns4__HttpDestinationConfiguration *)soap_save_block(soap, soap_blist_HttpDestination, NULL, 1);
		}
		else
		{	a->HttpDestination = NULL;
			if (soap_blist_HttpDestination)
				soap_end_block(soap, soap_blist_HttpDestination);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeHttpDestination < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__HttpHostConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpHostConfigurations, SOAP_TYPE_ns4__HttpHostConfigurations, sizeof(struct ns4__HttpHostConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HttpHostConfigurations * SOAP_FMAC4 soap_new_ns4__HttpHostConfigurations(struct soap *soap, int n)
{
	struct ns4__HttpHostConfigurations *p;
	struct ns4__HttpHostConfigurations *a = (struct ns4__HttpHostConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HttpHostConfigurations));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpHostConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpHostConfigurations(struct soap *soap, const struct ns4__HttpHostConfigurations *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpHostConfigurations(soap, tag ? tag : "ns4:HttpHostConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HttpHostConfigurations * SOAP_FMAC4 soap_get_ns4__HttpHostConfigurations(struct soap *soap, struct ns4__HttpHostConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpHostConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__MediaSource(struct soap *soap, struct ns4__MediaSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__MediaSource(struct soap *soap, const struct ns4__MediaSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__MediaSource(struct soap *soap, const char *tag, int id, const struct ns4__MediaSource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__MediaSource), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns4:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns4:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__MediaSource * SOAP_FMAC4 soap_in_ns4__MediaSource(struct soap *soap, const char *tag, struct ns4__MediaSource *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__MediaSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__MediaSource, sizeof(struct ns4__MediaSource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__MediaSource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns4:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__MediaSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__MediaSource, SOAP_TYPE_ns4__MediaSource, sizeof(struct ns4__MediaSource), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__MediaSource * SOAP_FMAC4 soap_new_ns4__MediaSource(struct soap *soap, int n)
{
	struct ns4__MediaSource *p;
	struct ns4__MediaSource *a = (struct ns4__MediaSource*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__MediaSource));
	for (p = a; p && n--; p++)
		soap_default_ns4__MediaSource(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__MediaSource(struct soap *soap, const struct ns4__MediaSource *a, const char *tag, const char *type)
{
	if (soap_out_ns4__MediaSource(soap, tag ? tag : "ns4:MediaSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__MediaSource * SOAP_FMAC4 soap_get_ns4__MediaSource(struct soap *soap, struct ns4__MediaSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__MediaSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__EMailBodyTextConfiguration(struct soap *soap, struct ns4__EMailBodyTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->includeEvent = NULL;
	soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__EMailBodyTextConfiguration(struct soap *soap, const struct ns4__EMailBodyTextConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailBodyTextConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__EMailBodyTextConfiguration *a, const char *type)
{
	if (a->includeEvent)
		soap_set_attr(soap, "includeEvent", soap_xsd__boolean2s(soap, *a->includeEvent), 1);
	if (a->type)
		soap_set_attr(soap, "type", soap_string2s(soap, a->type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailBodyTextConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__EMailBodyTextConfiguration * SOAP_FMAC4 soap_in_ns4__EMailBodyTextConfiguration(struct soap *soap, const char *tag, struct ns4__EMailBodyTextConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__EMailBodyTextConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailBodyTextConfiguration, sizeof(struct ns4__EMailBodyTextConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__EMailBodyTextConfiguration(soap, a);
	{	const char *t = soap_attr_value(soap, "includeEvent", 0);
		if (t)
		{
			if (!(a->includeEvent = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->includeEvent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "type", 0), &a->type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__EMailBodyTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailBodyTextConfiguration, SOAP_TYPE_ns4__EMailBodyTextConfiguration, sizeof(struct ns4__EMailBodyTextConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__EMailBodyTextConfiguration * SOAP_FMAC4 soap_new_ns4__EMailBodyTextConfiguration(struct soap *soap, int n)
{
	struct ns4__EMailBodyTextConfiguration *p;
	struct ns4__EMailBodyTextConfiguration *a = (struct ns4__EMailBodyTextConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__EMailBodyTextConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailBodyTextConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailBodyTextConfiguration(struct soap *soap, const struct ns4__EMailBodyTextConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailBodyTextConfiguration(soap, tag ? tag : "ns4:EMailBodyTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__EMailBodyTextConfiguration * SOAP_FMAC4 soap_get_ns4__EMailBodyTextConfiguration(struct soap *soap, struct ns4__EMailBodyTextConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailBodyTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, struct ns4__EMailAttachmentConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, const struct ns4__EMailAttachmentConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__EMailAttachmentConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailAttachmentConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__EMailAttachmentConfigurationExtension * SOAP_FMAC4 soap_in_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, const char *tag, struct ns4__EMailAttachmentConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__EMailAttachmentConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailAttachmentConfigurationExtension, sizeof(struct ns4__EMailAttachmentConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__EMailAttachmentConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__EMailAttachmentConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailAttachmentConfigurationExtension, SOAP_TYPE_ns4__EMailAttachmentConfigurationExtension, sizeof(struct ns4__EMailAttachmentConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__EMailAttachmentConfigurationExtension * SOAP_FMAC4 soap_new_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__EMailAttachmentConfigurationExtension *p;
	struct ns4__EMailAttachmentConfigurationExtension *a = (struct ns4__EMailAttachmentConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__EMailAttachmentConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailAttachmentConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, const struct ns4__EMailAttachmentConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailAttachmentConfigurationExtension(soap, tag ? tag : "ns4:EMailAttachmentConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__EMailAttachmentConfigurationExtension * SOAP_FMAC4 soap_get_ns4__EMailAttachmentConfigurationExtension(struct soap *soap, struct ns4__EMailAttachmentConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailAttachmentConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__EMailAttachmentConfiguration(struct soap *soap, struct ns4__EMailAttachmentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->FileName);
	a->doSuffix = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__EMailAttachmentConfiguration(struct soap *soap, const struct ns4__EMailAttachmentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->FileName);
	soap_serialize_PointerTons4__FileSuffixType(soap, &a->doSuffix);
	soap_serialize_PointerTons4__EMailAttachmentConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailAttachmentConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__EMailAttachmentConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailAttachmentConfiguration), type))
		return soap->error;
	if (soap_out_string(soap, "ns4:FileName", -1, (char*const*)&a->FileName, ""))
		return soap->error;
	if (soap_out_PointerTons4__FileSuffixType(soap, "ns4:doSuffix", -1, &a->doSuffix, ""))
		return soap->error;
	if (soap_out_PointerTons4__EMailAttachmentConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__EMailAttachmentConfiguration * SOAP_FMAC4 soap_in_ns4__EMailAttachmentConfiguration(struct soap *soap, const char *tag, struct ns4__EMailAttachmentConfiguration *a, const char *type)
{
	size_t soap_flag_FileName = 1;
	size_t soap_flag_doSuffix = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__EMailAttachmentConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailAttachmentConfiguration, sizeof(struct ns4__EMailAttachmentConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__EMailAttachmentConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:FileName", (char**)&a->FileName, "xsd:string"))
				{	soap_flag_FileName--;
					continue;
				}
			if (soap_flag_doSuffix && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__FileSuffixType(soap, "ns4:doSuffix", &a->doSuffix, "ns4:FileSuffixType"))
				{	soap_flag_doSuffix--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EMailAttachmentConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:EMailAttachmentConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__EMailAttachmentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailAttachmentConfiguration, SOAP_TYPE_ns4__EMailAttachmentConfiguration, sizeof(struct ns4__EMailAttachmentConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__EMailAttachmentConfiguration * SOAP_FMAC4 soap_new_ns4__EMailAttachmentConfiguration(struct soap *soap, int n)
{
	struct ns4__EMailAttachmentConfiguration *p;
	struct ns4__EMailAttachmentConfiguration *a = (struct ns4__EMailAttachmentConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__EMailAttachmentConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailAttachmentConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailAttachmentConfiguration(struct soap *soap, const struct ns4__EMailAttachmentConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailAttachmentConfiguration(soap, tag ? tag : "ns4:EMailAttachmentConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__EMailAttachmentConfiguration * SOAP_FMAC4 soap_get_ns4__EMailAttachmentConfiguration(struct soap *soap, struct ns4__EMailAttachmentConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailAttachmentConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__EMailReceiverConfigurationExtension(struct soap *soap, struct ns4__EMailReceiverConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__EMailReceiverConfigurationExtension(struct soap *soap, const struct ns4__EMailReceiverConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailReceiverConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__EMailReceiverConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailReceiverConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__EMailReceiverConfigurationExtension * SOAP_FMAC4 soap_in_ns4__EMailReceiverConfigurationExtension(struct soap *soap, const char *tag, struct ns4__EMailReceiverConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__EMailReceiverConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailReceiverConfigurationExtension, sizeof(struct ns4__EMailReceiverConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__EMailReceiverConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__EMailReceiverConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailReceiverConfigurationExtension, SOAP_TYPE_ns4__EMailReceiverConfigurationExtension, sizeof(struct ns4__EMailReceiverConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__EMailReceiverConfigurationExtension * SOAP_FMAC4 soap_new_ns4__EMailReceiverConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__EMailReceiverConfigurationExtension *p;
	struct ns4__EMailReceiverConfigurationExtension *a = (struct ns4__EMailReceiverConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__EMailReceiverConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailReceiverConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailReceiverConfigurationExtension(struct soap *soap, const struct ns4__EMailReceiverConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailReceiverConfigurationExtension(soap, tag ? tag : "ns4:EMailReceiverConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__EMailReceiverConfigurationExtension * SOAP_FMAC4 soap_get_ns4__EMailReceiverConfigurationExtension(struct soap *soap, struct ns4__EMailReceiverConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailReceiverConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__EMailReceiverConfiguration(struct soap *soap, struct ns4__EMailReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTO = 0;
	a->TO = NULL;
	a->__sizeCC = 0;
	a->CC = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__EMailReceiverConfiguration(struct soap *soap, const struct ns4__EMailReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->TO)
	{	int i;
		for (i = 0; i < (int)a->__sizeTO; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->TO + i));
		}
	}
	if (a->CC)
	{	int i;
		for (i = 0; i < (int)a->__sizeCC; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->CC + i));
		}
	}
	soap_serialize_PointerTons4__EMailReceiverConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailReceiverConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__EMailReceiverConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailReceiverConfiguration), type))
		return soap->error;
	if (a->TO)
	{	int i;
		for (i = 0; i < (int)a->__sizeTO; i++)
			soap_out_string(soap, "ns4:TO", -1, (char*const*)(a->TO + i), "");
	}
	if (a->CC)
	{	int i;
		for (i = 0; i < (int)a->__sizeCC; i++)
			soap_out_string(soap, "ns4:CC", -1, (char*const*)(a->CC + i), "");
	}
	if (soap_out_PointerTons4__EMailReceiverConfigurationExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__EMailReceiverConfiguration * SOAP_FMAC4 soap_in_ns4__EMailReceiverConfiguration(struct soap *soap, const char *tag, struct ns4__EMailReceiverConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_TO = NULL;
	struct soap_blist *soap_blist_CC = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__EMailReceiverConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailReceiverConfiguration, sizeof(struct ns4__EMailReceiverConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__EMailReceiverConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:TO", 1, NULL))
			{	if (a->TO == NULL)
				{	if (soap_blist_TO == NULL)
						soap_blist_TO = soap_alloc_block(soap);
					a->TO = (char **)soap_push_block_max(soap, soap_blist_TO, sizeof(char *));
					if (a->TO == NULL)
						return NULL;
					*a->TO = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns4:TO", (char**)a->TO, "xsd:string"))
				{	a->__sizeTO++;
					a->TO = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:CC", 1, NULL))
			{	if (a->CC == NULL)
				{	if (soap_blist_CC == NULL)
						soap_blist_CC = soap_alloc_block(soap);
					a->CC = (char **)soap_push_block_max(soap, soap_blist_CC, sizeof(char *));
					if (a->CC == NULL)
						return NULL;
					*a->CC = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns4:CC", (char**)a->CC, "xsd:string"))
				{	a->__sizeCC++;
					a->CC = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__EMailReceiverConfigurationExtension(soap, "ns4:Extension", &a->Extension, "ns4:EMailReceiverConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TO)
			soap_pop_block(soap, soap_blist_TO);
		if (a->__sizeTO)
		{	a->TO = (char **)soap_save_block(soap, soap_blist_TO, NULL, 1);
		}
		else
		{	a->TO = NULL;
			if (soap_blist_TO)
				soap_end_block(soap, soap_blist_TO);
		}
		if (a->CC)
			soap_pop_block(soap, soap_blist_CC);
		if (a->__sizeCC)
		{	a->CC = (char **)soap_save_block(soap, soap_blist_CC, NULL, 1);
		}
		else
		{	a->CC = NULL;
			if (soap_blist_CC)
				soap_end_block(soap, soap_blist_CC);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeTO < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__EMailReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailReceiverConfiguration, SOAP_TYPE_ns4__EMailReceiverConfiguration, sizeof(struct ns4__EMailReceiverConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__EMailReceiverConfiguration * SOAP_FMAC4 soap_new_ns4__EMailReceiverConfiguration(struct soap *soap, int n)
{
	struct ns4__EMailReceiverConfiguration *p;
	struct ns4__EMailReceiverConfiguration *a = (struct ns4__EMailReceiverConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__EMailReceiverConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailReceiverConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailReceiverConfiguration(struct soap *soap, const struct ns4__EMailReceiverConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailReceiverConfiguration(soap, tag ? tag : "ns4:EMailReceiverConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__EMailReceiverConfiguration * SOAP_FMAC4 soap_get_ns4__EMailReceiverConfiguration(struct soap *soap, struct ns4__EMailReceiverConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UserCredentialsExtension(struct soap *soap, struct ns4__UserCredentialsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UserCredentialsExtension(struct soap *soap, const struct ns4__UserCredentialsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UserCredentialsExtension(struct soap *soap, const char *tag, int id, const struct ns4__UserCredentialsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UserCredentialsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UserCredentialsExtension * SOAP_FMAC4 soap_in_ns4__UserCredentialsExtension(struct soap *soap, const char *tag, struct ns4__UserCredentialsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UserCredentialsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UserCredentialsExtension, sizeof(struct ns4__UserCredentialsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UserCredentialsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__UserCredentialsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UserCredentialsExtension, SOAP_TYPE_ns4__UserCredentialsExtension, sizeof(struct ns4__UserCredentialsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__UserCredentialsExtension * SOAP_FMAC4 soap_new_ns4__UserCredentialsExtension(struct soap *soap, int n)
{
	struct ns4__UserCredentialsExtension *p;
	struct ns4__UserCredentialsExtension *a = (struct ns4__UserCredentialsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__UserCredentialsExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__UserCredentialsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UserCredentialsExtension(struct soap *soap, const struct ns4__UserCredentialsExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__UserCredentialsExtension(soap, tag ? tag : "ns4:UserCredentialsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UserCredentialsExtension * SOAP_FMAC4 soap_get_ns4__UserCredentialsExtension(struct soap *soap, struct ns4__UserCredentialsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UserCredentialsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__UserCredentials(struct soap *soap, struct ns4__UserCredentials *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_xsd__base64Binary(soap, &a->password);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__UserCredentials(struct soap *soap, const struct ns4__UserCredentials *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->username);
	soap_serialize_xsd__base64Binary(soap, &a->password);
	soap_serialize_PointerTons4__UserCredentialsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UserCredentials(struct soap *soap, const char *tag, int id, const struct ns4__UserCredentials *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UserCredentials), type))
		return soap->error;
	if (!a->username)
	{	if (soap_element_nil(soap, "ns4:username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:username", -1, (char*const*)&a->username, ""))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "ns4:password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_PointerTons4__UserCredentialsExtension(soap, "ns4:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__UserCredentials * SOAP_FMAC4 soap_in_ns4__UserCredentials(struct soap *soap, const char *tag, struct ns4__UserCredentials *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__UserCredentials *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UserCredentials, sizeof(struct ns4__UserCredentials), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__UserCredentials(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:username", (char**)&a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__base64Binary(soap, "ns4:password", &a->password, "xsd:base64Binary"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserCredentialsExtension(soap, "ns4:Extension", &a->Extension, "ns4:UserCredentialsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__UserCredentials *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UserCredentials, SOAP_TYPE_ns4__UserCredentials, sizeof(struct ns4__UserCredentials), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__UserCredentials * SOAP_FMAC4 soap_new_ns4__UserCredentials(struct soap *soap, int n)
{
	struct ns4__UserCredentials *p;
	struct ns4__UserCredentials *a = (struct ns4__UserCredentials*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__UserCredentials));
	for (p = a; p && n--; p++)
		soap_default_ns4__UserCredentials(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__UserCredentials(struct soap *soap, const struct ns4__UserCredentials *a, const char *tag, const char *type)
{
	if (soap_out_ns4__UserCredentials(soap, tag ? tag : "ns4:UserCredentials", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__UserCredentials * SOAP_FMAC4 soap_get_ns4__UserCredentials(struct soap *soap, struct ns4__UserCredentials *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UserCredentials(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__HostAddress(struct soap *soap, struct ns4__HostAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Value);
	soap_default_ns4__AddressFormatType(soap, &a->formatType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__HostAddress(struct soap *soap, const struct ns4__HostAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HostAddress(struct soap *soap, const char *tag, int id, const struct ns4__HostAddress *a, const char *type)
{
	soap_set_attr(soap, "formatType", soap_ns4__AddressFormatType2s(soap, a->formatType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HostAddress), type))
		return soap->error;
	if (!a->Value)
	{	if (soap_element_nil(soap, "ns4:Value"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns4:Value", -1, (char*const*)&a->Value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__HostAddress * SOAP_FMAC4 soap_in_ns4__HostAddress(struct soap *soap, const char *tag, struct ns4__HostAddress *a, const char *type)
{
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__HostAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HostAddress, sizeof(struct ns4__HostAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__HostAddress(soap, a);
	if (soap_s2ns4__AddressFormatType(soap, soap_attr_value(soap, "formatType", 1), &a->formatType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns4:Value", (char**)&a->Value, "xsd:string"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Value > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__HostAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HostAddress, SOAP_TYPE_ns4__HostAddress, sizeof(struct ns4__HostAddress), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__HostAddress * SOAP_FMAC4 soap_new_ns4__HostAddress(struct soap *soap, int n)
{
	struct ns4__HostAddress *p;
	struct ns4__HostAddress *a = (struct ns4__HostAddress*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__HostAddress));
	for (p = a; p && n--; p++)
		soap_default_ns4__HostAddress(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HostAddress(struct soap *soap, const struct ns4__HostAddress *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HostAddress(soap, tag ? tag : "ns4:HostAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__HostAddress * SOAP_FMAC4 soap_get_ns4__HostAddress(struct soap *soap, struct ns4__HostAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HostAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__AuthenticationConfig(struct soap *soap, struct ns4__AuthenticationConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->User = NULL;
	soap_default_ns4__EMailAuthenticationMode(soap, &a->mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__AuthenticationConfig(struct soap *soap, const struct ns4__AuthenticationConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__UserCredentials(soap, &a->User);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AuthenticationConfig(struct soap *soap, const char *tag, int id, const struct ns4__AuthenticationConfig *a, const char *type)
{
	soap_set_attr(soap, "mode", soap_ns4__EMailAuthenticationMode2s(soap, a->mode), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__AuthenticationConfig), type))
		return soap->error;
	if (!a->User)
	{	if (soap_element_nil(soap, "ns4:User"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__UserCredentials(soap, "ns4:User", -1, &a->User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__AuthenticationConfig * SOAP_FMAC4 soap_in_ns4__AuthenticationConfig(struct soap *soap, const char *tag, struct ns4__AuthenticationConfig *a, const char *type)
{
	size_t soap_flag_User = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__AuthenticationConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AuthenticationConfig, sizeof(struct ns4__AuthenticationConfig), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__AuthenticationConfig(soap, a);
	if (soap_s2ns4__EMailAuthenticationMode(soap, soap_attr_value(soap, "mode", 1), &a->mode))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserCredentials(soap, "ns4:User", &a->User, "ns4:UserCredentials"))
				{	soap_flag_User--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_User > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__AuthenticationConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AuthenticationConfig, SOAP_TYPE_ns4__AuthenticationConfig, sizeof(struct ns4__AuthenticationConfig), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__AuthenticationConfig * SOAP_FMAC4 soap_new_ns4__AuthenticationConfig(struct soap *soap, int n)
{
	struct ns4__AuthenticationConfig *p;
	struct ns4__AuthenticationConfig *a = (struct ns4__AuthenticationConfig*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__AuthenticationConfig));
	for (p = a; p && n--; p++)
		soap_default_ns4__AuthenticationConfig(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__AuthenticationConfig(struct soap *soap, const struct ns4__AuthenticationConfig *a, const char *tag, const char *type)
{
	if (soap_out_ns4__AuthenticationConfig(soap, tag ? tag : "ns4:AuthenticationConfig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__AuthenticationConfig * SOAP_FMAC4 soap_get_ns4__AuthenticationConfig(struct soap *soap, struct ns4__AuthenticationConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AuthenticationConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__POPConfig(struct soap *soap, struct ns4__POPConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__POPConfig(struct soap *soap, const struct ns4__POPConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__HostAddress(soap, &a->HostAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__POPConfig(struct soap *soap, const char *tag, int id, const struct ns4__POPConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__POPConfig), type))
		return soap->error;
	if (!a->HostAddress)
	{	if (soap_element_nil(soap, "ns4:HostAddress"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__HostAddress(soap, "ns4:HostAddress", -1, &a->HostAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__POPConfig * SOAP_FMAC4 soap_in_ns4__POPConfig(struct soap *soap, const char *tag, struct ns4__POPConfig *a, const char *type)
{
	size_t soap_flag_HostAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__POPConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__POPConfig, sizeof(struct ns4__POPConfig), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__POPConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HostAddress(soap, "ns4:HostAddress", &a->HostAddress, "ns4:HostAddress"))
				{	soap_flag_HostAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostAddress > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__POPConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__POPConfig, SOAP_TYPE_ns4__POPConfig, sizeof(struct ns4__POPConfig), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__POPConfig * SOAP_FMAC4 soap_new_ns4__POPConfig(struct soap *soap, int n)
{
	struct ns4__POPConfig *p;
	struct ns4__POPConfig *a = (struct ns4__POPConfig*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__POPConfig));
	for (p = a; p && n--; p++)
		soap_default_ns4__POPConfig(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__POPConfig(struct soap *soap, const struct ns4__POPConfig *a, const char *tag, const char *type)
{
	if (soap_out_ns4__POPConfig(soap, tag ? tag : "ns4:POPConfig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__POPConfig * SOAP_FMAC4 soap_get_ns4__POPConfig(struct soap *soap, struct ns4__POPConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__POPConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__SMTPConfig(struct soap *soap, struct ns4__SMTPConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostAddress = NULL;
	soap_default_xsd__positiveInteger(soap, &a->portNo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__SMTPConfig(struct soap *soap, const struct ns4__SMTPConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__HostAddress(soap, &a->HostAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__SMTPConfig(struct soap *soap, const char *tag, int id, const struct ns4__SMTPConfig *a, const char *type)
{
	if (a->portNo)
		soap_set_attr(soap, "portNo", soap_xsd__positiveInteger2s(soap, a->portNo), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__SMTPConfig), type))
		return soap->error;
	if (!a->HostAddress)
	{	if (soap_element_nil(soap, "ns4:HostAddress"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__HostAddress(soap, "ns4:HostAddress", -1, &a->HostAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__SMTPConfig * SOAP_FMAC4 soap_in_ns4__SMTPConfig(struct soap *soap, const char *tag, struct ns4__SMTPConfig *a, const char *type)
{
	size_t soap_flag_HostAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__SMTPConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__SMTPConfig, sizeof(struct ns4__SMTPConfig), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__SMTPConfig(soap, a);
	if (soap_s2xsd__positiveInteger(soap, soap_attr_value(soap, "portNo", 0), &a->portNo))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__HostAddress(soap, "ns4:HostAddress", &a->HostAddress, "ns4:HostAddress"))
				{	soap_flag_HostAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostAddress > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__SMTPConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__SMTPConfig, SOAP_TYPE_ns4__SMTPConfig, sizeof(struct ns4__SMTPConfig), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__SMTPConfig * SOAP_FMAC4 soap_new_ns4__SMTPConfig(struct soap *soap, int n)
{
	struct ns4__SMTPConfig *p;
	struct ns4__SMTPConfig *a = (struct ns4__SMTPConfig*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__SMTPConfig));
	for (p = a; p && n--; p++)
		soap_default_ns4__SMTPConfig(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__SMTPConfig(struct soap *soap, const struct ns4__SMTPConfig *a, const char *tag, const char *type)
{
	if (soap_out_ns4__SMTPConfig(soap, tag ? tag : "ns4:SMTPConfig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__SMTPConfig * SOAP_FMAC4 soap_get_ns4__SMTPConfig(struct soap *soap, struct ns4__SMTPConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__SMTPConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__EMailServerConfiguration(struct soap *soap, struct ns4__EMailServerConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SMTPConfig = NULL;
	a->POPConfig = NULL;
	a->AuthenticationConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__EMailServerConfiguration(struct soap *soap, const struct ns4__EMailServerConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__SMTPConfig(soap, &a->SMTPConfig);
	soap_serialize_PointerTons4__POPConfig(soap, &a->POPConfig);
	soap_serialize_PointerTons4__AuthenticationConfig(soap, &a->AuthenticationConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailServerConfiguration(struct soap *soap, const char *tag, int id, const struct ns4__EMailServerConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailServerConfiguration), type))
		return soap->error;
	if (!a->SMTPConfig)
	{	if (soap_element_nil(soap, "ns4:SMTPConfig"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__SMTPConfig(soap, "ns4:SMTPConfig", -1, &a->SMTPConfig, ""))
		return soap->error;
	if (!a->POPConfig)
	{	if (soap_element_nil(soap, "ns4:POPConfig"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__POPConfig(soap, "ns4:POPConfig", -1, &a->POPConfig, ""))
		return soap->error;
	if (!a->AuthenticationConfig)
	{	if (soap_element_nil(soap, "ns4:AuthenticationConfig"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__AuthenticationConfig(soap, "ns4:AuthenticationConfig", -1, &a->AuthenticationConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__EMailServerConfiguration * SOAP_FMAC4 soap_in_ns4__EMailServerConfiguration(struct soap *soap, const char *tag, struct ns4__EMailServerConfiguration *a, const char *type)
{
	size_t soap_flag_SMTPConfig = 1;
	size_t soap_flag_POPConfig = 1;
	size_t soap_flag_AuthenticationConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__EMailServerConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailServerConfiguration, sizeof(struct ns4__EMailServerConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__EMailServerConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SMTPConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__SMTPConfig(soap, "ns4:SMTPConfig", &a->SMTPConfig, "ns4:SMTPConfig"))
				{	soap_flag_SMTPConfig--;
					continue;
				}
			if (soap_flag_POPConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__POPConfig(soap, "ns4:POPConfig", &a->POPConfig, "ns4:POPConfig"))
				{	soap_flag_POPConfig--;
					continue;
				}
			if (soap_flag_AuthenticationConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__AuthenticationConfig(soap, "ns4:AuthenticationConfig", &a->AuthenticationConfig, "ns4:AuthenticationConfig"))
				{	soap_flag_AuthenticationConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SMTPConfig > 0 || soap_flag_POPConfig > 0 || soap_flag_AuthenticationConfig > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__EMailServerConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailServerConfiguration, SOAP_TYPE_ns4__EMailServerConfiguration, sizeof(struct ns4__EMailServerConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__EMailServerConfiguration * SOAP_FMAC4 soap_new_ns4__EMailServerConfiguration(struct soap *soap, int n)
{
	struct ns4__EMailServerConfiguration *p;
	struct ns4__EMailServerConfiguration *a = (struct ns4__EMailServerConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__EMailServerConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailServerConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailServerConfiguration(struct soap *soap, const struct ns4__EMailServerConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailServerConfiguration(soap, tag ? tag : "ns4:EMailServerConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__EMailServerConfiguration * SOAP_FMAC4 soap_get_ns4__EMailServerConfiguration(struct soap *soap, struct ns4__EMailServerConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailServerConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__onvif_USCOREaction(struct soap *soap, struct ns4__onvif_USCOREaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeActionDescription = 0;
	a->ActionDescription = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__onvif_USCOREaction(struct soap *soap, const struct ns4__onvif_USCOREaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ActionDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionDescription; i++)
		{
			soap_embedded(soap, a->ActionDescription + i, SOAP_TYPE_ns4__ActionConfigDescription);
			soap_serialize_ns4__ActionConfigDescription(soap, a->ActionDescription + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__onvif_USCOREaction(struct soap *soap, const char *tag, int id, const struct ns4__onvif_USCOREaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__onvif_USCOREaction), type))
		return soap->error;
	if (a->ActionDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeActionDescription; i++)
			if (soap_out_ns4__ActionConfigDescription(soap, "ns4:ActionDescription", -1, a->ActionDescription + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__onvif_USCOREaction * SOAP_FMAC4 soap_in_ns4__onvif_USCOREaction(struct soap *soap, const char *tag, struct ns4__onvif_USCOREaction *a, const char *type)
{
	struct soap_blist *soap_blist_ActionDescription = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__onvif_USCOREaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__onvif_USCOREaction, sizeof(struct ns4__onvif_USCOREaction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__onvif_USCOREaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns4:ActionDescription", 1, NULL))
			{	if (a->ActionDescription == NULL)
				{	if (soap_blist_ActionDescription == NULL)
						soap_blist_ActionDescription = soap_alloc_block(soap);
					a->ActionDescription = (struct ns4__ActionConfigDescription *)soap_push_block_max(soap, soap_blist_ActionDescription, sizeof(struct ns4__ActionConfigDescription));
					if (a->ActionDescription == NULL)
						return NULL;
					soap_default_ns4__ActionConfigDescription(soap, a->ActionDescription);
				}
				soap_revert(soap);
				if (soap_in_ns4__ActionConfigDescription(soap, "ns4:ActionDescription", a->ActionDescription, "ns4:ActionConfigDescription"))
				{	a->__sizeActionDescription++;
					a->ActionDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ActionDescription)
			soap_pop_block(soap, soap_blist_ActionDescription);
		if (a->__sizeActionDescription)
		{	a->ActionDescription = (struct ns4__ActionConfigDescription *)soap_save_block(soap, soap_blist_ActionDescription, NULL, 1);
		}
		else
		{	a->ActionDescription = NULL;
			if (soap_blist_ActionDescription)
				soap_end_block(soap, soap_blist_ActionDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeActionDescription < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__onvif_USCOREaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__onvif_USCOREaction, SOAP_TYPE_ns4__onvif_USCOREaction, sizeof(struct ns4__onvif_USCOREaction), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__onvif_USCOREaction * SOAP_FMAC4 soap_new_ns4__onvif_USCOREaction(struct soap *soap, int n)
{
	struct ns4__onvif_USCOREaction *p;
	struct ns4__onvif_USCOREaction *a = (struct ns4__onvif_USCOREaction*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__onvif_USCOREaction));
	for (p = a; p && n--; p++)
		soap_default_ns4__onvif_USCOREaction(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__onvif_USCOREaction(struct soap *soap, const struct ns4__onvif_USCOREaction *a, const char *tag, const char *type)
{
	if (soap_out_ns4__onvif_USCOREaction(soap, tag ? tag : "ns4:onvif_action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__onvif_USCOREaction * SOAP_FMAC4 soap_get_ns4__onvif_USCOREaction(struct soap *soap, struct ns4__onvif_USCOREaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__onvif_USCOREaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionTrigger(struct soap *soap, struct ns4__ActionTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionTrigger(struct soap *soap, const struct ns4__ActionTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons4__ActionTriggerConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionTrigger(struct soap *soap, const char *tag, int id, const struct ns4__ActionTrigger *a, const char *type)
{
	if (a->Token)
		soap_set_attr(soap, "Token", soap_tt__ReferenceToken2s(soap, a->Token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionTrigger), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns4:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons4__ActionTriggerConfiguration(soap, "ns4:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionTrigger * SOAP_FMAC4 soap_in_ns4__ActionTrigger(struct soap *soap, const char *tag, struct ns4__ActionTrigger *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionTrigger, sizeof(struct ns4__ActionTrigger), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionTrigger(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "Token", 1), &a->Token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ActionTriggerConfiguration(soap, "ns4:Configuration", &a->Configuration, "ns4:ActionTriggerConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns4__ActionTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionTrigger, SOAP_TYPE_ns4__ActionTrigger, sizeof(struct ns4__ActionTrigger), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionTrigger * SOAP_FMAC4 soap_new_ns4__ActionTrigger(struct soap *soap, int n)
{
	struct ns4__ActionTrigger *p;
	struct ns4__ActionTrigger *a = (struct ns4__ActionTrigger*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionTrigger));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionTrigger(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionTrigger(struct soap *soap, const struct ns4__ActionTrigger *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionTrigger(soap, tag ? tag : "ns4:ActionTrigger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionTrigger * SOAP_FMAC4 soap_get_ns4__ActionTrigger(struct soap *soap, struct ns4__ActionTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns4__ActionTriggerConfigurationExtension(struct soap *soap, struct ns4__ActionTriggerConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns4__ActionTriggerConfigurationExtension(struct soap *soap, const struct ns4__ActionTriggerConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ActionTriggerConfigurationExtension(struct soap *soap, const char *tag, int id, const struct ns4__ActionTriggerConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ActionTriggerConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns4__ActionTriggerConfigurationExtension * SOAP_FMAC4 soap_in_ns4__ActionTriggerConfigurationExtension(struct soap *soap, const char *tag, struct ns4__ActionTriggerConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns4__ActionTriggerConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ActionTriggerConfigurationExtension, sizeof(struct ns4__ActionTriggerConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns4__ActionTriggerConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns4__ActionTriggerConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ActionTriggerConfigurationExtension, SOAP_TYPE_ns4__ActionTriggerConfigurationExtension, sizeof(struct ns4__ActionTriggerConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns4__ActionTriggerConfigurationExtension * SOAP_FMAC4 soap_new_ns4__ActionTriggerConfigurationExtension(struct soap *soap, int n)
{
	struct ns4__ActionTriggerConfigurationExtension *p;
	struct ns4__ActionTriggerConfigurationExtension *a = (struct ns4__ActionTriggerConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns4__ActionTriggerConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_ns4__ActionTriggerConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__ActionTriggerConfigurationExtension(struct soap *soap, const struct ns4__ActionTriggerConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns4__ActionTriggerConfigurationExtension(soap, tag ? tag : "ns4:ActionTriggerConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns4__ActionTriggerConfigurationExtension * SOAP_FMAC4 soap_get_ns4__ActionTriggerConfigurationExtension(struct soap *soap, struct ns4__ActionTriggerConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ActionTriggerConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
