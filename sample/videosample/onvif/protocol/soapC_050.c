/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetTrackConfigurationResponse))
		soap_serialize__trc__GetTrackConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__GetTrackConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetTrackConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetTrackConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetTrackConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetTrackConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__GetTrackConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetTrackConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetTrackConfigurationResponse(soap, tag ? tag : "trc:GetTrackConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetTrackConfiguration))
		soap_serialize__trc__GetTrackConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetTrackConfiguration(struct soap *soap, const char *tag, int id, struct _trc__GetTrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetTrackConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetTrackConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__GetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__GetTrackConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetTrackConfiguration **)soap_malloc(soap, sizeof(struct _trc__GetTrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetTrackConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetTrackConfiguration(soap, tag ? tag : "trc:GetTrackConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteTrackResponse))
		soap_serialize__trc__DeleteTrackResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteTrackResponse(struct soap *soap, const char *tag, int id, struct _trc__DeleteTrackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteTrackResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteTrackResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteTrackResponse(struct soap *soap, const char *tag, struct _trc__DeleteTrackResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteTrackResponse **)soap_malloc(soap, sizeof(struct _trc__DeleteTrackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteTrackResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__DeleteTrackResponse(soap, tag ? tag : "trc:DeleteTrackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteTrack))
		soap_serialize__trc__DeleteTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteTrack(struct soap *soap, const char *tag, int id, struct _trc__DeleteTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteTrack, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteTrack ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteTrack(struct soap *soap, const char *tag, struct _trc__DeleteTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteTrack **)soap_malloc(soap, sizeof(struct _trc__DeleteTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__DeleteTrack(soap, tag ? tag : "trc:DeleteTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrack ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateTrackResponse))
		soap_serialize__trc__CreateTrackResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateTrackResponse(struct soap *soap, const char *tag, int id, struct _trc__CreateTrackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateTrackResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateTrackResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateTrackResponse(struct soap *soap, const char *tag, struct _trc__CreateTrackResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateTrackResponse **)soap_malloc(soap, sizeof(struct _trc__CreateTrackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateTrackResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateTrackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__CreateTrackResponse(soap, tag ? tag : "trc:CreateTrackResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateTrack))
		soap_serialize__trc__CreateTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateTrack(struct soap *soap, const char *tag, int id, struct _trc__CreateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateTrack, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateTrack ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateTrack(struct soap *soap, const char *tag, struct _trc__CreateTrack **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateTrack **)soap_malloc(soap, sizeof(struct _trc__CreateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__CreateTrack(soap, tag ? tag : "trc:CreateTrack", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrack ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingOptionsResponse))
		soap_serialize__trc__GetRecordingOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingOptionsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingOptionsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingOptionsResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetRecordingOptionsResponse(soap, tag ? tag : "trc:GetRecordingOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingOptions))
		soap_serialize__trc__GetRecordingOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingOptions(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingOptions(struct soap *soap, const char *tag, struct _trc__GetRecordingOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingOptions **)soap_malloc(soap, sizeof(struct _trc__GetRecordingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetRecordingOptions(soap, tag ? tag : "trc:GetRecordingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingConfigurationResponse))
		soap_serialize__trc__GetRecordingConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetRecordingConfigurationResponse(soap, tag ? tag : "trc:GetRecordingConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingConfiguration))
		soap_serialize__trc__GetRecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingConfiguration **)soap_malloc(soap, sizeof(struct _trc__GetRecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetRecordingConfiguration(soap, tag ? tag : "trc:GetRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingConfigurationResponse))
		soap_serialize__trc__SetRecordingConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__SetRecordingConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__SetRecordingConfigurationResponse(soap, tag ? tag : "trc:SetRecordingConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingConfiguration))
		soap_serialize__trc__SetRecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingConfiguration **)soap_malloc(soap, sizeof(struct _trc__SetRecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__SetRecordingConfiguration(soap, tag ? tag : "trc:SetRecordingConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingsResponse))
		soap_serialize__trc__GetRecordingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingsResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingsResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetRecordingsResponse(soap, tag ? tag : "trc:GetRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordings))
		soap_serialize__trc__GetRecordings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordings(struct soap *soap, const char *tag, int id, struct _trc__GetRecordings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordings ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordings(struct soap *soap, const char *tag, struct _trc__GetRecordings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordings **)soap_malloc(soap, sizeof(struct _trc__GetRecordings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetRecordings(soap, tag ? tag : "trc:GetRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordings ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteRecordingResponse))
		soap_serialize__trc__DeleteRecordingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, const char *tag, int id, struct _trc__DeleteRecordingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteRecordingResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteRecordingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteRecordingResponse **)soap_malloc(soap, sizeof(struct _trc__DeleteRecordingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteRecordingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__DeleteRecordingResponse(soap, tag ? tag : "trc:DeleteRecordingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteRecording))
		soap_serialize__trc__DeleteRecording(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteRecording(struct soap *soap, const char *tag, int id, struct _trc__DeleteRecording *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteRecording, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteRecording(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteRecording ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteRecording(struct soap *soap, const char *tag, struct _trc__DeleteRecording **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteRecording **)soap_malloc(soap, sizeof(struct _trc__DeleteRecording *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteRecording(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__DeleteRecording(soap, tag ? tag : "trc:DeleteRecording", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecording ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateRecordingResponse))
		soap_serialize__trc__CreateRecordingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateRecordingResponse(struct soap *soap, const char *tag, int id, struct _trc__CreateRecordingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateRecordingResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateRecordingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateRecordingResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateRecordingResponse **)soap_malloc(soap, sizeof(struct _trc__CreateRecordingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateRecordingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__CreateRecordingResponse(soap, tag ? tag : "trc:CreateRecordingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateRecording))
		soap_serialize__trc__CreateRecording(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateRecording(struct soap *soap, const char *tag, int id, struct _trc__CreateRecording *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateRecording, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateRecording(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateRecording ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateRecording(struct soap *soap, const char *tag, struct _trc__CreateRecording **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateRecording **)soap_malloc(soap, sizeof(struct _trc__CreateRecording *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateRecording(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__CreateRecording(soap, tag ? tag : "trc:CreateRecording", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecording ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse))
		soap_serialize__trc__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trc__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trc__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetServiceCapabilitiesResponse(soap, tag ? tag : "trc:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetServiceCapabilities))
		soap_serialize__trc__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trc__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trc__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trc__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trc__GetServiceCapabilities(soap, tag ? tag : "trc:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse))
		soap_serialize__tptz__GetCompatibleConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetCompatibleConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetCompatibleConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetCompatibleConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetCompatibleConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetCompatibleConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetCompatibleConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetCompatibleConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetCompatibleConfigurationsResponse(soap, tag ? tag : "tptz:GetCompatibleConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetCompatibleConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetCompatibleConfigurations))
		soap_serialize__tptz__GetCompatibleConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, int id, struct _tptz__GetCompatibleConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetCompatibleConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetCompatibleConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, struct _tptz__GetCompatibleConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetCompatibleConfigurations **)soap_malloc(soap, sizeof(struct _tptz__GetCompatibleConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetCompatibleConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetCompatibleConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetCompatibleConfigurations(soap, tag ? tag : "tptz:GetCompatibleConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetCompatibleConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTourResponse))
		soap_serialize__tptz__RemovePresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__RemovePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTourResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetTourResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__RemovePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RemovePresetTourResponse(soap, tag ? tag : "tptz:RemovePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTour))
		soap_serialize__tptz__RemovePresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, struct _tptz__RemovePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, struct _tptz__RemovePresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePresetTour **)soap_malloc(soap, sizeof(struct _tptz__RemovePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RemovePresetTour(soap, tag ? tag : "tptz:RemovePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTourResponse))
		soap_serialize__tptz__OperatePresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__OperatePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTourResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__OperatePresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__OperatePresetTourResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__OperatePresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__OperatePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__OperatePresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__OperatePresetTourResponse(soap, tag ? tag : "tptz:OperatePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTour))
		soap_serialize__tptz__OperatePresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, struct _tptz__OperatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__OperatePresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, struct _tptz__OperatePresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__OperatePresetTour **)soap_malloc(soap, sizeof(struct _tptz__OperatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__OperatePresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__OperatePresetTour(soap, tag ? tag : "tptz:OperatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTourResponse))
		soap_serialize__tptz__ModifyPresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__ModifyPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTourResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ModifyPresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTourResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ModifyPresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__ModifyPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ModifyPresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__ModifyPresetTourResponse(soap, tag ? tag : "tptz:ModifyPresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTour))
		soap_serialize__tptz__ModifyPresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, struct _tptz__ModifyPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ModifyPresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ModifyPresetTour **)soap_malloc(soap, sizeof(struct _tptz__ModifyPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ModifyPresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__ModifyPresetTour(soap, tag ? tag : "tptz:ModifyPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTourResponse))
		soap_serialize__tptz__CreatePresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__CreatePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTourResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__CreatePresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__CreatePresetTourResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__CreatePresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__CreatePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__CreatePresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__CreatePresetTourResponse(soap, tag ? tag : "tptz:CreatePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTour))
		soap_serialize__tptz__CreatePresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, struct _tptz__CreatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__CreatePresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, struct _tptz__CreatePresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__CreatePresetTour **)soap_malloc(soap, sizeof(struct _tptz__CreatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__CreatePresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__CreatePresetTour(soap, tag ? tag : "tptz:CreatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse))
		soap_serialize__tptz__GetPresetTourOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTourOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTourOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptionsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTourOptionsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTourOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTourOptionsResponse(soap, tag ? tag : "tptz:GetPresetTourOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptions))
		soap_serialize__tptz__GetPresetTourOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTourOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTourOptions **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTourOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTourOptions(soap, tag ? tag : "tptz:GetPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourResponse))
		soap_serialize__tptz__GetPresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTourResponse(soap, tag ? tag : "tptz:GetPresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTour))
		soap_serialize__tptz__GetPresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, struct _tptz__GetPresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTour **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTour(soap, tag ? tag : "tptz:GetPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetToursResponse))
		soap_serialize__tptz__GetPresetToursResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetToursResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetToursResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetToursResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetToursResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetToursResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetToursResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetToursResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetToursResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetToursResponse(soap, tag ? tag : "tptz:GetPresetToursResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTours))
		soap_serialize__tptz__GetPresetTours(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTours *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTours, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTours(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTours ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, struct _tptz__GetPresetTours **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTours **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTours *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTours(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTours **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTours(soap, tag ? tag : "tptz:GetPresetTours", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTours ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__StopResponse))
		soap_serialize__tptz__StopResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, int id, struct _tptz__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__StopResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__StopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, struct _tptz__StopResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__StopResponse **)soap_malloc(soap, sizeof(struct _tptz__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__StopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__StopResponse(soap, tag ? tag : "tptz:StopResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__Stop))
		soap_serialize__tptz__Stop(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__Stop(struct soap *soap, const char *tag, int id, struct _tptz__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__Stop, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__Stop(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__Stop ** SOAP_FMAC4 soap_in_PointerTo_tptz__Stop(struct soap *soap, const char *tag, struct _tptz__Stop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__Stop **)soap_malloc(soap, sizeof(struct _tptz__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__Stop(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__Stop(soap, tag ? tag : "tptz:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__Stop ** SOAP_FMAC4 soap_get_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMoveResponse))
		soap_serialize__tptz__AbsoluteMoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__AbsoluteMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMoveResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__AbsoluteMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, struct _tptz__AbsoluteMoveResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__AbsoluteMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__AbsoluteMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__AbsoluteMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__AbsoluteMoveResponse(soap, tag ? tag : "tptz:AbsoluteMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMove))
		soap_serialize__tptz__AbsoluteMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, struct _tptz__AbsoluteMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMove, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__AbsoluteMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, struct _tptz__AbsoluteMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__AbsoluteMove **)soap_malloc(soap, sizeof(struct _tptz__AbsoluteMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__AbsoluteMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, tag ? tag : "tptz:AbsoluteMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse))
		soap_serialize__tptz__SendAuxiliaryCommandResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, struct _tptz__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommandResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(struct _tptz__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag ? tag : "tptz:SendAuxiliaryCommandResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommand))
		soap_serialize__tptz__SendAuxiliaryCommand(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, struct _tptz__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommand, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SendAuxiliaryCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommand **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(struct _tptz__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SendAuxiliaryCommand(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, tag ? tag : "tptz:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMoveResponse))
		soap_serialize__tptz__RelativeMoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__RelativeMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMoveResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RelativeMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, struct _tptz__RelativeMoveResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RelativeMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__RelativeMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RelativeMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RelativeMoveResponse(soap, tag ? tag : "tptz:RelativeMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMove))
		soap_serialize__tptz__RelativeMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, int id, struct _tptz__RelativeMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMove, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RelativeMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RelativeMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, struct _tptz__RelativeMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RelativeMove **)soap_malloc(soap, sizeof(struct _tptz__RelativeMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RelativeMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RelativeMove(soap, tag ? tag : "tptz:RelativeMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMoveResponse))
		soap_serialize__tptz__ContinuousMoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__ContinuousMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMoveResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ContinuousMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, struct _tptz__ContinuousMoveResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ContinuousMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__ContinuousMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ContinuousMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__ContinuousMoveResponse(soap, tag ? tag : "tptz:ContinuousMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMove))
		soap_serialize__tptz__ContinuousMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, int id, struct _tptz__ContinuousMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMove, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ContinuousMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ContinuousMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, struct _tptz__ContinuousMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ContinuousMove **)soap_malloc(soap, sizeof(struct _tptz__ContinuousMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ContinuousMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, tag ? tag : "tptz:ContinuousMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePositionResponse))
		soap_serialize__tptz__SetHomePositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePositionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetHomePositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__SetHomePositionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetHomePositionResponse **)soap_malloc(soap, sizeof(struct _tptz__SetHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetHomePositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SetHomePositionResponse(soap, tag ? tag : "tptz:SetHomePositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePosition))
		soap_serialize__tptz__SetHomePosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, int id, struct _tptz__SetHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePosition, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetHomePosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, struct _tptz__SetHomePosition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetHomePosition **)soap_malloc(soap, sizeof(struct _tptz__SetHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetHomePosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, tag ? tag : "tptz:SetHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePositionResponse))
		soap_serialize__tptz__GotoHomePositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, struct _tptz__GotoHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePositionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoHomePositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__GotoHomePositionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoHomePositionResponse **)soap_malloc(soap, sizeof(struct _tptz__GotoHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoHomePositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GotoHomePositionResponse(soap, tag ? tag : "tptz:GotoHomePositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePosition))
		soap_serialize__tptz__GotoHomePosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, struct _tptz__GotoHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePosition, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoHomePosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, struct _tptz__GotoHomePosition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoHomePosition **)soap_malloc(soap, sizeof(struct _tptz__GotoHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoHomePosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, tag ? tag : "tptz:GotoHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
