/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAccessPointInfoResponse(struct soap *soap, struct _ns1__GetAccessPointInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAccessPointInfo = 0;
	a->AccessPointInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAccessPointInfoResponse(struct soap *soap, const struct _ns1__GetAccessPointInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AccessPointInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessPointInfo; i++)
		{
			soap_embedded(soap, a->AccessPointInfo + i, SOAP_TYPE_ns1__AccessPointInfo);
			soap_serialize_ns1__AccessPointInfo(soap, a->AccessPointInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAccessPointInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetAccessPointInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAccessPointInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAccessPointInfo");
	if (a->AccessPointInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessPointInfo; i++)
			if (soap_out_ns1__AccessPointInfo(soap, "ns1:AccessPointInfo", -1, a->AccessPointInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoResponse * SOAP_FMAC4 soap_in__ns1__GetAccessPointInfoResponse(struct soap *soap, const char *tag, struct _ns1__GetAccessPointInfoResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AccessPointInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAccessPointInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAccessPointInfoResponse, sizeof(struct _ns1__GetAccessPointInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAccessPointInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AccessPointInfo", 1, NULL))
			{	if (a->AccessPointInfo == NULL)
				{	if (soap_blist_AccessPointInfo == NULL)
						soap_blist_AccessPointInfo = soap_alloc_block(soap);
					a->AccessPointInfo = (struct ns1__AccessPointInfo *)soap_push_block_max(soap, soap_blist_AccessPointInfo, sizeof(struct ns1__AccessPointInfo));
					if (a->AccessPointInfo == NULL)
						return NULL;
					soap_default_ns1__AccessPointInfo(soap, a->AccessPointInfo);
				}
				soap_revert(soap);
				if (soap_in_ns1__AccessPointInfo(soap, "ns1:AccessPointInfo", a->AccessPointInfo, "ns1:AccessPointInfo"))
				{	a->__sizeAccessPointInfo++;
					a->AccessPointInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAccessPointInfo");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessPointInfo)
			soap_pop_block(soap, soap_blist_AccessPointInfo);
		if (a->__sizeAccessPointInfo)
		{	a->AccessPointInfo = (struct ns1__AccessPointInfo *)soap_save_block(soap, soap_blist_AccessPointInfo, NULL, 1);
		}
		else
		{	a->AccessPointInfo = NULL;
			if (soap_blist_AccessPointInfo)
				soap_end_block(soap, soap_blist_AccessPointInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetAccessPointInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAccessPointInfoResponse, SOAP_TYPE__ns1__GetAccessPointInfoResponse, sizeof(struct _ns1__GetAccessPointInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoResponse * SOAP_FMAC4 soap_new__ns1__GetAccessPointInfoResponse(struct soap *soap, int n)
{
	struct _ns1__GetAccessPointInfoResponse *p;
	struct _ns1__GetAccessPointInfoResponse *a = (struct _ns1__GetAccessPointInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAccessPointInfoResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAccessPointInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAccessPointInfoResponse(struct soap *soap, const struct _ns1__GetAccessPointInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAccessPointInfoResponse(soap, tag ? tag : "ns1:GetAccessPointInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoResponse * SOAP_FMAC4 soap_get__ns1__GetAccessPointInfoResponse(struct soap *soap, struct _ns1__GetAccessPointInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAccessPointInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAccessPointInfo(struct soap *soap, struct _ns1__GetAccessPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAccessPointInfo(struct soap *soap, const struct _ns1__GetAccessPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAccessPointInfo(struct soap *soap, const char *tag, int id, const struct _ns1__GetAccessPointInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAccessPointInfo), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns1:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfo * SOAP_FMAC4 soap_in__ns1__GetAccessPointInfo(struct soap *soap, const char *tag, struct _ns1__GetAccessPointInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAccessPointInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAccessPointInfo, sizeof(struct _ns1__GetAccessPointInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAccessPointInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__GetAccessPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAccessPointInfo, SOAP_TYPE__ns1__GetAccessPointInfo, sizeof(struct _ns1__GetAccessPointInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfo * SOAP_FMAC4 soap_new__ns1__GetAccessPointInfo(struct soap *soap, int n)
{
	struct _ns1__GetAccessPointInfo *p;
	struct _ns1__GetAccessPointInfo *a = (struct _ns1__GetAccessPointInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAccessPointInfo));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAccessPointInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAccessPointInfo(struct soap *soap, const struct _ns1__GetAccessPointInfo *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAccessPointInfo(soap, tag ? tag : "ns1:GetAccessPointInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfo * SOAP_FMAC4 soap_get__ns1__GetAccessPointInfo(struct soap *soap, struct _ns1__GetAccessPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAccessPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccessPointInfo(struct soap *soap, struct ns1__AccessPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
	soap_default_ns2__ReferenceToken(soap, &a->AreaFrom);
	soap_default_ns2__ReferenceToken(soap, &a->AreaTo);
	soap_default__QName(soap, &a->EntityType);
	soap_default_ns2__ReferenceToken(soap, &a->Entity);
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccessPointInfo(struct soap *soap, const struct ns1__AccessPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->AreaFrom);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->AreaTo);
	soap_serialize__QName(soap, (char*const*)&a->EntityType);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Entity);
	soap_serialize_PointerTons1__AccessPointCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessPointInfo(struct soap *soap, const char *tag, int id, const struct ns1__AccessPointInfo *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	 const char *soap_tmp_EntityType = soap_QName2s(soap, a->EntityType);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessPointInfo), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns1:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns1:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns1:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:AreaFrom", -1, (char*const*)&a->AreaFrom, ""))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:AreaTo", -1, (char*const*)&a->AreaTo, ""))
		return soap->error;
	if (soap_out__QName(soap, "ns1:EntityType", -1, (char*const*)(void*)&soap_tmp_EntityType, ""))
		return soap->error;
	if (!a->Entity)
	{	if (soap_element_nil(soap, "ns1:Entity"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns1:Entity", -1, (char*const*)&a->Entity, ""))
		return soap->error;
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns1:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__AccessPointCapabilities(soap, "ns1:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccessPointInfo * SOAP_FMAC4 soap_in_ns1__AccessPointInfo(struct soap *soap, const char *tag, struct ns1__AccessPointInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_AreaFrom = 1;
	size_t soap_flag_AreaTo = 1;
	size_t soap_flag_EntityType = 1;
	size_t soap_flag_Entity = 1;
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AccessPointInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessPointInfo, sizeof(struct ns1__AccessPointInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccessPointInfo(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns1:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns1:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_AreaFrom && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:AreaFrom", (char**)&a->AreaFrom, "ns2:ReferenceToken"))
				{	soap_flag_AreaFrom--;
					continue;
				}
			if (soap_flag_AreaTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:AreaTo", (char**)&a->AreaTo, "ns2:ReferenceToken"))
				{	soap_flag_AreaTo--;
					continue;
				}
			if (soap_flag_EntityType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "ns1:EntityType", (char**)&a->EntityType, "xsd:QName"))
				{	soap_flag_EntityType--;
					continue;
				}
			if (soap_flag_Entity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Entity", (char**)&a->Entity, "ns2:ReferenceToken"))
				{	soap_flag_Entity--;
					continue;
				}
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessPointCapabilities(soap, "ns1:Capabilities", &a->Capabilities, "ns1:AccessPointCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Entity > 0 || soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AccessPointInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessPointInfo, SOAP_TYPE_ns1__AccessPointInfo, sizeof(struct ns1__AccessPointInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AccessPointInfo * SOAP_FMAC4 soap_new_ns1__AccessPointInfo(struct soap *soap, int n)
{
	struct ns1__AccessPointInfo *p;
	struct ns1__AccessPointInfo *a = (struct ns1__AccessPointInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AccessPointInfo));
	for (p = a; p && n--; p++)
		soap_default_ns1__AccessPointInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccessPointInfo(struct soap *soap, const struct ns1__AccessPointInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AccessPointInfo(soap, tag ? tag : "ns1:AccessPointInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessPointInfo * SOAP_FMAC4 soap_get_ns1__AccessPointInfo(struct soap *soap, struct ns1__AccessPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAccessPointInfoListResponse(struct soap *soap, struct _ns1__GetAccessPointInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeAccessPointInfo = 0;
	a->AccessPointInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAccessPointInfoListResponse(struct soap *soap, const struct _ns1__GetAccessPointInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->AccessPointInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessPointInfo; i++)
		{
			soap_embedded(soap, a->AccessPointInfo + i, SOAP_TYPE_ns1__AccessPointInfo);
			soap_serialize_ns1__AccessPointInfo(soap, a->AccessPointInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAccessPointInfoListResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetAccessPointInfoListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAccessPointInfoListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns1:NextStartReference");
	if (soap_out_string(soap, "ns1:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->AccessPointInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeAccessPointInfo; i++)
			if (soap_out_ns1__AccessPointInfo(soap, "ns1:AccessPointInfo", -1, a->AccessPointInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoListResponse * SOAP_FMAC4 soap_in__ns1__GetAccessPointInfoListResponse(struct soap *soap, const char *tag, struct _ns1__GetAccessPointInfoListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_AccessPointInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAccessPointInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAccessPointInfoListResponse, sizeof(struct _ns1__GetAccessPointInfoListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAccessPointInfoListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:AccessPointInfo", 1, NULL))
			{	if (a->AccessPointInfo == NULL)
				{	if (soap_blist_AccessPointInfo == NULL)
						soap_blist_AccessPointInfo = soap_alloc_block(soap);
					a->AccessPointInfo = (struct ns1__AccessPointInfo *)soap_push_block_max(soap, soap_blist_AccessPointInfo, sizeof(struct ns1__AccessPointInfo));
					if (a->AccessPointInfo == NULL)
						return NULL;
					soap_default_ns1__AccessPointInfo(soap, a->AccessPointInfo);
				}
				soap_revert(soap);
				if (soap_in_ns1__AccessPointInfo(soap, "ns1:AccessPointInfo", a->AccessPointInfo, "ns1:AccessPointInfo"))
				{	a->__sizeAccessPointInfo++;
					a->AccessPointInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AccessPointInfo)
			soap_pop_block(soap, soap_blist_AccessPointInfo);
		if (a->__sizeAccessPointInfo)
		{	a->AccessPointInfo = (struct ns1__AccessPointInfo *)soap_save_block(soap, soap_blist_AccessPointInfo, NULL, 1);
		}
		else
		{	a->AccessPointInfo = NULL;
			if (soap_blist_AccessPointInfo)
				soap_end_block(soap, soap_blist_AccessPointInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetAccessPointInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAccessPointInfoListResponse, SOAP_TYPE__ns1__GetAccessPointInfoListResponse, sizeof(struct _ns1__GetAccessPointInfoListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoListResponse * SOAP_FMAC4 soap_new__ns1__GetAccessPointInfoListResponse(struct soap *soap, int n)
{
	struct _ns1__GetAccessPointInfoListResponse *p;
	struct _ns1__GetAccessPointInfoListResponse *a = (struct _ns1__GetAccessPointInfoListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAccessPointInfoListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAccessPointInfoListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAccessPointInfoListResponse(struct soap *soap, const struct _ns1__GetAccessPointInfoListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAccessPointInfoListResponse(soap, tag ? tag : "ns1:GetAccessPointInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoListResponse * SOAP_FMAC4 soap_get__ns1__GetAccessPointInfoListResponse(struct soap *soap, struct _ns1__GetAccessPointInfoListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAccessPointInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetAccessPointInfoList(struct soap *soap, struct _ns1__GetAccessPointInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetAccessPointInfoList(struct soap *soap, const struct _ns1__GetAccessPointInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAccessPointInfoList(struct soap *soap, const char *tag, int id, const struct _ns1__GetAccessPointInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAccessPointInfoList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoList * SOAP_FMAC4 soap_in__ns1__GetAccessPointInfoList(struct soap *soap, const char *tag, struct _ns1__GetAccessPointInfoList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetAccessPointInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAccessPointInfoList, sizeof(struct _ns1__GetAccessPointInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetAccessPointInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetAccessPointInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAccessPointInfoList, SOAP_TYPE__ns1__GetAccessPointInfoList, sizeof(struct _ns1__GetAccessPointInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoList * SOAP_FMAC4 soap_new__ns1__GetAccessPointInfoList(struct soap *soap, int n)
{
	struct _ns1__GetAccessPointInfoList *p;
	struct _ns1__GetAccessPointInfoList *a = (struct _ns1__GetAccessPointInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetAccessPointInfoList));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetAccessPointInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetAccessPointInfoList(struct soap *soap, const struct _ns1__GetAccessPointInfoList *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetAccessPointInfoList(soap, tag ? tag : "ns1:GetAccessPointInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetAccessPointInfoList * SOAP_FMAC4 soap_get__ns1__GetAccessPointInfoList(struct soap *soap, struct _ns1__GetAccessPointInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAccessPointInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns1__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns1__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns1:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns1:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ServiceCapabilities(soap, "ns1:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__ns1__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns1__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, sizeof(struct _ns1__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ServiceCapabilities(soap, "ns1:Capabilities", &a->Capabilities, "ns1:ServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns1:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns1__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, sizeof(struct _ns1__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__ns1__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _ns1__GetServiceCapabilitiesResponse *p;
	struct _ns1__GetServiceCapabilitiesResponse *a = (struct _ns1__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns1__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns1:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__ns1__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns1__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetServiceCapabilities(struct soap *soap, struct _ns1__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetServiceCapabilities(struct soap *soap, const struct _ns1__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns1__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns1__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns1__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetServiceCapabilities, sizeof(struct _ns1__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetServiceCapabilities, SOAP_TYPE__ns1__GetServiceCapabilities, sizeof(struct _ns1__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns1__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns1__GetServiceCapabilities *p;
	struct _ns1__GetServiceCapabilities *a = (struct _ns1__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns1__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns1__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetServiceCapabilities(struct soap *soap, const struct _ns1__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns1__GetServiceCapabilities(soap, tag ? tag : "ns1:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns1__GetServiceCapabilities(struct soap *soap, struct _ns1__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccessPointState(struct soap *soap, struct ns1__AccessPointState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccessPointState(struct soap *soap, const struct ns1__AccessPointState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessPointState(struct soap *soap, const char *tag, int id, const struct ns1__AccessPointState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessPointState), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns1:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccessPointState * SOAP_FMAC4 soap_in_ns1__AccessPointState(struct soap *soap, const char *tag, struct ns1__AccessPointState *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AccessPointState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessPointState, sizeof(struct ns1__AccessPointState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccessPointState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns1:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AccessPointState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessPointState, SOAP_TYPE_ns1__AccessPointState, sizeof(struct ns1__AccessPointState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AccessPointState * SOAP_FMAC4 soap_new_ns1__AccessPointState(struct soap *soap, int n)
{
	struct ns1__AccessPointState *p;
	struct ns1__AccessPointState *a = (struct ns1__AccessPointState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AccessPointState));
	for (p = a; p && n--; p++)
		soap_default_ns1__AccessPointState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccessPointState(struct soap *soap, const struct ns1__AccessPointState *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AccessPointState(soap, tag ? tag : "ns1:AccessPointState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessPointState * SOAP_FMAC4 soap_get_ns1__AccessPointState(struct soap *soap, struct ns1__AccessPointState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessPointState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccessPointCapabilities(struct soap *soap, struct ns1__AccessPointCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->DisableAccessPoint);
	a->Duress = NULL;
	a->AnonymousAccess = NULL;
	a->AccessTaken = NULL;
	a->ExternalAuthorization = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccessPointCapabilities(struct soap *soap, const struct ns1__AccessPointCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessPointCapabilities(struct soap *soap, const char *tag, int id, const struct ns1__AccessPointCapabilities *a, const char *type)
{
	soap_set_attr(soap, "DisableAccessPoint", soap_xsd__boolean2s(soap, a->DisableAccessPoint), 1);
	if (a->Duress)
		soap_set_attr(soap, "Duress", soap_xsd__boolean2s(soap, *a->Duress), 1);
	if (a->AnonymousAccess)
		soap_set_attr(soap, "AnonymousAccess", soap_xsd__boolean2s(soap, *a->AnonymousAccess), 1);
	if (a->AccessTaken)
		soap_set_attr(soap, "AccessTaken", soap_xsd__boolean2s(soap, *a->AccessTaken), 1);
	if (a->ExternalAuthorization)
		soap_set_attr(soap, "ExternalAuthorization", soap_xsd__boolean2s(soap, *a->ExternalAuthorization), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessPointCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccessPointCapabilities * SOAP_FMAC4 soap_in_ns1__AccessPointCapabilities(struct soap *soap, const char *tag, struct ns1__AccessPointCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AccessPointCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessPointCapabilities, sizeof(struct ns1__AccessPointCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccessPointCapabilities(soap, a);
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "DisableAccessPoint", 1), &a->DisableAccessPoint))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Duress", 0);
		if (t)
		{
			if (!(a->Duress = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Duress))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "AnonymousAccess", 0);
		if (t)
		{
			if (!(a->AnonymousAccess = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AnonymousAccess))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "AccessTaken", 0);
		if (t)
		{
			if (!(a->AccessTaken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AccessTaken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ExternalAuthorization", 0);
		if (t)
		{
			if (!(a->ExternalAuthorization = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ExternalAuthorization))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AccessPointCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessPointCapabilities, SOAP_TYPE_ns1__AccessPointCapabilities, sizeof(struct ns1__AccessPointCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AccessPointCapabilities * SOAP_FMAC4 soap_new_ns1__AccessPointCapabilities(struct soap *soap, int n)
{
	struct ns1__AccessPointCapabilities *p;
	struct ns1__AccessPointCapabilities *a = (struct ns1__AccessPointCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AccessPointCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns1__AccessPointCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccessPointCapabilities(struct soap *soap, const struct ns1__AccessPointCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AccessPointCapabilities(soap, tag ? tag : "ns1:AccessPointCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessPointCapabilities * SOAP_FMAC4 soap_get_ns1__AccessPointCapabilities(struct soap *soap, struct ns1__AccessPointCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessPointCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ServiceCapabilities(struct soap *soap, struct ns1__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->MaxLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ServiceCapabilities(struct soap *soap, const struct ns1__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServiceCapabilities(struct soap *soap, const char *tag, int id, const struct ns1__ServiceCapabilities *a, const char *type)
{
	soap_set_attr(soap, "MaxLimit", soap_unsignedInt2s(soap, a->MaxLimit), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ServiceCapabilities * SOAP_FMAC4 soap_in_ns1__ServiceCapabilities(struct soap *soap, const char *tag, struct ns1__ServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServiceCapabilities, sizeof(struct ns1__ServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ServiceCapabilities(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MaxLimit", 1), &a->MaxLimit))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServiceCapabilities, SOAP_TYPE_ns1__ServiceCapabilities, sizeof(struct ns1__ServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__ServiceCapabilities * SOAP_FMAC4 soap_new_ns1__ServiceCapabilities(struct soap *soap, int n)
{
	struct ns1__ServiceCapabilities *p;
	struct ns1__ServiceCapabilities *a = (struct ns1__ServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__ServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns1__ServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ServiceCapabilities(struct soap *soap, const struct ns1__ServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ServiceCapabilities(soap, tag ? tag : "ns1:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ServiceCapabilities * SOAP_FMAC4 soap_get_ns1__ServiceCapabilities(struct soap *soap, struct ns1__ServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSK(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSK(struct soap *soap, const struct xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11PSK);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11PSK2s(struct soap *soap, struct xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11PSK, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11PSK(struct soap *soap, const char *s, struct xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 32)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11PSK(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSK(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSK(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSK(soap, tag ? tag : "tt:Dot11PSK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11PSK(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SSIDType(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SSIDType(struct soap *soap, const struct xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11SSIDType);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SSIDType2s(struct soap *soap, struct xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11SSIDType, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SSIDType(struct soap *soap, const char *s, struct xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 1)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11SSIDType(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SSIDType(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 1)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SSIDType(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SSIDType(soap, tag ? tag : "tt:Dot11SSIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11SSIDType(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__hexBinary(struct soap *soap, const struct xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, struct xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, struct xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__hexBinary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_new_xsd__hexBinary(struct soap *soap, int n)
{
	struct xsd__hexBinary *p;
	struct xsd__hexBinary *a = (struct xsd__hexBinary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xsd__hexBinary));
	for (p = a; p && n--; p++)
		soap_default_xsd__hexBinary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__hexBinary(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr && !soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_xsd__base64Binary))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, struct xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, struct xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_new_xsd__base64Binary(struct soap *soap, int n)
{
	struct xsd__base64Binary *p;
	struct xsd__base64Binary *a = (struct xsd__base64Binary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xsd__base64Binary));
	for (p = a; p && n--; p++)
		soap_default_xsd__base64Binary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	soap_outliteral(soap, "SOAP-ENV:Body", (char*const*)&a->SOAP_ENV__Body, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Envelope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "SOAP-ENV:Body", (char**)&a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_new_SOAP_ENV__Envelope(struct soap *soap, int n)
{
	struct SOAP_ENV__Envelope *p;
	struct SOAP_ENV__Envelope *a = (struct SOAP_ENV__Envelope*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Envelope));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Envelope(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	a->saml1__Assertion = NULL;
	a->saml2__Assertion = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", soap_string2s(soap, a->SOAP_ENV__actor), 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", soap_string2s(soap, a->SOAP_ENV__role), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml1__Assertion = 1;
	size_t soap_flag_saml2__Assertion = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_new__wsse__Security(struct soap *soap, int n)
{
	struct _wsse__Security *p;
	struct _wsse__Security *a = (struct _wsse__Security*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsse__Security));
	for (p = a; p && n--; p++)
		soap_default__wsse__Security(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Security(soap, tag ? tag : "wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Attribute = NULL;
	a->saml2__EncryptedAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__AttributeType(soap, &a->saml2__Attribute);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAttribute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__AttributeType(soap, "saml2:Attribute", -1, &a->saml2__Attribute, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", -1, &a->saml2__EncryptedAttribute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_in___saml2__union_AttributeStatementType(struct soap *soap, const char *tag, struct __saml2__union_AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml2__Attribute = 1;
	size_t soap_flag_saml2__EncryptedAttribute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AttributeStatementType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AttributeStatementType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Attribute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AttributeType(soap, "saml2:Attribute", &a->saml2__Attribute, "saml2:AttributeType"))
				{	soap_flag_saml2__Attribute--;
					continue;
				}
			if (soap_flag_saml2__EncryptedAttribute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAttribute", &a->saml2__EncryptedAttribute, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAttribute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_new___saml2__union_AttributeStatementType(struct soap *soap, int n)
{
	struct __saml2__union_AttributeStatementType *p;
	struct __saml2__union_AttributeStatementType *a = (struct __saml2__union_AttributeStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_AttributeStatementType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_AttributeStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AttributeStatementType(struct soap *soap, const struct __saml2__union_AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AttributeStatementType(soap, tag ? tag : "-saml2:union-AttributeStatementType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AttributeStatementType * SOAP_FMAC4 soap_get___saml2__union_AttributeStatementType(struct soap *soap, struct __saml2__union_AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_in___saml2__union_EvidenceType(struct soap *soap, const char *tag, struct __saml2__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_EvidenceType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_EvidenceType, sizeof(struct __saml2__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_new___saml2__union_EvidenceType(struct soap *soap, int n)
{
	struct __saml2__union_EvidenceType *p;
	struct __saml2__union_EvidenceType *a = (struct __saml2__union_EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_EvidenceType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_EvidenceType(struct soap *soap, const struct __saml2__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_EvidenceType(soap, tag ? tag : "-saml2:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_EvidenceType * SOAP_FMAC4 soap_get___saml2__union_EvidenceType(struct soap *soap, struct __saml2__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AssertionIDRef);
	soap_default_string(soap, &a->saml2__AssertionURIRef);
	a->saml2__Assertion = NULL;
	a->saml2__EncryptedAssertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionIDRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AssertionURIRef);
	soap_serialize_PointerTosaml2__AssertionType(soap, &a->saml2__Assertion);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedAssertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml2:AssertionIDRef", -1, (char*const*)&a->saml2__AssertionIDRef, ""))
		return soap->error;
	if (soap_out_string(soap, "saml2:AssertionURIRef", -1, (char*const*)&a->saml2__AssertionURIRef, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AssertionType(soap, "saml2:Assertion", -1, &a->saml2__Assertion, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", -1, &a->saml2__EncryptedAssertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_in___saml2__union_AdviceType(struct soap *soap, const char *tag, struct __saml2__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml2__AssertionIDRef = 1;
	size_t soap_flag_saml2__AssertionURIRef = 1;
	size_t soap_flag_saml2__Assertion = 1;
	size_t soap_flag_saml2__EncryptedAssertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AdviceType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AdviceType, sizeof(struct __saml2__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AssertionIDRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml2:AssertionIDRef", (char**)&a->saml2__AssertionIDRef, "xsd:string"))
				{	soap_flag_saml2__AssertionIDRef--;
					continue;
				}
			if (soap_flag_saml2__AssertionURIRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml2:AssertionURIRef", (char**)&a->saml2__AssertionURIRef, "xsd:string"))
				{	soap_flag_saml2__AssertionURIRef--;
					continue;
				}
			if (soap_flag_saml2__Assertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AssertionType(soap, "saml2:Assertion", &a->saml2__Assertion, "saml2:AssertionType"))
				{	soap_flag_saml2__Assertion--;
					continue;
				}
			if (soap_flag_saml2__EncryptedAssertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedAssertion", &a->saml2__EncryptedAssertion, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedAssertion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_new___saml2__union_AdviceType(struct soap *soap, int n)
{
	struct __saml2__union_AdviceType *p;
	struct __saml2__union_AdviceType *a = (struct __saml2__union_AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_AdviceType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AdviceType(struct soap *soap, const struct __saml2__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AdviceType(soap, tag ? tag : "-saml2:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AdviceType * SOAP_FMAC4 soap_get___saml2__union_AdviceType(struct soap *soap, struct __saml2__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Condition = NULL;
	a->saml2__AudienceRestriction = NULL;
	a->saml2__OneTimeUse = NULL;
	a->saml2__ProxyRestriction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__ConditionAbstractType(soap, &a->saml2__Condition);
	soap_serialize_PointerTosaml2__AudienceRestrictionType(soap, &a->saml2__AudienceRestriction);
	soap_serialize_PointerTosaml2__OneTimeUseType(soap, &a->saml2__OneTimeUse);
	soap_serialize_PointerTosaml2__ProxyRestrictionType(soap, &a->saml2__ProxyRestriction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml2__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", -1, &a->saml2__Condition, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", -1, &a->saml2__AudienceRestriction, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", -1, &a->saml2__OneTimeUse, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", -1, &a->saml2__ProxyRestriction, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_in___saml2__union_ConditionsType(struct soap *soap, const char *tag, struct __saml2__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml2__Condition = 1;
	size_t soap_flag_saml2__AudienceRestriction = 1;
	size_t soap_flag_saml2__OneTimeUse = 1;
	size_t soap_flag_saml2__ProxyRestriction = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_ConditionsType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_ConditionsType, sizeof(struct __saml2__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Condition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__ConditionAbstractType(soap, "saml2:Condition", &a->saml2__Condition, "saml2:ConditionAbstractType"))
				{	soap_flag_saml2__Condition--;
					continue;
				}
			if (soap_flag_saml2__AudienceRestriction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AudienceRestrictionType(soap, "saml2:AudienceRestriction", &a->saml2__AudienceRestriction, "saml2:AudienceRestrictionType"))
				{	soap_flag_saml2__AudienceRestriction--;
					continue;
				}
			if (soap_flag_saml2__OneTimeUse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__OneTimeUseType(soap, "saml2:OneTimeUse", &a->saml2__OneTimeUse, "saml2:OneTimeUseType"))
				{	soap_flag_saml2__OneTimeUse--;
					continue;
				}
			if (soap_flag_saml2__ProxyRestriction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__ProxyRestrictionType(soap, "saml2:ProxyRestriction", &a->saml2__ProxyRestriction, "saml2:ProxyRestrictionType"))
				{	soap_flag_saml2__ProxyRestriction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_new___saml2__union_ConditionsType(struct soap *soap, int n)
{
	struct __saml2__union_ConditionsType *p;
	struct __saml2__union_ConditionsType *a = (struct __saml2__union_ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_ConditionsType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_ConditionsType(struct soap *soap, const struct __saml2__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_ConditionsType(soap, tag ? tag : "-saml2:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_ConditionsType * SOAP_FMAC4 soap_get___saml2__union_ConditionsType(struct soap *soap, struct __saml2__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Statement = NULL;
	a->saml2__AuthnStatement = NULL;
	a->saml2__AuthzDecisionStatement = NULL;
	a->saml2__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__StatementAbstractType(soap, &a->saml2__Statement);
	soap_serialize_PointerTosaml2__AuthnStatementType(soap, &a->saml2__AuthnStatement);
	soap_serialize_PointerTosaml2__AuthzDecisionStatementType(soap, &a->saml2__AuthzDecisionStatement);
	soap_serialize_PointerTosaml2__AttributeStatementType(soap, &a->saml2__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml2__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml2__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", -1, &a->saml2__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", -1, &a->saml2__AuthnStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", -1, &a->saml2__AuthzDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", -1, &a->saml2__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_in___saml2__union_AssertionType(struct soap *soap, const char *tag, struct __saml2__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Statement = 1;
	size_t soap_flag_saml2__AuthnStatement = 1;
	size_t soap_flag_saml2__AuthzDecisionStatement = 1;
	size_t soap_flag_saml2__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml2__union_AssertionType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml2__union_AssertionType, sizeof(struct __saml2__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml2__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Statement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__StatementAbstractType(soap, "saml2:Statement", &a->saml2__Statement, "saml2:StatementAbstractType"))
				{	soap_flag_saml2__Statement--;
					continue;
				}
			if (soap_flag_saml2__AuthnStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AuthnStatementType(soap, "saml2:AuthnStatement", &a->saml2__AuthnStatement, "saml2:AuthnStatementType"))
				{	soap_flag_saml2__AuthnStatement--;
					continue;
				}
			if (soap_flag_saml2__AuthzDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AuthzDecisionStatementType(soap, "saml2:AuthzDecisionStatement", &a->saml2__AuthzDecisionStatement, "saml2:AuthzDecisionStatementType"))
				{	soap_flag_saml2__AuthzDecisionStatement--;
					continue;
				}
			if (soap_flag_saml2__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AttributeStatementType(soap, "saml2:AttributeStatement", &a->saml2__AttributeStatement, "saml2:AttributeStatementType"))
				{	soap_flag_saml2__AttributeStatement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_new___saml2__union_AssertionType(struct soap *soap, int n)
{
	struct __saml2__union_AssertionType *p;
	struct __saml2__union_AssertionType *a = (struct __saml2__union_AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml2__union_AssertionType));
	for (p = a; p && n--; p++)
		soap_default___saml2__union_AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml2__union_AssertionType(struct soap *soap, const struct __saml2__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml2__union_AssertionType(soap, tag ? tag : "-saml2:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml2__union_AssertionType * SOAP_FMAC4 soap_get___saml2__union_AssertionType(struct soap *soap, struct __saml2__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml2__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAttributeValue = 0;
	a->saml2__AttributeValue = NULL;
	soap_default_string(soap, &a->Name);
	soap_default_string(soap, &a->NameFormat);
	soap_default_string(soap, &a->FriendlyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeType *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->NameFormat)
		soap_set_attr(soap, "NameFormat", soap_string2s(soap, a->NameFormat), 1);
	if (a->FriendlyName)
		soap_set_attr(soap, "FriendlyName", soap_string2s(soap, a->FriendlyName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeType), type))
		return soap->error;
	if (a->saml2__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			soap_outliteral(soap, "saml2:AttributeValue", (char*const*)(a->saml2__AttributeValue + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_in_saml2__AttributeType(struct soap *soap, const char *tag, struct saml2__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameFormat", 0), &a->NameFormat))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "FriendlyName", 0), &a->FriendlyName))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AttributeValue", 1, NULL))
			{	if (a->saml2__AttributeValue == NULL)
				{	if (soap_blist_saml2__AttributeValue == NULL)
						soap_blist_saml2__AttributeValue = soap_alloc_block(soap);
					a->saml2__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml2__AttributeValue, sizeof(char *));
					if (a->saml2__AttributeValue == NULL)
						return NULL;
					*a->saml2__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml2:AttributeValue", (char**)a->saml2__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml2__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AttributeValue)
			soap_pop_block(soap, soap_blist_saml2__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml2__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml2__AttributeValue, NULL, 1);
		}
		else
		{	a->saml2__AttributeValue = NULL;
			if (soap_blist_saml2__AttributeValue)
				soap_end_block(soap, soap_blist_saml2__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeType, SOAP_TYPE_saml2__AttributeType, sizeof(struct saml2__AttributeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_new_saml2__AttributeType(struct soap *soap, int n)
{
	struct saml2__AttributeType *p;
	struct saml2__AttributeType *a = (struct saml2__AttributeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AttributeType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AttributeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeType(struct soap *soap, const struct saml2__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeType(soap, tag ? tag : "saml2:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeType * SOAP_FMAC4 soap_get_saml2__AttributeType(struct soap *soap, struct saml2__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AttributeStatementType = 0;
	a->__union_AttributeStatementType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
		{
			soap_serialize___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AttributeStatementType), type))
		return soap->error;
	if (a->__union_AttributeStatementType)
	{	int i;
		for (i = 0; i < (int)a->__size_AttributeStatementType; i++)
			if (soap_out___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", -1, a->__union_AttributeStatementType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_in_saml2__AttributeStatementType(struct soap *soap, const char *tag, struct saml2__AttributeStatementType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AttributeStatementType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AttributeStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AttributeStatementType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AttributeStatementType == NULL)
				{	if (soap_blist___union_AttributeStatementType == NULL)
						soap_blist___union_AttributeStatementType = soap_alloc_block(soap);
					a->__union_AttributeStatementType = (struct __saml2__union_AttributeStatementType *)soap_push_block_max(soap, soap_blist___union_AttributeStatementType, sizeof(struct __saml2__union_AttributeStatementType));
					if (a->__union_AttributeStatementType == NULL)
						return NULL;
					soap_default___saml2__union_AttributeStatementType(soap, a->__union_AttributeStatementType);
				}
				if (soap_in___saml2__union_AttributeStatementType(soap, "-union-AttributeStatementType", a->__union_AttributeStatementType, "-saml2:union-AttributeStatementType"))
				{	a->__size_AttributeStatementType++;
					a->__union_AttributeStatementType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AttributeStatementType)
			soap_pop_block(soap, soap_blist___union_AttributeStatementType);
		if (a->__size_AttributeStatementType)
		{	a->__union_AttributeStatementType = (struct __saml2__union_AttributeStatementType *)soap_save_block(soap, soap_blist___union_AttributeStatementType, NULL, 1);
		}
		else
		{	a->__union_AttributeStatementType = NULL;
			if (soap_blist___union_AttributeStatementType)
				soap_end_block(soap, soap_blist___union_AttributeStatementType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AttributeStatementType, SOAP_TYPE_saml2__AttributeStatementType, sizeof(struct saml2__AttributeStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_new_saml2__AttributeStatementType(struct soap *soap, int n)
{
	struct saml2__AttributeStatementType *p;
	struct saml2__AttributeStatementType *a = (struct saml2__AttributeStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AttributeStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AttributeStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AttributeStatementType(struct soap *soap, const struct saml2__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AttributeStatementType(soap, tag ? tag : "saml2:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AttributeStatementType * SOAP_FMAC4 soap_get_saml2__AttributeStatementType(struct soap *soap, struct saml2__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml2__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml2__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml2__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_in_saml2__EvidenceType(struct soap *soap, const char *tag, struct saml2__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__EvidenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EvidenceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = (struct __saml2__union_EvidenceType *)soap_push_block_max(soap, soap_blist___union_EvidenceType, sizeof(struct __saml2__union_EvidenceType));
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml2__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml2__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml2:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_pop_block(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = (struct __saml2__union_EvidenceType *)soap_save_block(soap, soap_blist___union_EvidenceType, NULL, 1);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_end_block(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EvidenceType, SOAP_TYPE_saml2__EvidenceType, sizeof(struct saml2__EvidenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_new_saml2__EvidenceType(struct soap *soap, int n)
{
	struct saml2__EvidenceType *p;
	struct saml2__EvidenceType *a = (struct saml2__EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__EvidenceType));
	for (p = a; p && n--; p++)
		soap_default_saml2__EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EvidenceType(struct soap *soap, const struct saml2__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EvidenceType(soap, tag ? tag : "saml2:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EvidenceType * SOAP_FMAC4 soap_get_saml2__EvidenceType(struct soap *soap, struct saml2__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ActionType(struct soap *soap, struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ActionType(struct soap *soap, const char *tag, int id, const struct saml2__ActionType *a, const char *type)
{
	if (a->Namespace)
		soap_set_attr(soap, "Namespace", soap_string2s(soap, a->Namespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_in_saml2__ActionType(struct soap *soap, const char *tag, struct saml2__ActionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct saml2__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ActionType, sizeof(struct saml2__ActionType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 1), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_new_saml2__ActionType(struct soap *soap, int n)
{
	struct saml2__ActionType *p;
	struct saml2__ActionType *a = (struct saml2__ActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ActionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ActionType(struct soap *soap, const struct saml2__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ActionType(soap, tag ? tag : "saml2:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ActionType * SOAP_FMAC4 soap_get_saml2__ActionType(struct soap *soap, struct saml2__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAction = 0;
	a->saml2__Action = NULL;
	a->saml2__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml2__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml2__Action + i, SOAP_TYPE_saml2__ActionType);
			soap_serialize_saml2__ActionType(soap, a->saml2__Action + i);
		}
	}
	soap_serialize_PointerTosaml2__EvidenceType(soap, &a->saml2__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	if (a->Resource)
		soap_set_attr(soap, "Resource", soap_string2s(soap, a->Resource), 1);
	soap_set_attr(soap, "Decision", soap_saml2__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType), type))
		return soap->error;
	if (a->saml2__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml2__ActionType(soap, "saml2:Action", -1, a->saml2__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", -1, &a->saml2__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_in_saml2__AuthzDecisionStatementType(struct soap *soap, const char *tag, struct saml2__AuthzDecisionStatementType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Action = NULL;
	size_t soap_flag_saml2__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AuthzDecisionStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthzDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1), &a->Resource))
		return NULL;
	if (soap_s2saml2__DecisionType(soap, soap_attr_value(soap, "Decision", 1), &a->Decision))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Action", 1, NULL))
			{	if (a->saml2__Action == NULL)
				{	if (soap_blist_saml2__Action == NULL)
						soap_blist_saml2__Action = soap_alloc_block(soap);
					a->saml2__Action = (struct saml2__ActionType *)soap_push_block_max(soap, soap_blist_saml2__Action, sizeof(struct saml2__ActionType));
					if (a->saml2__Action == NULL)
						return NULL;
					soap_default_saml2__ActionType(soap, a->saml2__Action);
				}
				soap_revert(soap);
				if (soap_in_saml2__ActionType(soap, "saml2:Action", a->saml2__Action, "saml2:ActionType"))
				{	a->__sizeAction++;
					a->saml2__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml2__Evidence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__EvidenceType(soap, "saml2:Evidence", &a->saml2__Evidence, "saml2:EvidenceType"))
				{	soap_flag_saml2__Evidence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Action)
			soap_pop_block(soap, soap_blist_saml2__Action);
		if (a->__sizeAction)
		{	a->saml2__Action = (struct saml2__ActionType *)soap_save_block(soap, soap_blist_saml2__Action, NULL, 1);
		}
		else
		{	a->saml2__Action = NULL;
			if (soap_blist_saml2__Action)
				soap_end_block(soap, soap_blist_saml2__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthzDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthzDecisionStatementType, SOAP_TYPE_saml2__AuthzDecisionStatementType, sizeof(struct saml2__AuthzDecisionStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_new_saml2__AuthzDecisionStatementType(struct soap *soap, int n)
{
	struct saml2__AuthzDecisionStatementType *p;
	struct saml2__AuthzDecisionStatementType *a = (struct saml2__AuthzDecisionStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AuthzDecisionStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AuthzDecisionStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthzDecisionStatementType(struct soap *soap, const struct saml2__AuthzDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthzDecisionStatementType(soap, tag ? tag : "saml2:AuthzDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthzDecisionStatementType * SOAP_FMAC4 soap_get_saml2__AuthzDecisionStatementType(struct soap *soap, struct saml2__AuthzDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthzDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml2__AuthnContextClassRef);
	a->saml2__AuthnContextDecl = NULL;
	soap_default_string(soap, &a->saml2__AuthnContextDeclRef);
	a->__sizeAuthenticatingAuthority = 0;
	a->saml2__AuthenticatingAuthority = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextClassRef);
	soap_serialize_string(soap, (char*const*)&a->saml2__AuthnContextDeclRef);
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__AuthenticatingAuthority + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnContextType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnContextType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnContextType), type))
		return soap->error;
	if (soap_out_string(soap, "saml2:AuthnContextClassRef", -1, (char*const*)&a->saml2__AuthnContextClassRef, ""))
		return soap->error;
	soap_outliteral(soap, "saml2:AuthnContextDecl", (char*const*)&a->saml2__AuthnContextDecl, NULL);
	if (soap_out_string(soap, "saml2:AuthnContextDeclRef", -1, (char*const*)&a->saml2__AuthnContextDeclRef, ""))
		return soap->error;
	if (a->saml2__AuthenticatingAuthority)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthenticatingAuthority; i++)
			soap_out_string(soap, "saml2:AuthenticatingAuthority", -1, (char*const*)(a->saml2__AuthenticatingAuthority + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_in_saml2__AuthnContextType(struct soap *soap, const char *tag, struct saml2__AuthnContextType *a, const char *type)
{
	size_t soap_flag_saml2__AuthnContextClassRef = 1;
	size_t soap_flag_saml2__AuthnContextDecl = 1;
	size_t soap_flag_saml2__AuthnContextDeclRef = 1;
	struct soap_blist *soap_blist_saml2__AuthenticatingAuthority = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AuthnContextType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnContextType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__AuthnContextClassRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml2:AuthnContextClassRef", (char**)&a->saml2__AuthnContextClassRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextClassRef--;
					continue;
				}
			if (soap_flag_saml2__AuthnContextDecl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "saml2:AuthnContextDecl", (char**)&a->saml2__AuthnContextDecl))
				{	soap_flag_saml2__AuthnContextDecl--;
					continue;
				}
			if (soap_flag_saml2__AuthnContextDeclRef && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml2:AuthnContextDeclRef", (char**)&a->saml2__AuthnContextDeclRef, "xsd:string"))
				{	soap_flag_saml2__AuthnContextDeclRef--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:AuthenticatingAuthority", 1, NULL))
			{	if (a->saml2__AuthenticatingAuthority == NULL)
				{	if (soap_blist_saml2__AuthenticatingAuthority == NULL)
						soap_blist_saml2__AuthenticatingAuthority = soap_alloc_block(soap);
					a->saml2__AuthenticatingAuthority = (char **)soap_push_block_max(soap, soap_blist_saml2__AuthenticatingAuthority, sizeof(char *));
					if (a->saml2__AuthenticatingAuthority == NULL)
						return NULL;
					*a->saml2__AuthenticatingAuthority = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:AuthenticatingAuthority", (char**)a->saml2__AuthenticatingAuthority, "xsd:string"))
				{	a->__sizeAuthenticatingAuthority++;
					a->saml2__AuthenticatingAuthority = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__AuthenticatingAuthority)
			soap_pop_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		if (a->__sizeAuthenticatingAuthority)
		{	a->saml2__AuthenticatingAuthority = (char **)soap_save_block(soap, soap_blist_saml2__AuthenticatingAuthority, NULL, 1);
		}
		else
		{	a->saml2__AuthenticatingAuthority = NULL;
			if (soap_blist_saml2__AuthenticatingAuthority)
				soap_end_block(soap, soap_blist_saml2__AuthenticatingAuthority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AuthnContextType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnContextType, SOAP_TYPE_saml2__AuthnContextType, sizeof(struct saml2__AuthnContextType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_new_saml2__AuthnContextType(struct soap *soap, int n)
{
	struct saml2__AuthnContextType *p;
	struct saml2__AuthnContextType *a = (struct saml2__AuthnContextType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AuthnContextType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AuthnContextType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnContextType(struct soap *soap, const struct saml2__AuthnContextType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnContextType(soap, tag ? tag : "saml2:AuthnContextType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnContextType * SOAP_FMAC4 soap_get_saml2__AuthnContextType(struct soap *soap, struct saml2__AuthnContextType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnContextType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	soap_default_string(soap, &a->DNSName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectLocalityType *a, const char *type)
{
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	if (a->DNSName)
		soap_set_attr(soap, "DNSName", soap_string2s(soap, a->DNSName), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_in_saml2__SubjectLocalityType(struct soap *soap, const char *tag, struct saml2__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__SubjectLocalityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 0), &a->Address))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSName", 0), &a->DNSName))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectLocalityType, SOAP_TYPE_saml2__SubjectLocalityType, sizeof(struct saml2__SubjectLocalityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_new_saml2__SubjectLocalityType(struct soap *soap, int n)
{
	struct saml2__SubjectLocalityType *p;
	struct saml2__SubjectLocalityType *a = (struct saml2__SubjectLocalityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectLocalityType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectLocalityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectLocalityType(struct soap *soap, const struct saml2__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectLocalityType(soap, tag ? tag : "saml2:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectLocalityType * SOAP_FMAC4 soap_get_saml2__SubjectLocalityType(struct soap *soap, struct saml2__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__SubjectLocality = NULL;
	a->saml2__AuthnContext = NULL;
	soap_default_dateTime(soap, &a->AuthnInstant);
	soap_default_string(soap, &a->SessionIndex);
	a->SessionNotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__SubjectLocalityType(soap, &a->saml2__SubjectLocality);
	soap_serialize_PointerTosaml2__AuthnContextType(soap, &a->saml2__AuthnContext);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AuthnStatementType(struct soap *soap, const char *tag, int id, const struct saml2__AuthnStatementType *a, const char *type)
{
	soap_set_attr(soap, "AuthnInstant", soap_dateTime2s(soap, a->AuthnInstant), 1);
	if (a->SessionIndex)
		soap_set_attr(soap, "SessionIndex", soap_string2s(soap, a->SessionIndex), 1);
	if (a->SessionNotOnOrAfter)
		soap_set_attr(soap, "SessionNotOnOrAfter", soap_dateTime2s(soap, *a->SessionNotOnOrAfter), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AuthnStatementType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", -1, &a->saml2__SubjectLocality, ""))
		return soap->error;
	if (!a->saml2__AuthnContext)
	{	if (soap_element_nil(soap, "saml2:AuthnContext"))
			return soap->error;
	}
	else
	if (soap_out_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", -1, &a->saml2__AuthnContext, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_in_saml2__AuthnStatementType(struct soap *soap, const char *tag, struct saml2__AuthnStatementType *a, const char *type)
{
	size_t soap_flag_saml2__SubjectLocality = 1;
	size_t soap_flag_saml2__AuthnContext = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AuthnStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AuthnStatementType(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "AuthnInstant", 1), &a->AuthnInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SessionIndex", 0), &a->SessionIndex))
		return NULL;
	{	const char *t = soap_attr_value(soap, "SessionNotOnOrAfter", 0);
		if (t)
		{
			if (!(a->SessionNotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->SessionNotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__SubjectLocalityType(soap, "saml2:SubjectLocality", &a->saml2__SubjectLocality, "saml2:SubjectLocalityType"))
				{	soap_flag_saml2__SubjectLocality--;
					continue;
				}
			if (soap_flag_saml2__AuthnContext && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AuthnContextType(soap, "saml2:AuthnContext", &a->saml2__AuthnContext, "saml2:AuthnContextType"))
				{	soap_flag_saml2__AuthnContext--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_saml2__AuthnContext > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AuthnStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AuthnStatementType, SOAP_TYPE_saml2__AuthnStatementType, sizeof(struct saml2__AuthnStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_new_saml2__AuthnStatementType(struct soap *soap, int n)
{
	struct saml2__AuthnStatementType *p;
	struct saml2__AuthnStatementType *a = (struct saml2__AuthnStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AuthnStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AuthnStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AuthnStatementType(struct soap *soap, const struct saml2__AuthnStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AuthnStatementType(soap, tag ? tag : "saml2:AuthnStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AuthnStatementType * SOAP_FMAC4 soap_get_saml2__AuthnStatementType(struct soap *soap, struct saml2__AuthnStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AuthnStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_in_saml2__StatementAbstractType(struct soap *soap, const char *tag, struct saml2__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__StatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__StatementAbstractType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__StatementAbstractType, SOAP_TYPE_saml2__StatementAbstractType, sizeof(struct saml2__StatementAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_new_saml2__StatementAbstractType(struct soap *soap, int n)
{
	struct saml2__StatementAbstractType *p;
	struct saml2__StatementAbstractType *a = (struct saml2__StatementAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__StatementAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml2__StatementAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__StatementAbstractType(struct soap *soap, const struct saml2__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__StatementAbstractType(soap, tag ? tag : "saml2:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__StatementAbstractType * SOAP_FMAC4 soap_get_saml2__StatementAbstractType(struct soap *soap, struct saml2__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml2__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AdviceType(struct soap *soap, const char *tag, int id, const struct saml2__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml2__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_in_saml2__AdviceType(struct soap *soap, const char *tag, struct saml2__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AdviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AdviceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = (struct __saml2__union_AdviceType *)soap_push_block_max(soap, soap_blist___union_AdviceType, sizeof(struct __saml2__union_AdviceType));
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml2__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml2__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml2:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_pop_block(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = (struct __saml2__union_AdviceType *)soap_save_block(soap, soap_blist___union_AdviceType, NULL, 1);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_end_block(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AdviceType, SOAP_TYPE_saml2__AdviceType, sizeof(struct saml2__AdviceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_new_saml2__AdviceType(struct soap *soap, int n)
{
	struct saml2__AdviceType *p;
	struct saml2__AdviceType *a = (struct saml2__AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AdviceType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AdviceType(struct soap *soap, const struct saml2__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AdviceType(soap, tag ? tag : "saml2:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AdviceType * SOAP_FMAC4 soap_get_saml2__AdviceType(struct soap *soap, struct saml2__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
	soap_default_string(soap, &a->Count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__ProxyRestrictionType *a, const char *type)
{
	if (a->Count)
		soap_set_attr(soap, "Count", soap_string2s(soap, a->Count), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ProxyRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_in_saml2__ProxyRestrictionType(struct soap *soap, const char *tag, struct saml2__ProxyRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__ProxyRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ProxyRestrictionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Count", 0), &a->Count))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ProxyRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ProxyRestrictionType, SOAP_TYPE_saml2__ProxyRestrictionType, sizeof(struct saml2__ProxyRestrictionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_new_saml2__ProxyRestrictionType(struct soap *soap, int n)
{
	struct saml2__ProxyRestrictionType *p;
	struct saml2__ProxyRestrictionType *a = (struct saml2__ProxyRestrictionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ProxyRestrictionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ProxyRestrictionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ProxyRestrictionType(struct soap *soap, const struct saml2__ProxyRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ProxyRestrictionType(soap, tag ? tag : "saml2:ProxyRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ProxyRestrictionType * SOAP_FMAC4 soap_get_saml2__ProxyRestrictionType(struct soap *soap, struct saml2__ProxyRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ProxyRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__OneTimeUseType(struct soap *soap, const char *tag, int id, const struct saml2__OneTimeUseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__OneTimeUseType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_in_saml2__OneTimeUseType(struct soap *soap, const char *tag, struct saml2__OneTimeUseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__OneTimeUseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__OneTimeUseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__OneTimeUseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__OneTimeUseType, SOAP_TYPE_saml2__OneTimeUseType, sizeof(struct saml2__OneTimeUseType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_new_saml2__OneTimeUseType(struct soap *soap, int n)
{
	struct saml2__OneTimeUseType *p;
	struct saml2__OneTimeUseType *a = (struct saml2__OneTimeUseType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__OneTimeUseType));
	for (p = a; p && n--; p++)
		soap_default_saml2__OneTimeUseType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__OneTimeUseType(struct soap *soap, const struct saml2__OneTimeUseType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__OneTimeUseType(soap, tag ? tag : "saml2:OneTimeUseType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__OneTimeUseType * SOAP_FMAC4 soap_get_saml2__OneTimeUseType(struct soap *soap, struct saml2__OneTimeUseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__OneTimeUseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml2__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml2__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, int id, const struct saml2__AudienceRestrictionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AudienceRestrictionType), type))
		return soap->error;
	if (a->saml2__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			soap_out_string(soap, "saml2:Audience", -1, (char*const*)(a->saml2__Audience + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_in_saml2__AudienceRestrictionType(struct soap *soap, const char *tag, struct saml2__AudienceRestrictionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml2__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AudienceRestrictionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AudienceRestrictionType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:Audience", 1, NULL))
			{	if (a->saml2__Audience == NULL)
				{	if (soap_blist_saml2__Audience == NULL)
						soap_blist_saml2__Audience = soap_alloc_block(soap);
					a->saml2__Audience = (char **)soap_push_block_max(soap, soap_blist_saml2__Audience, sizeof(char *));
					if (a->saml2__Audience == NULL)
						return NULL;
					*a->saml2__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml2:Audience", (char**)a->saml2__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml2__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__Audience)
			soap_pop_block(soap, soap_blist_saml2__Audience);
		if (a->__sizeAudience)
		{	a->saml2__Audience = (char **)soap_save_block(soap, soap_blist_saml2__Audience, NULL, 1);
		}
		else
		{	a->saml2__Audience = NULL;
			if (soap_blist_saml2__Audience)
				soap_end_block(soap, soap_blist_saml2__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AudienceRestrictionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AudienceRestrictionType, SOAP_TYPE_saml2__AudienceRestrictionType, sizeof(struct saml2__AudienceRestrictionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_new_saml2__AudienceRestrictionType(struct soap *soap, int n)
{
	struct saml2__AudienceRestrictionType *p;
	struct saml2__AudienceRestrictionType *a = (struct saml2__AudienceRestrictionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AudienceRestrictionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AudienceRestrictionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AudienceRestrictionType(struct soap *soap, const struct saml2__AudienceRestrictionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AudienceRestrictionType(soap, tag ? tag : "saml2:AudienceRestrictionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AudienceRestrictionType * SOAP_FMAC4 soap_get_saml2__AudienceRestrictionType(struct soap *soap, struct saml2__AudienceRestrictionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AudienceRestrictionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_in_saml2__ConditionAbstractType(struct soap *soap, const char *tag, struct saml2__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__ConditionAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionAbstractType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionAbstractType, SOAP_TYPE_saml2__ConditionAbstractType, sizeof(struct saml2__ConditionAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_new_saml2__ConditionAbstractType(struct soap *soap, int n)
{
	struct saml2__ConditionAbstractType *p;
	struct saml2__ConditionAbstractType *a = (struct saml2__ConditionAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ConditionAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ConditionAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionAbstractType(struct soap *soap, const struct saml2__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionAbstractType(soap, tag ? tag : "saml2:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionAbstractType * SOAP_FMAC4 soap_get_saml2__ConditionAbstractType(struct soap *soap, struct saml2__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml2__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml2__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
		soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
	if (a->NotOnOrAfter)
		soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml2__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_in_saml2__ConditionsType(struct soap *soap, const char *tag, struct saml2__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__ConditionsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__ConditionsType(soap, a);
	{	const char *t = soap_attr_value(soap, "NotBefore", 0);
		if (t)
		{
			if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NotOnOrAfter", 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = (struct __saml2__union_ConditionsType *)soap_push_block_max(soap, soap_blist___union_ConditionsType, sizeof(struct __saml2__union_ConditionsType));
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml2__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml2__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml2:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_pop_block(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = (struct __saml2__union_ConditionsType *)soap_save_block(soap, soap_blist___union_ConditionsType, NULL, 1);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_end_block(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__ConditionsType, SOAP_TYPE_saml2__ConditionsType, sizeof(struct saml2__ConditionsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_new_saml2__ConditionsType(struct soap *soap, int n)
{
	struct saml2__ConditionsType *p;
	struct saml2__ConditionsType *a = (struct saml2__ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__ConditionsType));
	for (p = a; p && n--; p++)
		soap_default_saml2__ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__ConditionsType(struct soap *soap, const struct saml2__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__ConditionsType(soap, tag ? tag : "saml2:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__ConditionsType * SOAP_FMAC4 soap_get_saml2__ConditionsType(struct soap *soap, struct saml2__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeds__KeyInfo = 0;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
		{
			soap_serialize_PointerTo_ds__KeyInfo(soap, a->ds__KeyInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType), type))
		return soap->error;
	if (a->ds__KeyInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeds__KeyInfo; i++)
			if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, a->ds__KeyInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_in_saml2__KeyInfoConfirmationDataType(struct soap *soap, const char *tag, struct saml2__KeyInfoConfirmationDataType *a, const char *type)
{
	struct soap_blist *soap_blist_ds__KeyInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__KeyInfoConfirmationDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:KeyInfo", 1, NULL))
			{	if (a->ds__KeyInfo == NULL)
				{	if (soap_blist_ds__KeyInfo == NULL)
						soap_blist_ds__KeyInfo = soap_alloc_block(soap);
					a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_push_block_max(soap, soap_blist_ds__KeyInfo, sizeof(struct ds__KeyInfoType *));
					if (a->ds__KeyInfo == NULL)
						return NULL;
					*a->ds__KeyInfo = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", a->ds__KeyInfo, ""))
				{	a->__sizeds__KeyInfo++;
					a->ds__KeyInfo = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ds__KeyInfo)
			soap_pop_block(soap, soap_blist_ds__KeyInfo);
		if (a->__sizeds__KeyInfo)
		{	a->ds__KeyInfo = (struct ds__KeyInfoType **)soap_save_block(soap, soap_blist_ds__KeyInfo, NULL, 1);
		}
		else
		{	a->ds__KeyInfo = NULL;
			if (soap_blist_ds__KeyInfo)
				soap_end_block(soap, soap_blist_ds__KeyInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeds__KeyInfo < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__KeyInfoConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, SOAP_TYPE_saml2__KeyInfoConfirmationDataType, sizeof(struct saml2__KeyInfoConfirmationDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_new_saml2__KeyInfoConfirmationDataType(struct soap *soap, int n)
{
	struct saml2__KeyInfoConfirmationDataType *p;
	struct saml2__KeyInfoConfirmationDataType *a = (struct saml2__KeyInfoConfirmationDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__KeyInfoConfirmationDataType));
	for (p = a; p && n--; p++)
		soap_default_saml2__KeyInfoConfirmationDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__KeyInfoConfirmationDataType(struct soap *soap, const struct saml2__KeyInfoConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__KeyInfoConfirmationDataType(soap, tag ? tag : "saml2:KeyInfoConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__KeyInfoConfirmationDataType * SOAP_FMAC4 soap_get_saml2__KeyInfoConfirmationDataType(struct soap *soap, struct saml2__KeyInfoConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__KeyInfoConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
	soap_default_string(soap, &a->Recipient);
	soap_default_string(soap, &a->InResponseTo);
	soap_default_string(soap, &a->Address);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	if (a->NotBefore)
		soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
	if (a->NotOnOrAfter)
		soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	if (a->InResponseTo)
		soap_set_attr(soap, "InResponseTo", soap_string2s(soap, a->InResponseTo), 1);
	if (a->Address)
		soap_set_attr(soap, "Address", soap_string2s(soap, a->Address), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationDataType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationDataType *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__SubjectConfirmationDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationDataType(soap, a);
	{	const char *t = soap_attr_value(soap, "NotBefore", 0);
		if (t)
		{
			if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NotOnOrAfter", 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "InResponseTo", 0), &a->InResponseTo))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Address", 0), &a->Address))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationDataType, SOAP_TYPE_saml2__SubjectConfirmationDataType, sizeof(struct saml2__SubjectConfirmationDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_new_saml2__SubjectConfirmationDataType(struct soap *soap, int n)
{
	struct saml2__SubjectConfirmationDataType *p;
	struct saml2__SubjectConfirmationDataType *a = (struct saml2__SubjectConfirmationDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectConfirmationDataType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectConfirmationDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationDataType(struct soap *soap, const struct saml2__SubjectConfirmationDataType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationDataType(soap, tag ? tag : "saml2:SubjectConfirmationDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationDataType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationDataType(struct soap *soap, struct saml2__SubjectConfirmationDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->saml2__SubjectConfirmationData = NULL;
	soap_default_string(soap, &a->Method);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	soap_serialize_PointerTosaml2__SubjectConfirmationDataType(soap, &a->saml2__SubjectConfirmationData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectConfirmationType *a, const char *type)
{
	if (a->Method)
		soap_set_attr(soap, "Method", soap_string2s(soap, a->Method), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectConfirmationType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", -1, &a->saml2__SubjectConfirmationData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml2__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml2__SubjectConfirmationType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	size_t soap_flag_saml2__SubjectConfirmationData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__SubjectConfirmationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectConfirmationType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Method", 1), &a->Method))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			if (soap_flag_saml2__SubjectConfirmationData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__SubjectConfirmationDataType(soap, "saml2:SubjectConfirmationData", &a->saml2__SubjectConfirmationData, "saml2:SubjectConfirmationDataType"))
				{	soap_flag_saml2__SubjectConfirmationData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectConfirmationType, SOAP_TYPE_saml2__SubjectConfirmationType, sizeof(struct saml2__SubjectConfirmationType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_new_saml2__SubjectConfirmationType(struct soap *soap, int n)
{
	struct saml2__SubjectConfirmationType *p;
	struct saml2__SubjectConfirmationType *a = (struct saml2__SubjectConfirmationType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectConfirmationType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectConfirmationType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectConfirmationType(struct soap *soap, const struct saml2__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectConfirmationType(soap, tag ? tag : "saml2:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml2__SubjectConfirmationType(struct soap *soap, struct saml2__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__BaseID = NULL;
	a->saml2__NameID = NULL;
	a->saml2__EncryptedID = NULL;
	a->__sizeSubjectConfirmation = 0;
	a->saml2__SubjectConfirmation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__BaseIDAbstractType(soap, &a->saml2__BaseID);
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__NameID);
	soap_serialize_PointerTosaml2__EncryptedElementType(soap, &a->saml2__EncryptedID);
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
		{
			soap_embedded(soap, a->saml2__SubjectConfirmation + i, SOAP_TYPE_saml2__SubjectConfirmationType);
			soap_serialize_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__SubjectType(struct soap *soap, const char *tag, int id, const struct saml2__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", -1, &a->saml2__BaseID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:NameID", -1, &a->saml2__NameID, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", -1, &a->saml2__EncryptedID, ""))
		return soap->error;
	if (a->saml2__SubjectConfirmation)
	{	int i;
		for (i = 0; i < (int)a->__sizeSubjectConfirmation; i++)
			if (soap_out_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", -1, a->saml2__SubjectConfirmation + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_in_saml2__SubjectType(struct soap *soap, const char *tag, struct saml2__SubjectType *a, const char *type)
{
	size_t soap_flag_saml2__BaseID = 1;
	size_t soap_flag_saml2__NameID = 1;
	size_t soap_flag_saml2__EncryptedID = 1;
	struct soap_blist *soap_blist_saml2__SubjectConfirmation = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__SubjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__SubjectType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__BaseID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__BaseIDAbstractType(soap, "saml2:BaseID", &a->saml2__BaseID, "saml2:BaseIDAbstractType"))
				{	soap_flag_saml2__BaseID--;
					continue;
				}
			if (soap_flag_saml2__NameID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:NameID", &a->saml2__NameID, "saml2:NameIDType"))
				{	soap_flag_saml2__NameID--;
					continue;
				}
			if (soap_flag_saml2__EncryptedID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__EncryptedElementType(soap, "saml2:EncryptedID", &a->saml2__EncryptedID, "saml2:EncryptedElementType"))
				{	soap_flag_saml2__EncryptedID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml2:SubjectConfirmation", 1, NULL))
			{	if (a->saml2__SubjectConfirmation == NULL)
				{	if (soap_blist_saml2__SubjectConfirmation == NULL)
						soap_blist_saml2__SubjectConfirmation = soap_alloc_block(soap);
					a->saml2__SubjectConfirmation = (struct saml2__SubjectConfirmationType *)soap_push_block_max(soap, soap_blist_saml2__SubjectConfirmation, sizeof(struct saml2__SubjectConfirmationType));
					if (a->saml2__SubjectConfirmation == NULL)
						return NULL;
					soap_default_saml2__SubjectConfirmationType(soap, a->saml2__SubjectConfirmation);
				}
				soap_revert(soap);
				if (soap_in_saml2__SubjectConfirmationType(soap, "saml2:SubjectConfirmation", a->saml2__SubjectConfirmation, "saml2:SubjectConfirmationType"))
				{	a->__sizeSubjectConfirmation++;
					a->saml2__SubjectConfirmation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml2__SubjectConfirmation)
			soap_pop_block(soap, soap_blist_saml2__SubjectConfirmation);
		if (a->__sizeSubjectConfirmation)
		{	a->saml2__SubjectConfirmation = (struct saml2__SubjectConfirmationType *)soap_save_block(soap, soap_blist_saml2__SubjectConfirmation, NULL, 1);
		}
		else
		{	a->saml2__SubjectConfirmation = NULL;
			if (soap_blist_saml2__SubjectConfirmation)
				soap_end_block(soap, soap_blist_saml2__SubjectConfirmation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__SubjectType, SOAP_TYPE_saml2__SubjectType, sizeof(struct saml2__SubjectType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_new_saml2__SubjectType(struct soap *soap, int n)
{
	struct saml2__SubjectType *p;
	struct saml2__SubjectType *a = (struct saml2__SubjectType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__SubjectType));
	for (p = a; p && n--; p++)
		soap_default_saml2__SubjectType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__SubjectType(struct soap *soap, const struct saml2__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__SubjectType(soap, tag ? tag : "saml2:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__SubjectType * SOAP_FMAC4 soap_get_saml2__SubjectType(struct soap *soap, struct saml2__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml2__Issuer = NULL;
	a->ds__Signature = NULL;
	a->saml2__Subject = NULL;
	a->saml2__Conditions = NULL;
	a->saml2__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->ID);
	soap_default_dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml2__NameIDType(soap, &a->saml2__Issuer);
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
	soap_serialize_PointerTosaml2__SubjectType(soap, &a->saml2__Subject);
	soap_serialize_PointerTosaml2__ConditionsType(soap, &a->saml2__Conditions);
	soap_serialize_PointerTosaml2__AdviceType(soap, &a->saml2__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml2__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__AssertionType(struct soap *soap, const char *tag, int id, const struct saml2__AssertionType *a, const char *type)
{
	if (a->Version)
		soap_set_attr(soap, "Version", soap_string2s(soap, a->Version), 1);
	if (a->ID)
		soap_set_attr(soap, "ID", soap_string2s(soap, a->ID), 1);
	soap_set_attr(soap, "IssueInstant", soap_dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__AssertionType), type))
		return soap->error;
	if (!a->saml2__Issuer)
	{	if (soap_element_nil(soap, "saml2:Issuer"))
			return soap->error;
	}
	else
	if (soap_out_PointerTosaml2__NameIDType(soap, "saml2:Issuer", -1, &a->saml2__Issuer, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__SubjectType(soap, "saml2:Subject", -1, &a->saml2__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", -1, &a->saml2__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml2__AdviceType(soap, "saml2:Advice", -1, &a->saml2__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml2__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_in_saml2__AssertionType(struct soap *soap, const char *tag, struct saml2__AssertionType *a, const char *type)
{
	size_t soap_flag_saml2__Issuer = 1;
	size_t soap_flag_ds__Signature = 1;
	size_t soap_flag_saml2__Subject = 1;
	size_t soap_flag_saml2__Conditions = 1;
	size_t soap_flag_saml2__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__AssertionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Version", 1), &a->Version))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ID", 1), &a->ID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "IssueInstant", 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml2__Issuer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__NameIDType(soap, "saml2:Issuer", &a->saml2__Issuer, "saml2:NameIDType"))
				{	soap_flag_saml2__Issuer--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap_flag_saml2__Subject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__SubjectType(soap, "saml2:Subject", &a->saml2__Subject, "saml2:SubjectType"))
				{	soap_flag_saml2__Subject--;
					continue;
				}
			if (soap_flag_saml2__Conditions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__ConditionsType(soap, "saml2:Conditions", &a->saml2__Conditions, "saml2:ConditionsType"))
				{	soap_flag_saml2__Conditions--;
					continue;
				}
			if (soap_flag_saml2__Advice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml2__AdviceType(soap, "saml2:Advice", &a->saml2__Advice, "saml2:AdviceType"))
				{	soap_flag_saml2__Advice--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = (struct __saml2__union_AssertionType *)soap_push_block_max(soap, soap_blist___union_AssertionType, sizeof(struct __saml2__union_AssertionType));
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml2__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml2__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml2:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_pop_block(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = (struct __saml2__union_AssertionType *)soap_save_block(soap, soap_blist___union_AssertionType, NULL, 1);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_end_block(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_saml2__Issuer > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__AssertionType, SOAP_TYPE_saml2__AssertionType, sizeof(struct saml2__AssertionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_new_saml2__AssertionType(struct soap *soap, int n)
{
	struct saml2__AssertionType *p;
	struct saml2__AssertionType *a = (struct saml2__AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__AssertionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__AssertionType(struct soap *soap, const struct saml2__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__AssertionType(soap, tag ? tag : "saml2:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__AssertionType * SOAP_FMAC4 soap_get_saml2__AssertionType(struct soap *soap, struct saml2__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	a->__sizexenc__EncryptedKey = 0;
	a->xenc__EncryptedKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xenc__EncryptedDataType(soap, &a->xenc__EncryptedData);
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
		{
			soap_serialize_PointerToxenc__EncryptedKeyType(soap, a->xenc__EncryptedKey + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__EncryptedElementType(struct soap *soap, const char *tag, int id, const struct saml2__EncryptedElementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__EncryptedElementType), type))
		return soap->error;
	if (soap_out_xenc__EncryptedDataType(soap, "xenc:EncryptedData", -1, &a->xenc__EncryptedData, ""))
		return soap->error;
	if (a->xenc__EncryptedKey)
	{	int i;
		for (i = 0; i < (int)a->__sizexenc__EncryptedKey; i++)
			if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, a->xenc__EncryptedKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_in_saml2__EncryptedElementType(struct soap *soap, const char *tag, struct saml2__EncryptedElementType *a, const char *type)
{
	size_t soap_flag_xenc__EncryptedData = 1;
	struct soap_blist *soap_blist_xenc__EncryptedKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__EncryptedElementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__EncryptedElementType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xenc__EncryptedData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xenc__EncryptedDataType(soap, "xenc:EncryptedData", &a->xenc__EncryptedData, "xenc:EncryptedDataType"))
				{	soap_flag_xenc__EncryptedData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptedKey", 1, NULL))
			{	if (a->xenc__EncryptedKey == NULL)
				{	if (soap_blist_xenc__EncryptedKey == NULL)
						soap_blist_xenc__EncryptedKey = soap_alloc_block(soap);
					a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_push_block_max(soap, soap_blist_xenc__EncryptedKey, sizeof(struct xenc__EncryptedKeyType *));
					if (a->xenc__EncryptedKey == NULL)
						return NULL;
					*a->xenc__EncryptedKey = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	a->__sizexenc__EncryptedKey++;
					a->xenc__EncryptedKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->xenc__EncryptedKey)
			soap_pop_block(soap, soap_blist_xenc__EncryptedKey);
		if (a->__sizexenc__EncryptedKey)
		{	a->xenc__EncryptedKey = (struct xenc__EncryptedKeyType **)soap_save_block(soap, soap_blist_xenc__EncryptedKey, NULL, 1);
		}
		else
		{	a->xenc__EncryptedKey = NULL;
			if (soap_blist_xenc__EncryptedKey)
				soap_end_block(soap, soap_blist_xenc__EncryptedKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xenc__EncryptedData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml2__EncryptedElementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__EncryptedElementType, SOAP_TYPE_saml2__EncryptedElementType, sizeof(struct saml2__EncryptedElementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_new_saml2__EncryptedElementType(struct soap *soap, int n)
{
	struct saml2__EncryptedElementType *p;
	struct saml2__EncryptedElementType *a = (struct saml2__EncryptedElementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__EncryptedElementType));
	for (p = a; p && n--; p++)
		soap_default_saml2__EncryptedElementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__EncryptedElementType(struct soap *soap, const struct saml2__EncryptedElementType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__EncryptedElementType(soap, tag ? tag : "saml2:EncryptedElementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__EncryptedElementType * SOAP_FMAC4 soap_get_saml2__EncryptedElementType(struct soap *soap, struct saml2__EncryptedElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__EncryptedElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Format);
	soap_default_string(soap, &a->SPProvidedID);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__NameIDType(struct soap *soap, const char *tag, int id, const struct saml2__NameIDType *a, const char *type)
{
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	if (a->SPProvidedID)
		soap_set_attr(soap, "SPProvidedID", soap_string2s(soap, a->SPProvidedID), 1);
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_in_saml2__NameIDType(struct soap *soap, const char *tag, struct saml2__NameIDType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct saml2__NameIDType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__NameIDType, sizeof(struct saml2__NameIDType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml2__NameIDType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 0), &a->Format))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPProvidedID", 0), &a->SPProvidedID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 0), &a->SPNameQualifier))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml2:NameIDType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_new_saml2__NameIDType(struct soap *soap, int n)
{
	struct saml2__NameIDType *p;
	struct saml2__NameIDType *a = (struct saml2__NameIDType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__NameIDType));
	for (p = a; p && n--; p++)
		soap_default_saml2__NameIDType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__NameIDType(struct soap *soap, const struct saml2__NameIDType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__NameIDType(soap, tag ? tag : "saml2:NameIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__NameIDType * SOAP_FMAC4 soap_get_saml2__NameIDType(struct soap *soap, struct saml2__NameIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__NameIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->SPNameQualifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, int id, const struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->SPNameQualifier)
		soap_set_attr(soap, "SPNameQualifier", soap_string2s(soap, a->SPNameQualifier), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__BaseIDAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_in_saml2__BaseIDAbstractType(struct soap *soap, const char *tag, struct saml2__BaseIDAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml2__BaseIDAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml2__BaseIDAbstractType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SPNameQualifier", 0), &a->SPNameQualifier))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml2__BaseIDAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__BaseIDAbstractType, SOAP_TYPE_saml2__BaseIDAbstractType, sizeof(struct saml2__BaseIDAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_new_saml2__BaseIDAbstractType(struct soap *soap, int n)
{
	struct saml2__BaseIDAbstractType *p;
	struct saml2__BaseIDAbstractType *a = (struct saml2__BaseIDAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml2__BaseIDAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml2__BaseIDAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__BaseIDAbstractType(struct soap *soap, const struct saml2__BaseIDAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__BaseIDAbstractType(soap, tag ? tag : "saml2:BaseIDAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml2__BaseIDAbstractType * SOAP_FMAC4 soap_get_saml2__BaseIDAbstractType(struct soap *soap, struct saml2__BaseIDAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__BaseIDAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_EvidenceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_in___saml1__union_EvidenceType(struct soap *soap, const char *tag, struct __saml1__union_EvidenceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_EvidenceType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_EvidenceType, sizeof(struct __saml1__union_EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_EvidenceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_new___saml1__union_EvidenceType(struct soap *soap, int n)
{
	struct __saml1__union_EvidenceType *p;
	struct __saml1__union_EvidenceType *a = (struct __saml1__union_EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_EvidenceType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_EvidenceType(struct soap *soap, const struct __saml1__union_EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_EvidenceType(soap, tag ? tag : "-saml1:union-EvidenceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_EvidenceType * SOAP_FMAC4 soap_get___saml1__union_EvidenceType(struct soap *soap, struct __saml1__union_EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->saml1__AssertionIDReference);
	a->saml1__Assertion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->saml1__AssertionIDReference);
	soap_serialize_PointerTosaml1__AssertionType(soap, &a->saml1__Assertion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AdviceType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_string(soap, "saml1:AssertionIDReference", -1, (char*const*)&a->saml1__AssertionIDReference, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AssertionType(soap, "saml1:Assertion", -1, &a->saml1__Assertion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_in___saml1__union_AdviceType(struct soap *soap, const char *tag, struct __saml1__union_AdviceType *a, const char *type)
{
	size_t soap_flag_saml1__AssertionIDReference = 1;
	size_t soap_flag_saml1__Assertion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AdviceType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AdviceType, sizeof(struct __saml1__union_AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AdviceType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AssertionIDReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "saml1:AssertionIDReference", (char**)&a->saml1__AssertionIDReference, "xsd:string"))
				{	soap_flag_saml1__AssertionIDReference--;
					continue;
				}
			if (soap_flag_saml1__Assertion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AssertionType(soap, "saml1:Assertion", &a->saml1__Assertion, "saml1:AssertionType"))
				{	soap_flag_saml1__Assertion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_new___saml1__union_AdviceType(struct soap *soap, int n)
{
	struct __saml1__union_AdviceType *p;
	struct __saml1__union_AdviceType *a = (struct __saml1__union_AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_AdviceType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AdviceType(struct soap *soap, const struct __saml1__union_AdviceType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AdviceType(soap, tag ? tag : "-saml1:union-AdviceType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AdviceType * SOAP_FMAC4 soap_get___saml1__union_AdviceType(struct soap *soap, struct __saml1__union_AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__AudienceRestrictionCondition = NULL;
	a->saml1__DoNotCacheCondition = NULL;
	a->saml1__Condition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__AudienceRestrictionConditionType(soap, &a->saml1__AudienceRestrictionCondition);
	soap_serialize_PointerTosaml1__DoNotCacheConditionType(soap, &a->saml1__DoNotCacheCondition);
	soap_serialize_PointerTosaml1__ConditionAbstractType(soap, &a->saml1__Condition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_ConditionsType(struct soap *soap, const char *tag, int id, const struct __saml1__union_ConditionsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", -1, &a->saml1__AudienceRestrictionCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", -1, &a->saml1__DoNotCacheCondition, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", -1, &a->saml1__Condition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_in___saml1__union_ConditionsType(struct soap *soap, const char *tag, struct __saml1__union_ConditionsType *a, const char *type)
{
	size_t soap_flag_saml1__AudienceRestrictionCondition = 1;
	size_t soap_flag_saml1__DoNotCacheCondition = 1;
	size_t soap_flag_saml1__Condition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_ConditionsType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_ConditionsType, sizeof(struct __saml1__union_ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_ConditionsType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__AudienceRestrictionCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AudienceRestrictionConditionType(soap, "saml1:AudienceRestrictionCondition", &a->saml1__AudienceRestrictionCondition, "saml1:AudienceRestrictionConditionType"))
				{	soap_flag_saml1__AudienceRestrictionCondition--;
					continue;
				}
			if (soap_flag_saml1__DoNotCacheCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__DoNotCacheConditionType(soap, "saml1:DoNotCacheCondition", &a->saml1__DoNotCacheCondition, "saml1:DoNotCacheConditionType"))
				{	soap_flag_saml1__DoNotCacheCondition--;
					continue;
				}
			if (soap_flag_saml1__Condition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__ConditionAbstractType(soap, "saml1:Condition", &a->saml1__Condition, "saml1:ConditionAbstractType"))
				{	soap_flag_saml1__Condition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_new___saml1__union_ConditionsType(struct soap *soap, int n)
{
	struct __saml1__union_ConditionsType *p;
	struct __saml1__union_ConditionsType *a = (struct __saml1__union_ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_ConditionsType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_ConditionsType(struct soap *soap, const struct __saml1__union_ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_ConditionsType(soap, tag ? tag : "-saml1:union-ConditionsType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_ConditionsType * SOAP_FMAC4 soap_get___saml1__union_ConditionsType(struct soap *soap, struct __saml1__union_ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Statement = NULL;
	a->saml1__SubjectStatement = NULL;
	a->saml1__AuthenticationStatement = NULL;
	a->saml1__AuthorizationDecisionStatement = NULL;
	a->saml1__AttributeStatement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__StatementAbstractType(soap, &a->saml1__Statement);
	soap_serialize_PointerTosaml1__SubjectStatementAbstractType(soap, &a->saml1__SubjectStatement);
	soap_serialize_PointerTosaml1__AuthenticationStatementType(soap, &a->saml1__AuthenticationStatement);
	soap_serialize_PointerTosaml1__AuthorizationDecisionStatementType(soap, &a->saml1__AuthorizationDecisionStatement);
	soap_serialize_PointerTosaml1__AttributeStatementType(soap, &a->saml1__AttributeStatement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___saml1__union_AssertionType(struct soap *soap, const char *tag, int id, const struct __saml1__union_AssertionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", -1, &a->saml1__Statement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", -1, &a->saml1__SubjectStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", -1, &a->saml1__AuthenticationStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", -1, &a->saml1__AuthorizationDecisionStatement, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", -1, &a->saml1__AttributeStatement, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_in___saml1__union_AssertionType(struct soap *soap, const char *tag, struct __saml1__union_AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Statement = 1;
	size_t soap_flag_saml1__SubjectStatement = 1;
	size_t soap_flag_saml1__AuthenticationStatement = 1;
	size_t soap_flag_saml1__AuthorizationDecisionStatement = 1;
	size_t soap_flag_saml1__AttributeStatement = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __saml1__union_AssertionType *)soap_id_enter(soap, "", a, SOAP_TYPE___saml1__union_AssertionType, sizeof(struct __saml1__union_AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___saml1__union_AssertionType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Statement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__StatementAbstractType(soap, "saml1:Statement", &a->saml1__Statement, "saml1:StatementAbstractType"))
				{	soap_flag_saml1__Statement--;
					continue;
				}
			if (soap_flag_saml1__SubjectStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectStatementAbstractType(soap, "saml1:SubjectStatement", &a->saml1__SubjectStatement, "saml1:SubjectStatementAbstractType"))
				{	soap_flag_saml1__SubjectStatement--;
					continue;
				}
			if (soap_flag_saml1__AuthenticationStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AuthenticationStatementType(soap, "saml1:AuthenticationStatement", &a->saml1__AuthenticationStatement, "saml1:AuthenticationStatementType"))
				{	soap_flag_saml1__AuthenticationStatement--;
					continue;
				}
			if (soap_flag_saml1__AuthorizationDecisionStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AuthorizationDecisionStatementType(soap, "saml1:AuthorizationDecisionStatement", &a->saml1__AuthorizationDecisionStatement, "saml1:AuthorizationDecisionStatementType"))
				{	soap_flag_saml1__AuthorizationDecisionStatement--;
					continue;
				}
			if (soap_flag_saml1__AttributeStatement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AttributeStatementType(soap, "saml1:AttributeStatement", &a->saml1__AttributeStatement, "saml1:AttributeStatementType"))
				{	soap_flag_saml1__AttributeStatement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_new___saml1__union_AssertionType(struct soap *soap, int n)
{
	struct __saml1__union_AssertionType *p;
	struct __saml1__union_AssertionType *a = (struct __saml1__union_AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __saml1__union_AssertionType));
	for (p = a; p && n--; p++)
		soap_default___saml1__union_AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___saml1__union_AssertionType(struct soap *soap, const struct __saml1__union_AssertionType *a, const char *tag, const char *type)
{
	if (soap_out___saml1__union_AssertionType(soap, tag ? tag : "-saml1:union-AssertionType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __saml1__union_AssertionType * SOAP_FMAC4 soap_get___saml1__union_AssertionType(struct soap *soap, struct __saml1__union_AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in___saml1__union_AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
	a->__sizeAttributeValue = 0;
	a->saml1__AttributeValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeType *a, const char *type)
{
	if (a->AttributeName)
		soap_set_attr(soap, "AttributeName", soap_string2s(soap, a->AttributeName), 1);
	if (a->AttributeNamespace)
		soap_set_attr(soap, "AttributeNamespace", soap_string2s(soap, a->AttributeNamespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeType), type))
		return soap->error;
	if (a->saml1__AttributeValue)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttributeValue; i++)
			soap_outliteral(soap, "saml1:AttributeValue", (char*const*)(a->saml1__AttributeValue + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_in_saml1__AttributeType(struct soap *soap, const char *tag, struct saml1__AttributeType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__AttributeValue = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AttributeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AttributeValue", 1, NULL))
			{	if (a->saml1__AttributeValue == NULL)
				{	if (soap_blist_saml1__AttributeValue == NULL)
						soap_blist_saml1__AttributeValue = soap_alloc_block(soap);
					a->saml1__AttributeValue = (char **)soap_push_block_max(soap, soap_blist_saml1__AttributeValue, sizeof(char *));
					if (a->saml1__AttributeValue == NULL)
						return NULL;
					*a->saml1__AttributeValue = NULL;
				}
				soap_revert(soap);
				if (soap_inliteral(soap, "saml1:AttributeValue", (char**)a->saml1__AttributeValue))
				{	a->__sizeAttributeValue++;
					a->saml1__AttributeValue = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AttributeValue)
			soap_pop_block(soap, soap_blist_saml1__AttributeValue);
		if (a->__sizeAttributeValue)
		{	a->saml1__AttributeValue = (char **)soap_save_block(soap, soap_blist_saml1__AttributeValue, NULL, 1);
		}
		else
		{	a->saml1__AttributeValue = NULL;
			if (soap_blist_saml1__AttributeValue)
				soap_end_block(soap, soap_blist_saml1__AttributeValue);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAttributeValue < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeType, SOAP_TYPE_saml1__AttributeType, sizeof(struct saml1__AttributeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_new_saml1__AttributeType(struct soap *soap, int n)
{
	struct saml1__AttributeType *p;
	struct saml1__AttributeType *a = (struct saml1__AttributeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AttributeType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AttributeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeType(struct soap *soap, const struct saml1__AttributeType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeType(soap, tag ? tag : "saml1:AttributeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeType * SOAP_FMAC4 soap_get_saml1__AttributeType(struct soap *soap, struct saml1__AttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->AttributeName);
	soap_default_string(soap, &a->AttributeNamespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeDesignatorType *a, const char *type)
{
	if (a->AttributeName)
		soap_set_attr(soap, "AttributeName", soap_string2s(soap, a->AttributeName), 1);
	if (a->AttributeNamespace)
		soap_set_attr(soap, "AttributeNamespace", soap_string2s(soap, a->AttributeNamespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeDesignatorType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_in_saml1__AttributeDesignatorType(struct soap *soap, const char *tag, struct saml1__AttributeDesignatorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AttributeDesignatorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeDesignatorType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeName", 1), &a->AttributeName))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AttributeNamespace", 1), &a->AttributeNamespace))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AttributeDesignatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeDesignatorType, SOAP_TYPE_saml1__AttributeDesignatorType, sizeof(struct saml1__AttributeDesignatorType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_new_saml1__AttributeDesignatorType(struct soap *soap, int n)
{
	struct saml1__AttributeDesignatorType *p;
	struct saml1__AttributeDesignatorType *a = (struct saml1__AttributeDesignatorType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AttributeDesignatorType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AttributeDesignatorType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeDesignatorType(struct soap *soap, const struct saml1__AttributeDesignatorType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeDesignatorType(soap, tag ? tag : "saml1:AttributeDesignatorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeDesignatorType * SOAP_FMAC4 soap_get_saml1__AttributeDesignatorType(struct soap *soap, struct saml1__AttributeDesignatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeDesignatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
