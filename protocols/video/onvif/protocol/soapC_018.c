/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetSynchronizationPointResponse(struct soap *soap, struct _ns6__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetSynchronizationPointResponse(struct soap *soap, const struct _ns6__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _ns6__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__ns6__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _ns6__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetSynchronizationPointResponse, sizeof(struct _ns6__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetSynchronizationPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetSynchronizationPointResponse, SOAP_TYPE__ns6__SetSynchronizationPointResponse, sizeof(struct _ns6__SetSynchronizationPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetSynchronizationPointResponse * SOAP_FMAC4 soap_new__ns6__SetSynchronizationPointResponse(struct soap *soap, int n)
{
	struct _ns6__SetSynchronizationPointResponse *p;
	struct _ns6__SetSynchronizationPointResponse *a = (struct _ns6__SetSynchronizationPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetSynchronizationPointResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetSynchronizationPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetSynchronizationPointResponse(struct soap *soap, const struct _ns6__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetSynchronizationPointResponse(soap, tag ? tag : "ns6:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__ns6__SetSynchronizationPointResponse(struct soap *soap, struct _ns6__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetSynchronizationPoint(struct soap *soap, struct _ns6__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetSynchronizationPoint(struct soap *soap, const struct _ns6__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _ns6__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetSynchronizationPoint), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns6:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetSynchronizationPoint * SOAP_FMAC4 soap_in__ns6__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _ns6__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetSynchronizationPoint, sizeof(struct _ns6__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetSynchronizationPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetSynchronizationPoint, SOAP_TYPE__ns6__SetSynchronizationPoint, sizeof(struct _ns6__SetSynchronizationPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetSynchronizationPoint * SOAP_FMAC4 soap_new__ns6__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct _ns6__SetSynchronizationPoint *p;
	struct _ns6__SetSynchronizationPoint *a = (struct _ns6__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetSynchronizationPoint(struct soap *soap, const struct _ns6__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetSynchronizationPoint(soap, tag ? tag : "ns6:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetSynchronizationPoint * SOAP_FMAC4 soap_get__ns6__SetSynchronizationPoint(struct soap *soap, struct _ns6__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetStreamUriResponse(struct soap *soap, struct _ns6__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetStreamUriResponse(struct soap *soap, const struct _ns6__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetStreamUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetStreamUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "ns6:Uri");
	if (!a->Uri)
	{	if (soap_element_nil(soap, "ns6:Uri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "ns6:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetStreamUriResponse * SOAP_FMAC4 soap_in__ns6__GetStreamUriResponse(struct soap *soap, const char *tag, struct _ns6__GetStreamUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetStreamUriResponse, sizeof(struct _ns6__GetStreamUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetStreamUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns6:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			soap_check_result(soap, "ns6:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetStreamUriResponse, SOAP_TYPE__ns6__GetStreamUriResponse, sizeof(struct _ns6__GetStreamUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetStreamUriResponse * SOAP_FMAC4 soap_new__ns6__GetStreamUriResponse(struct soap *soap, int n)
{
	struct _ns6__GetStreamUriResponse *p;
	struct _ns6__GetStreamUriResponse *a = (struct _ns6__GetStreamUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetStreamUriResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetStreamUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetStreamUriResponse(struct soap *soap, const struct _ns6__GetStreamUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetStreamUriResponse(soap, tag ? tag : "ns6:GetStreamUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetStreamUriResponse * SOAP_FMAC4 soap_get__ns6__GetStreamUriResponse(struct soap *soap, struct _ns6__GetStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetStreamUri(struct soap *soap, struct _ns6__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Protocol);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetStreamUri(struct soap *soap, const struct _ns6__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Protocol);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetStreamUri(struct soap *soap, const char *tag, int id, const struct _ns6__GetStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetStreamUri), type))
		return soap->error;
	if (!a->Protocol)
	{	if (soap_element_nil(soap, "ns6:Protocol"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns6:Protocol", -1, (char*const*)&a->Protocol, ""))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns6:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetStreamUri * SOAP_FMAC4 soap_in__ns6__GetStreamUri(struct soap *soap, const char *tag, struct _ns6__GetStreamUri *a, const char *type)
{
	size_t soap_flag_Protocol = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetStreamUri, sizeof(struct _ns6__GetStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetStreamUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Protocol", (char**)&a->Protocol, "xsd:string"))
				{	soap_flag_Protocol--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol > 0 || soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetStreamUri, SOAP_TYPE__ns6__GetStreamUri, sizeof(struct _ns6__GetStreamUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetStreamUri * SOAP_FMAC4 soap_new__ns6__GetStreamUri(struct soap *soap, int n)
{
	struct _ns6__GetStreamUri *p;
	struct _ns6__GetStreamUri *a = (struct _ns6__GetStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetStreamUri));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetStreamUri(struct soap *soap, const struct _ns6__GetStreamUri *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetStreamUri(soap, tag ? tag : "ns6:GetStreamUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetStreamUri * SOAP_FMAC4 soap_get__ns6__GetStreamUri(struct soap *soap, struct _ns6__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, struct _ns6__GetVideoEncoderInstancesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Info = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, const struct _ns6__GetVideoEncoderInstancesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__EncoderInstanceInfo(soap, &a->Info);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoEncoderInstancesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoEncoderInstancesResponse), type))
		return soap->error;
	if (a->Info)
		soap_element_result(soap, "ns6:Info");
	if (!a->Info)
	{	if (soap_element_nil(soap, "ns6:Info"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__EncoderInstanceInfo(soap, "ns6:Info", -1, &a->Info, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderInstancesResponse * SOAP_FMAC4 soap_in__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoEncoderInstancesResponse *a, const char *type)
{
	size_t soap_flag_Info = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoEncoderInstancesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoEncoderInstancesResponse, sizeof(struct _ns6__GetVideoEncoderInstancesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoEncoderInstancesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__EncoderInstanceInfo(soap, "ns6:Info", &a->Info, "ns6:EncoderInstanceInfo"))
				{	soap_flag_Info--;
					continue;
				}
			soap_check_result(soap, "ns6:Info");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Info > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoEncoderInstancesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoEncoderInstancesResponse, SOAP_TYPE__ns6__GetVideoEncoderInstancesResponse, sizeof(struct _ns6__GetVideoEncoderInstancesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderInstancesResponse * SOAP_FMAC4 soap_new__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, int n)
{
	struct _ns6__GetVideoEncoderInstancesResponse *p;
	struct _ns6__GetVideoEncoderInstancesResponse *a = (struct _ns6__GetVideoEncoderInstancesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoEncoderInstancesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoEncoderInstancesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, const struct _ns6__GetVideoEncoderInstancesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoEncoderInstancesResponse(soap, tag ? tag : "ns6:GetVideoEncoderInstancesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderInstancesResponse * SOAP_FMAC4 soap_get__ns6__GetVideoEncoderInstancesResponse(struct soap *soap, struct _ns6__GetVideoEncoderInstancesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoEncoderInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoEncoderInstances(struct soap *soap, struct _ns6__GetVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoEncoderInstances(struct soap *soap, const struct _ns6__GetVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoEncoderInstances(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoEncoderInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoEncoderInstances), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "ns6:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderInstances * SOAP_FMAC4 soap_in__ns6__GetVideoEncoderInstances(struct soap *soap, const char *tag, struct _ns6__GetVideoEncoderInstances *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoEncoderInstances *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoEncoderInstances, sizeof(struct _ns6__GetVideoEncoderInstances), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoEncoderInstances(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoEncoderInstances *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoEncoderInstances, SOAP_TYPE__ns6__GetVideoEncoderInstances, sizeof(struct _ns6__GetVideoEncoderInstances), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderInstances * SOAP_FMAC4 soap_new__ns6__GetVideoEncoderInstances(struct soap *soap, int n)
{
	struct _ns6__GetVideoEncoderInstances *p;
	struct _ns6__GetVideoEncoderInstances *a = (struct _ns6__GetVideoEncoderInstances*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoEncoderInstances));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoEncoderInstances(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoEncoderInstances(struct soap *soap, const struct _ns6__GetVideoEncoderInstances *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoEncoderInstances(soap, tag ? tag : "ns6:GetVideoEncoderInstances", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderInstances * SOAP_FMAC4 soap_get__ns6__GetVideoEncoderInstances(struct soap *soap, struct _ns6__GetVideoEncoderInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioDecoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions);
			soap_serialize_tt__AudioEncoder2ConfigurationOptions(soap, a->Options + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioDecoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioDecoderConfigurationOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOptions");
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
			if (soap_out_tt__AudioEncoder2ConfigurationOptions(soap, "ns6:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioDecoderConfigurationOptionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioDecoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioDecoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioDecoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_alloc_block(soap);
					a->Options = (struct tt__AudioEncoder2ConfigurationOptions *)soap_push_block_max(soap, soap_blist_Options, sizeof(struct tt__AudioEncoder2ConfigurationOptions));
					if (a->Options == NULL)
						return NULL;
					soap_default_tt__AudioEncoder2ConfigurationOptions(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoder2ConfigurationOptions(soap, "ns6:Options", a->Options, "tt:AudioEncoder2ConfigurationOptions"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
		{	a->Options = (struct tt__AudioEncoder2ConfigurationOptions *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		}
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOptions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioDecoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioDecoderConfigurationOptionsResponse, SOAP_TYPE__ns6__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioDecoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioDecoderConfigurationOptionsResponse *p;
	struct _ns6__GetAudioDecoderConfigurationOptionsResponse *a = (struct _ns6__GetAudioDecoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioDecoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioDecoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioDecoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioDecoderConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetAudioDecoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioDecoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioOutputConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "ns6:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "ns6:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, "ns6:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioOutputConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioOutputConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfigurationOptions(soap, "ns6:Options", &a->Options, "tt:AudioOutputConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "ns6:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioOutputConfigurationOptionsResponse, SOAP_TYPE__ns6__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioOutputConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioOutputConfigurationOptionsResponse *p;
	struct _ns6__GetAudioOutputConfigurationOptionsResponse *a = (struct _ns6__GetAudioOutputConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioOutputConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioOutputConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioOutputConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioOutputConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetAudioOutputConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetMetadataConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MetadataConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetMetadataConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetMetadataConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "ns6:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "ns6:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, "ns6:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetMetadataConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetMetadataConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetMetadataConfigurationOptionsResponse, sizeof(struct _ns6__GetMetadataConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetMetadataConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfigurationOptions(soap, "ns6:Options", &a->Options, "tt:MetadataConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "ns6:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetMetadataConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetMetadataConfigurationOptionsResponse, SOAP_TYPE__ns6__GetMetadataConfigurationOptionsResponse, sizeof(struct _ns6__GetMetadataConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetMetadataConfigurationOptionsResponse *p;
	struct _ns6__GetMetadataConfigurationOptionsResponse *a = (struct _ns6__GetMetadataConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetMetadataConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetMetadataConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetMetadataConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetMetadataConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetMetadataConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetMetadataConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions);
			soap_serialize_tt__AudioEncoder2ConfigurationOptions(soap, a->Options + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioEncoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioEncoderConfigurationOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOptions");
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
			if (soap_out_tt__AudioEncoder2ConfigurationOptions(soap, "ns6:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioEncoderConfigurationOptionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_alloc_block(soap);
					a->Options = (struct tt__AudioEncoder2ConfigurationOptions *)soap_push_block_max(soap, soap_blist_Options, sizeof(struct tt__AudioEncoder2ConfigurationOptions));
					if (a->Options == NULL)
						return NULL;
					soap_default_tt__AudioEncoder2ConfigurationOptions(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoder2ConfigurationOptions(soap, "ns6:Options", a->Options, "tt:AudioEncoder2ConfigurationOptions"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
		{	a->Options = (struct tt__AudioEncoder2ConfigurationOptions *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		}
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOptions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioEncoderConfigurationOptionsResponse, SOAP_TYPE__ns6__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioEncoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioEncoderConfigurationOptionsResponse *p;
	struct _ns6__GetAudioEncoderConfigurationOptionsResponse *a = (struct _ns6__GetAudioEncoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioEncoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioEncoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioEncoderConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetAudioEncoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "ns6:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "ns6:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, "ns6:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioSourceConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfigurationOptions(soap, "ns6:Options", &a->Options, "tt:AudioSourceConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "ns6:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioSourceConfigurationOptionsResponse, SOAP_TYPE__ns6__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _ns6__GetAudioSourceConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioSourceConfigurationOptionsResponse *p;
	struct _ns6__GetAudioSourceConfigurationOptionsResponse *a = (struct _ns6__GetAudioSourceConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioSourceConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioSourceConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetAudioSourceConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioSourceConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetAudioSourceConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions);
			soap_serialize_tt__VideoEncoder2ConfigurationOptions(soap, a->Options + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoEncoderConfigurationOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOptions");
	if (a->Options)
	{	int i;
		for (i = 0; i < (int)a->__sizeOptions; i++)
			if (soap_out_tt__VideoEncoder2ConfigurationOptions(soap, "ns6:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _ns6__GetVideoEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_alloc_block(soap);
					a->Options = (struct tt__VideoEncoder2ConfigurationOptions *)soap_push_block_max(soap, soap_blist_Options, sizeof(struct tt__VideoEncoder2ConfigurationOptions));
					if (a->Options == NULL)
						return NULL;
					soap_default_tt__VideoEncoder2ConfigurationOptions(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoEncoder2ConfigurationOptions(soap, "ns6:Options", a->Options, "tt:VideoEncoder2ConfigurationOptions"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
		{	a->Options = (struct tt__VideoEncoder2ConfigurationOptions *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		}
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOptions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoEncoderConfigurationOptionsResponse, SOAP_TYPE__ns6__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _ns6__GetVideoEncoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetVideoEncoderConfigurationOptionsResponse *p;
	struct _ns6__GetVideoEncoderConfigurationOptionsResponse *a = (struct _ns6__GetVideoEncoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoEncoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoEncoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetVideoEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoEncoderConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetVideoEncoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetVideoSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "ns6:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "ns6:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, "ns6:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoSourceConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _ns6__GetVideoSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoSourceConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptions(soap, "ns6:Options", &a->Options, "tt:VideoSourceConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "ns6:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoSourceConfigurationOptionsResponse, SOAP_TYPE__ns6__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _ns6__GetVideoSourceConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns6__GetVideoSourceConfigurationOptionsResponse *p;
	struct _ns6__GetVideoSourceConfigurationOptionsResponse *a = (struct _ns6__GetVideoSourceConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoSourceConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoSourceConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const struct _ns6__GetVideoSourceConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoSourceConfigurationOptionsResponse(soap, tag ? tag : "ns6:GetVideoSourceConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns6__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetAudioDecoderConfiguration(struct soap *soap, struct _ns6__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetAudioDecoderConfiguration(struct soap *soap, const struct _ns6__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetAudioDecoderConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_in__ns6__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _ns6__SetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetAudioDecoderConfiguration, sizeof(struct _ns6__SetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "ns6:Configuration", &a->Configuration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetAudioDecoderConfiguration, SOAP_TYPE__ns6__SetAudioDecoderConfiguration, sizeof(struct _ns6__SetAudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_new__ns6__SetAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetAudioDecoderConfiguration *p;
	struct _ns6__SetAudioDecoderConfiguration *a = (struct _ns6__SetAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetAudioDecoderConfiguration(struct soap *soap, const struct _ns6__SetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetAudioDecoderConfiguration(soap, tag ? tag : "ns6:SetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_get__ns6__SetAudioDecoderConfiguration(struct soap *soap, struct _ns6__SetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetAudioOutputConfiguration(struct soap *soap, struct _ns6__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetAudioOutputConfiguration(struct soap *soap, const struct _ns6__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetAudioOutputConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetAudioOutputConfiguration * SOAP_FMAC4 soap_in__ns6__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _ns6__SetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetAudioOutputConfiguration, sizeof(struct _ns6__SetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetAudioOutputConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "ns6:Configuration", &a->Configuration, "tt:AudioOutputConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetAudioOutputConfiguration, SOAP_TYPE__ns6__SetAudioOutputConfiguration, sizeof(struct _ns6__SetAudioOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetAudioOutputConfiguration * SOAP_FMAC4 soap_new__ns6__SetAudioOutputConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetAudioOutputConfiguration *p;
	struct _ns6__SetAudioOutputConfiguration *a = (struct _ns6__SetAudioOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetAudioOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetAudioOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetAudioOutputConfiguration(struct soap *soap, const struct _ns6__SetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetAudioOutputConfiguration(soap, tag ? tag : "ns6:SetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetAudioOutputConfiguration * SOAP_FMAC4 soap_get__ns6__SetAudioOutputConfiguration(struct soap *soap, struct _ns6__SetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetMetadataConfiguration(struct soap *soap, struct _ns6__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetMetadataConfiguration(struct soap *soap, const struct _ns6__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MetadataConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetMetadataConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MetadataConfiguration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetMetadataConfiguration * SOAP_FMAC4 soap_in__ns6__SetMetadataConfiguration(struct soap *soap, const char *tag, struct _ns6__SetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetMetadataConfiguration, sizeof(struct _ns6__SetMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetMetadataConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "ns6:Configuration", &a->Configuration, "tt:MetadataConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetMetadataConfiguration, SOAP_TYPE__ns6__SetMetadataConfiguration, sizeof(struct _ns6__SetMetadataConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetMetadataConfiguration * SOAP_FMAC4 soap_new__ns6__SetMetadataConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetMetadataConfiguration *p;
	struct _ns6__SetMetadataConfiguration *a = (struct _ns6__SetMetadataConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetMetadataConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetMetadataConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetMetadataConfiguration(struct soap *soap, const struct _ns6__SetMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetMetadataConfiguration(soap, tag ? tag : "ns6:SetMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetMetadataConfiguration * SOAP_FMAC4 soap_get__ns6__SetMetadataConfiguration(struct soap *soap, struct _ns6__SetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetAudioSourceConfiguration(struct soap *soap, struct _ns6__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetAudioSourceConfiguration(struct soap *soap, const struct _ns6__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetAudioSourceConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetAudioSourceConfiguration * SOAP_FMAC4 soap_in__ns6__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _ns6__SetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetAudioSourceConfiguration, sizeof(struct _ns6__SetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetAudioSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "ns6:Configuration", &a->Configuration, "tt:AudioSourceConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetAudioSourceConfiguration, SOAP_TYPE__ns6__SetAudioSourceConfiguration, sizeof(struct _ns6__SetAudioSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetAudioSourceConfiguration * SOAP_FMAC4 soap_new__ns6__SetAudioSourceConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetAudioSourceConfiguration *p;
	struct _ns6__SetAudioSourceConfiguration *a = (struct _ns6__SetAudioSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetAudioSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetAudioSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetAudioSourceConfiguration(struct soap *soap, const struct _ns6__SetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetAudioSourceConfiguration(soap, tag ? tag : "ns6:SetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetAudioSourceConfiguration * SOAP_FMAC4 soap_get__ns6__SetAudioSourceConfiguration(struct soap *soap, struct _ns6__SetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetAudioEncoderConfiguration(struct soap *soap, struct _ns6__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetAudioEncoderConfiguration(struct soap *soap, const struct _ns6__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioEncoder2Configuration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetAudioEncoderConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioEncoder2Configuration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_in__ns6__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _ns6__SetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetAudioEncoderConfiguration, sizeof(struct _ns6__SetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetAudioEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoder2Configuration(soap, "ns6:Configuration", &a->Configuration, "tt:AudioEncoder2Configuration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetAudioEncoderConfiguration, SOAP_TYPE__ns6__SetAudioEncoderConfiguration, sizeof(struct _ns6__SetAudioEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_new__ns6__SetAudioEncoderConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetAudioEncoderConfiguration *p;
	struct _ns6__SetAudioEncoderConfiguration *a = (struct _ns6__SetAudioEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetAudioEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetAudioEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetAudioEncoderConfiguration(struct soap *soap, const struct _ns6__SetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetAudioEncoderConfiguration(soap, tag ? tag : "ns6:SetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_get__ns6__SetAudioEncoderConfiguration(struct soap *soap, struct _ns6__SetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetVideoSourceConfiguration(struct soap *soap, struct _ns6__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetVideoSourceConfiguration(struct soap *soap, const struct _ns6__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetVideoSourceConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceConfiguration * SOAP_FMAC4 soap_in__ns6__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _ns6__SetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetVideoSourceConfiguration, sizeof(struct _ns6__SetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetVideoSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "ns6:Configuration", &a->Configuration, "tt:VideoSourceConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetVideoSourceConfiguration, SOAP_TYPE__ns6__SetVideoSourceConfiguration, sizeof(struct _ns6__SetVideoSourceConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetVideoSourceConfiguration * SOAP_FMAC4 soap_new__ns6__SetVideoSourceConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetVideoSourceConfiguration *p;
	struct _ns6__SetVideoSourceConfiguration *a = (struct _ns6__SetVideoSourceConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetVideoSourceConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetVideoSourceConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetVideoSourceConfiguration(struct soap *soap, const struct _ns6__SetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetVideoSourceConfiguration(soap, tag ? tag : "ns6:SetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceConfiguration * SOAP_FMAC4 soap_get__ns6__SetVideoSourceConfiguration(struct soap *soap, struct _ns6__SetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetConfigurationResponse(struct soap *soap, struct _ns6__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetConfigurationResponse(struct soap *soap, const struct _ns6__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _ns6__SetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetConfigurationResponse * SOAP_FMAC4 soap_in__ns6__SetConfigurationResponse(struct soap *soap, const char *tag, struct _ns6__SetConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetConfigurationResponse, sizeof(struct _ns6__SetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetConfigurationResponse, SOAP_TYPE__ns6__SetConfigurationResponse, sizeof(struct _ns6__SetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetConfigurationResponse * SOAP_FMAC4 soap_new__ns6__SetConfigurationResponse(struct soap *soap, int n)
{
	struct _ns6__SetConfigurationResponse *p;
	struct _ns6__SetConfigurationResponse *a = (struct _ns6__SetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetConfigurationResponse(struct soap *soap, const struct _ns6__SetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetConfigurationResponse(soap, tag ? tag : "ns6:SetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetConfigurationResponse * SOAP_FMAC4 soap_get__ns6__SetConfigurationResponse(struct soap *soap, struct _ns6__SetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__SetVideoEncoderConfiguration(struct soap *soap, struct _ns6__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__SetVideoEncoderConfiguration(struct soap *soap, const struct _ns6__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoEncoder2Configuration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__SetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__SetVideoEncoderConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns6:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoEncoder2Configuration(soap, "ns6:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in__ns6__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _ns6__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__SetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__SetVideoEncoderConfiguration, sizeof(struct _ns6__SetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__SetVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoder2Configuration(soap, "ns6:Configuration", &a->Configuration, "tt:VideoEncoder2Configuration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__SetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__SetVideoEncoderConfiguration, SOAP_TYPE__ns6__SetVideoEncoderConfiguration, sizeof(struct _ns6__SetVideoEncoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_new__ns6__SetVideoEncoderConfiguration(struct soap *soap, int n)
{
	struct _ns6__SetVideoEncoderConfiguration *p;
	struct _ns6__SetVideoEncoderConfiguration *a = (struct _ns6__SetVideoEncoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__SetVideoEncoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__SetVideoEncoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__SetVideoEncoderConfiguration(struct soap *soap, const struct _ns6__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__SetVideoEncoderConfiguration(soap, tag ? tag : "ns6:SetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get__ns6__SetVideoEncoderConfiguration(struct soap *soap, struct _ns6__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioDecoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioDecoderConfiguration);
			soap_serialize_tt__AudioDecoderConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioDecoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioDecoderConfiguration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioDecoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioDecoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse, sizeof(struct _ns6__GetAudioDecoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioDecoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioDecoderConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioDecoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioDecoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioDecoderConfiguration(soap, "ns6:Configurations", a->Configurations, "tt:AudioDecoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioDecoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioDecoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse, sizeof(struct _ns6__GetAudioDecoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioDecoderConfigurationsResponse *p;
	struct _ns6__GetAudioDecoderConfigurationsResponse *a = (struct _ns6__GetAudioDecoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioDecoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioDecoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioDecoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioDecoderConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioDecoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioOutputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioOutputConfiguration);
			soap_serialize_tt__AudioOutputConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioOutputConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioOutputConfiguration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioOutputConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioOutputConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse, sizeof(struct _ns6__GetAudioOutputConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioOutputConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioOutputConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioOutputConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioOutputConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioOutputConfiguration(soap, "ns6:Configurations", a->Configurations, "tt:AudioOutputConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioOutputConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioOutputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse, sizeof(struct _ns6__GetAudioOutputConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioOutputConfigurationsResponse *p;
	struct _ns6__GetAudioOutputConfigurationsResponse *a = (struct _ns6__GetAudioOutputConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioOutputConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioOutputConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioOutputConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioOutputConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioOutputConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetMetadataConfigurationsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetMetadataConfigurationsResponse(struct soap *soap, const struct _ns6__GetMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__MetadataConfiguration);
			soap_serialize_tt__MetadataConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetMetadataConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__MetadataConfiguration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetMetadataConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetMetadataConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse, sizeof(struct _ns6__GetMetadataConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetMetadataConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__MetadataConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__MetadataConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__MetadataConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__MetadataConfiguration(soap, "ns6:Configurations", a->Configurations, "tt:MetadataConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__MetadataConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetMetadataConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse, sizeof(struct _ns6__GetMetadataConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetMetadataConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetMetadataConfigurationsResponse *p;
	struct _ns6__GetMetadataConfigurationsResponse *a = (struct _ns6__GetMetadataConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetMetadataConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetMetadataConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetMetadataConfigurationsResponse(struct soap *soap, const struct _ns6__GetMetadataConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetMetadataConfigurationsResponse(soap, tag ? tag : "ns6:GetMetadataConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetMetadataConfigurationsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, struct _ns6__GetAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, const struct _ns6__GetAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
			soap_serialize_tt__VideoAnalyticsConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAnalyticsConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoAnalyticsConfiguration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAnalyticsConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAnalyticsConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse, sizeof(struct _ns6__GetAnalyticsConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAnalyticsConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoAnalyticsConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoAnalyticsConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoAnalyticsConfiguration(soap, "ns6:Configurations", a->Configurations, "tt:VideoAnalyticsConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse, sizeof(struct _ns6__GetAnalyticsConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAnalyticsConfigurationsResponse *p;
	struct _ns6__GetAnalyticsConfigurationsResponse *a = (struct _ns6__GetAnalyticsConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAnalyticsConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAnalyticsConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, const struct _ns6__GetAnalyticsConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAnalyticsConfigurationsResponse(soap, tag ? tag : "ns6:GetAnalyticsConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, struct _ns6__GetAnalyticsConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioSourceConfiguration);
			soap_serialize_tt__AudioSourceConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioSourceConfiguration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse, sizeof(struct _ns6__GetAudioSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioSourceConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSourceConfiguration(soap, "ns6:Configurations", a->Configurations, "tt:AudioSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse, sizeof(struct _ns6__GetAudioSourceConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioSourceConfigurationsResponse *p;
	struct _ns6__GetAudioSourceConfigurationsResponse *a = (struct _ns6__GetAudioSourceConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioSourceConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioSourceConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioSourceConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioEncoder2Configuration);
			soap_serialize_tt__AudioEncoder2Configuration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioEncoder2Configuration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetAudioEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse, sizeof(struct _ns6__GetAudioEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetAudioEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__AudioEncoder2Configuration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__AudioEncoder2Configuration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioEncoder2Configuration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoder2Configuration(soap, "ns6:Configurations", a->Configurations, "tt:AudioEncoder2Configuration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__AudioEncoder2Configuration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse, sizeof(struct _ns6__GetAudioEncoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetAudioEncoderConfigurationsResponse *p;
	struct _ns6__GetAudioEncoderConfigurationsResponse *a = (struct _ns6__GetAudioEncoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetAudioEncoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetAudioEncoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _ns6__GetAudioEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetAudioEncoderConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _ns6__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoSourceConfiguration);
			soap_serialize_tt__VideoSourceConfiguration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoSourceConfiguration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse, sizeof(struct _ns6__GetVideoSourceConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoSourceConfiguration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSourceConfiguration(soap, "ns6:Configurations", a->Configurations, "tt:VideoSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse, sizeof(struct _ns6__GetVideoSourceConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetVideoSourceConfigurationsResponse *p;
	struct _ns6__GetVideoSourceConfigurationsResponse *a = (struct _ns6__GetVideoSourceConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoSourceConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoSourceConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _ns6__GetVideoSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoSourceConfigurationsResponse(soap, tag ? tag : "ns6:GetVideoSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _ns6__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoEncoder2Configuration);
			soap_serialize_tt__VideoEncoder2Configuration(soap, a->Configurations + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoEncoder2Configuration(soap, "ns6:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetVideoEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse, sizeof(struct _ns6__GetVideoEncoderConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetVideoEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_alloc_block(soap);
					a->Configurations = (struct tt__VideoEncoder2Configuration *)soap_push_block_max(soap, soap_blist_Configurations, sizeof(struct tt__VideoEncoder2Configuration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoEncoder2Configuration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoEncoder2Configuration(soap, "ns6:Configurations", a->Configurations, "tt:VideoEncoder2Configuration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
		{	a->Configurations = (struct tt__VideoEncoder2Configuration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		}
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse, sizeof(struct _ns6__GetVideoEncoderConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_new__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, int n)
{
	struct _ns6__GetVideoEncoderConfigurationsResponse *p;
	struct _ns6__GetVideoEncoderConfigurationsResponse *a = (struct _ns6__GetVideoEncoderConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetVideoEncoderConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetVideoEncoderConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _ns6__GetVideoEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetVideoEncoderConfigurationsResponse(soap, tag ? tag : "ns6:GetVideoEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__DeleteProfileResponse(struct soap *soap, struct _ns6__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__DeleteProfileResponse(struct soap *soap, const struct _ns6__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__DeleteProfileResponse(struct soap *soap, const char *tag, int id, const struct _ns6__DeleteProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__DeleteProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__DeleteProfileResponse * SOAP_FMAC4 soap_in__ns6__DeleteProfileResponse(struct soap *soap, const char *tag, struct _ns6__DeleteProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__DeleteProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__DeleteProfileResponse, sizeof(struct _ns6__DeleteProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__DeleteProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__DeleteProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__DeleteProfileResponse, SOAP_TYPE__ns6__DeleteProfileResponse, sizeof(struct _ns6__DeleteProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__DeleteProfileResponse * SOAP_FMAC4 soap_new__ns6__DeleteProfileResponse(struct soap *soap, int n)
{
	struct _ns6__DeleteProfileResponse *p;
	struct _ns6__DeleteProfileResponse *a = (struct _ns6__DeleteProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__DeleteProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__DeleteProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__DeleteProfileResponse(struct soap *soap, const struct _ns6__DeleteProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__DeleteProfileResponse(soap, tag ? tag : "ns6:DeleteProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__DeleteProfileResponse * SOAP_FMAC4 soap_get__ns6__DeleteProfileResponse(struct soap *soap, struct _ns6__DeleteProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__DeleteProfile(struct soap *soap, struct _ns6__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__DeleteProfile(struct soap *soap, const struct _ns6__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__DeleteProfile(struct soap *soap, const char *tag, int id, const struct _ns6__DeleteProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__DeleteProfile), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns6:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__DeleteProfile * SOAP_FMAC4 soap_in__ns6__DeleteProfile(struct soap *soap, const char *tag, struct _ns6__DeleteProfile *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__DeleteProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__DeleteProfile, sizeof(struct _ns6__DeleteProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__DeleteProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__DeleteProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__DeleteProfile, SOAP_TYPE__ns6__DeleteProfile, sizeof(struct _ns6__DeleteProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__DeleteProfile * SOAP_FMAC4 soap_new__ns6__DeleteProfile(struct soap *soap, int n)
{
	struct _ns6__DeleteProfile *p;
	struct _ns6__DeleteProfile *a = (struct _ns6__DeleteProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__DeleteProfile));
	for (p = a; p && n--; p++)
		soap_default__ns6__DeleteProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__DeleteProfile(struct soap *soap, const struct _ns6__DeleteProfile *a, const char *tag, const char *type)
{
	if (soap_out__ns6__DeleteProfile(soap, tag ? tag : "ns6:DeleteProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__DeleteProfile * SOAP_FMAC4 soap_get__ns6__DeleteProfile(struct soap *soap, struct _ns6__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__RemoveConfigurationResponse(struct soap *soap, struct _ns6__RemoveConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__RemoveConfigurationResponse(struct soap *soap, const struct _ns6__RemoveConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__RemoveConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _ns6__RemoveConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__RemoveConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__RemoveConfigurationResponse * SOAP_FMAC4 soap_in__ns6__RemoveConfigurationResponse(struct soap *soap, const char *tag, struct _ns6__RemoveConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__RemoveConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__RemoveConfigurationResponse, sizeof(struct _ns6__RemoveConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__RemoveConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__RemoveConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__RemoveConfigurationResponse, SOAP_TYPE__ns6__RemoveConfigurationResponse, sizeof(struct _ns6__RemoveConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__RemoveConfigurationResponse * SOAP_FMAC4 soap_new__ns6__RemoveConfigurationResponse(struct soap *soap, int n)
{
	struct _ns6__RemoveConfigurationResponse *p;
	struct _ns6__RemoveConfigurationResponse *a = (struct _ns6__RemoveConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__RemoveConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__RemoveConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__RemoveConfigurationResponse(struct soap *soap, const struct _ns6__RemoveConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__RemoveConfigurationResponse(soap, tag ? tag : "ns6:RemoveConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__RemoveConfigurationResponse * SOAP_FMAC4 soap_get__ns6__RemoveConfigurationResponse(struct soap *soap, struct _ns6__RemoveConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__RemoveConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__RemoveConfiguration(struct soap *soap, struct _ns6__RemoveConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__RemoveConfiguration(struct soap *soap, const struct _ns6__RemoveConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_ns6__ConfigurationRef);
			soap_serialize_ns6__ConfigurationRef(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__RemoveConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__RemoveConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__RemoveConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns6:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_ns6__ConfigurationRef(soap, "ns6:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__RemoveConfiguration * SOAP_FMAC4 soap_in__ns6__RemoveConfiguration(struct soap *soap, const char *tag, struct _ns6__RemoveConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__RemoveConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__RemoveConfiguration, sizeof(struct _ns6__RemoveConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__RemoveConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct ns6__ConfigurationRef *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct ns6__ConfigurationRef));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_ns6__ConfigurationRef(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_ns6__ConfigurationRef(soap, "ns6:Configuration", a->Configuration, "ns6:ConfigurationRef"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct ns6__ConfigurationRef *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__RemoveConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__RemoveConfiguration, SOAP_TYPE__ns6__RemoveConfiguration, sizeof(struct _ns6__RemoveConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__RemoveConfiguration * SOAP_FMAC4 soap_new__ns6__RemoveConfiguration(struct soap *soap, int n)
{
	struct _ns6__RemoveConfiguration *p;
	struct _ns6__RemoveConfiguration *a = (struct _ns6__RemoveConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__RemoveConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__RemoveConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__RemoveConfiguration(struct soap *soap, const struct _ns6__RemoveConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__RemoveConfiguration(soap, tag ? tag : "ns6:RemoveConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__RemoveConfiguration * SOAP_FMAC4 soap_get__ns6__RemoveConfiguration(struct soap *soap, struct _ns6__RemoveConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__RemoveConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__AddConfigurationResponse(struct soap *soap, struct _ns6__AddConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__AddConfigurationResponse(struct soap *soap, const struct _ns6__AddConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__AddConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _ns6__AddConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__AddConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__AddConfigurationResponse * SOAP_FMAC4 soap_in__ns6__AddConfigurationResponse(struct soap *soap, const char *tag, struct _ns6__AddConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__AddConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__AddConfigurationResponse, sizeof(struct _ns6__AddConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__AddConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__AddConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__AddConfigurationResponse, SOAP_TYPE__ns6__AddConfigurationResponse, sizeof(struct _ns6__AddConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__AddConfigurationResponse * SOAP_FMAC4 soap_new__ns6__AddConfigurationResponse(struct soap *soap, int n)
{
	struct _ns6__AddConfigurationResponse *p;
	struct _ns6__AddConfigurationResponse *a = (struct _ns6__AddConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__AddConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__AddConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__AddConfigurationResponse(struct soap *soap, const struct _ns6__AddConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__AddConfigurationResponse(soap, tag ? tag : "ns6:AddConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__AddConfigurationResponse * SOAP_FMAC4 soap_get__ns6__AddConfigurationResponse(struct soap *soap, struct _ns6__AddConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__AddConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__AddConfiguration(struct soap *soap, struct _ns6__AddConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__Name(soap, &a->Name);
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__AddConfiguration(struct soap *soap, const struct _ns6__AddConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_ns6__ConfigurationRef);
			soap_serialize_ns6__ConfigurationRef(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__AddConfiguration(struct soap *soap, const char *tag, int id, const struct _ns6__AddConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__AddConfiguration), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns6:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__Name(soap, "ns6:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_ns6__ConfigurationRef(soap, "ns6:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__AddConfiguration * SOAP_FMAC4 soap_in__ns6__AddConfiguration(struct soap *soap, const char *tag, struct _ns6__AddConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Name = 1;
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__AddConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__AddConfiguration, sizeof(struct _ns6__AddConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__AddConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "ns6:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct ns6__ConfigurationRef *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct ns6__ConfigurationRef));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_ns6__ConfigurationRef(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_ns6__ConfigurationRef(soap, "ns6:Configuration", a->Configuration, "ns6:ConfigurationRef"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct ns6__ConfigurationRef *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__AddConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__AddConfiguration, SOAP_TYPE__ns6__AddConfiguration, sizeof(struct _ns6__AddConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__AddConfiguration * SOAP_FMAC4 soap_new__ns6__AddConfiguration(struct soap *soap, int n)
{
	struct _ns6__AddConfiguration *p;
	struct _ns6__AddConfiguration *a = (struct _ns6__AddConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__AddConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns6__AddConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__AddConfiguration(struct soap *soap, const struct _ns6__AddConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns6__AddConfiguration(soap, tag ? tag : "ns6:AddConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__AddConfiguration * SOAP_FMAC4 soap_get__ns6__AddConfiguration(struct soap *soap, struct _ns6__AddConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__AddConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetProfilesResponse(struct soap *soap, struct _ns6__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetProfilesResponse(struct soap *soap, const struct _ns6__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_ns6__MediaProfile);
			soap_serialize_ns6__MediaProfile(soap, a->Profiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _ns6__GetProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeProfiles; i++)
			if (soap_out_ns6__MediaProfile(soap, "ns6:Profiles", -1, a->Profiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetProfilesResponse * SOAP_FMAC4 soap_in__ns6__GetProfilesResponse(struct soap *soap, const char *tag, struct _ns6__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetProfilesResponse, sizeof(struct _ns6__GetProfilesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Profiles", 1, NULL))
			{	if (a->Profiles == NULL)
				{	if (soap_blist_Profiles == NULL)
						soap_blist_Profiles = soap_alloc_block(soap);
					a->Profiles = (struct ns6__MediaProfile *)soap_push_block_max(soap, soap_blist_Profiles, sizeof(struct ns6__MediaProfile));
					if (a->Profiles == NULL)
						return NULL;
					soap_default_ns6__MediaProfile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_ns6__MediaProfile(soap, "ns6:Profiles", a->Profiles, "ns6:MediaProfile"))
				{	a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Profiles)
			soap_pop_block(soap, soap_blist_Profiles);
		if (a->__sizeProfiles)
		{	a->Profiles = (struct ns6__MediaProfile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		}
		else
		{	a->Profiles = NULL;
			if (soap_blist_Profiles)
				soap_end_block(soap, soap_blist_Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetProfilesResponse, SOAP_TYPE__ns6__GetProfilesResponse, sizeof(struct _ns6__GetProfilesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetProfilesResponse * SOAP_FMAC4 soap_new__ns6__GetProfilesResponse(struct soap *soap, int n)
{
	struct _ns6__GetProfilesResponse *p;
	struct _ns6__GetProfilesResponse *a = (struct _ns6__GetProfilesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetProfilesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetProfilesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetProfilesResponse(struct soap *soap, const struct _ns6__GetProfilesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetProfilesResponse(soap, tag ? tag : "ns6:GetProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetProfilesResponse * SOAP_FMAC4 soap_get__ns6__GetProfilesResponse(struct soap *soap, struct _ns6__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetProfiles(struct soap *soap, struct _ns6__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->__sizeType = 0;
	a->Type = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetProfiles(struct soap *soap, const struct _ns6__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Type + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetProfiles(struct soap *soap, const char *tag, int id, const struct _ns6__GetProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetProfiles), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "ns6:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	if (a->Type)
	{	int i;
		for (i = 0; i < (int)a->__sizeType; i++)
			soap_out_string(soap, "ns6:Type", -1, (char*const*)(a->Type + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetProfiles * SOAP_FMAC4 soap_in__ns6__GetProfiles(struct soap *soap, const char *tag, struct _ns6__GetProfiles *a, const char *type)
{
	size_t soap_flag_Token = 1;
	struct soap_blist *soap_blist_Type = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetProfiles, sizeof(struct _ns6__GetProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Type", 1, NULL))
			{	if (a->Type == NULL)
				{	if (soap_blist_Type == NULL)
						soap_blist_Type = soap_alloc_block(soap);
					a->Type = (char **)soap_push_block_max(soap, soap_blist_Type, sizeof(char *));
					if (a->Type == NULL)
						return NULL;
					*a->Type = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "ns6:Type", (char**)a->Type, "xsd:string"))
				{	a->__sizeType++;
					a->Type = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Type)
			soap_pop_block(soap, soap_blist_Type);
		if (a->__sizeType)
		{	a->Type = (char **)soap_save_block(soap, soap_blist_Type, NULL, 1);
		}
		else
		{	a->Type = NULL;
			if (soap_blist_Type)
				soap_end_block(soap, soap_blist_Type);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetProfiles, SOAP_TYPE__ns6__GetProfiles, sizeof(struct _ns6__GetProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetProfiles * SOAP_FMAC4 soap_new__ns6__GetProfiles(struct soap *soap, int n)
{
	struct _ns6__GetProfiles *p;
	struct _ns6__GetProfiles *a = (struct _ns6__GetProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetProfiles));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetProfiles(struct soap *soap, const struct _ns6__GetProfiles *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetProfiles(soap, tag ? tag : "ns6:GetProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetProfiles * SOAP_FMAC4 soap_get__ns6__GetProfiles(struct soap *soap, struct _ns6__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__CreateProfileResponse(struct soap *soap, struct _ns6__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__CreateProfileResponse(struct soap *soap, const struct _ns6__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__CreateProfileResponse(struct soap *soap, const char *tag, int id, const struct _ns6__CreateProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__CreateProfileResponse), type))
		return soap->error;
	if (a->Token)
		soap_element_result(soap, "ns6:Token");
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns6:Token"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__CreateProfileResponse * SOAP_FMAC4 soap_in__ns6__CreateProfileResponse(struct soap *soap, const char *tag, struct _ns6__CreateProfileResponse *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__CreateProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__CreateProfileResponse, sizeof(struct _ns6__CreateProfileResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__CreateProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			soap_check_result(soap, "ns6:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__CreateProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__CreateProfileResponse, SOAP_TYPE__ns6__CreateProfileResponse, sizeof(struct _ns6__CreateProfileResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__CreateProfileResponse * SOAP_FMAC4 soap_new__ns6__CreateProfileResponse(struct soap *soap, int n)
{
	struct _ns6__CreateProfileResponse *p;
	struct _ns6__CreateProfileResponse *a = (struct _ns6__CreateProfileResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__CreateProfileResponse));
	for (p = a; p && n--; p++)
		soap_default__ns6__CreateProfileResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__CreateProfileResponse(struct soap *soap, const struct _ns6__CreateProfileResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns6__CreateProfileResponse(soap, tag ? tag : "ns6:CreateProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__CreateProfileResponse * SOAP_FMAC4 soap_get__ns6__CreateProfileResponse(struct soap *soap, struct _ns6__CreateProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__CreateProfile(struct soap *soap, struct _ns6__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__CreateProfile(struct soap *soap, const struct _ns6__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_ns6__ConfigurationRef);
			soap_serialize_ns6__ConfigurationRef(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__CreateProfile(struct soap *soap, const char *tag, int id, const struct _ns6__CreateProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__CreateProfile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns6:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "ns6:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_ns6__ConfigurationRef(soap, "ns6:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__CreateProfile * SOAP_FMAC4 soap_in__ns6__CreateProfile(struct soap *soap, const char *tag, struct _ns6__CreateProfile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__CreateProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__CreateProfile, sizeof(struct _ns6__CreateProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__CreateProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "ns6:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct ns6__ConfigurationRef *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct ns6__ConfigurationRef));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_ns6__ConfigurationRef(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_ns6__ConfigurationRef(soap, "ns6:Configuration", a->Configuration, "ns6:ConfigurationRef"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct ns6__ConfigurationRef *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__CreateProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__CreateProfile, SOAP_TYPE__ns6__CreateProfile, sizeof(struct _ns6__CreateProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__CreateProfile * SOAP_FMAC4 soap_new__ns6__CreateProfile(struct soap *soap, int n)
{
	struct _ns6__CreateProfile *p;
	struct _ns6__CreateProfile *a = (struct _ns6__CreateProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__CreateProfile));
	for (p = a; p && n--; p++)
		soap_default__ns6__CreateProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__CreateProfile(struct soap *soap, const struct _ns6__CreateProfile *a, const char *tag, const char *type)
{
	if (soap_out__ns6__CreateProfile(soap, tag ? tag : "ns6:CreateProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__CreateProfile * SOAP_FMAC4 soap_get__ns6__CreateProfile(struct soap *soap, struct _ns6__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, struct _ns6__GetServiceCapabilitiesResponse2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, const struct _ns6__GetServiceCapabilitiesResponse2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__Capabilities2(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, const char *tag, int id, const struct _ns6__GetServiceCapabilitiesResponse2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns6:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns6:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__Capabilities2(soap, "ns6:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilitiesResponse2 * SOAP_FMAC4 soap_in__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, const char *tag, struct _ns6__GetServiceCapabilitiesResponse2 *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetServiceCapabilitiesResponse2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2, sizeof(struct _ns6__GetServiceCapabilitiesResponse2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetServiceCapabilitiesResponse2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Capabilities2(soap, "ns6:Capabilities", &a->Capabilities, "ns6:Capabilities2"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns6:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns6__GetServiceCapabilitiesResponse2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2, sizeof(struct _ns6__GetServiceCapabilitiesResponse2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilitiesResponse2 * SOAP_FMAC4 soap_new__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, int n)
{
	struct _ns6__GetServiceCapabilitiesResponse2 *p;
	struct _ns6__GetServiceCapabilitiesResponse2 *a = (struct _ns6__GetServiceCapabilitiesResponse2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetServiceCapabilitiesResponse2));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetServiceCapabilitiesResponse2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, const struct _ns6__GetServiceCapabilitiesResponse2 *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetServiceCapabilitiesResponse2(soap, tag ? tag : "ns6:GetServiceCapabilitiesResponse2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilitiesResponse2 * SOAP_FMAC4 soap_get__ns6__GetServiceCapabilitiesResponse2(struct soap *soap, struct _ns6__GetServiceCapabilitiesResponse2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetServiceCapabilitiesResponse2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns6__GetServiceCapabilities(struct soap *soap, struct _ns6__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__GetServiceCapabilities(struct soap *soap, const struct _ns6__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns6__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns6__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns6__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns6__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__GetServiceCapabilities, sizeof(struct _ns6__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns6__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__GetServiceCapabilities, SOAP_TYPE__ns6__GetServiceCapabilities, sizeof(struct _ns6__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns6__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns6__GetServiceCapabilities *p;
	struct _ns6__GetServiceCapabilities *a = (struct _ns6__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns6__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns6__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns6__GetServiceCapabilities(struct soap *soap, const struct _ns6__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns6__GetServiceCapabilities(soap, tag ? tag : "ns6:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns6__GetServiceCapabilities(struct soap *soap, struct _ns6__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__VideoSourceMode(struct soap *soap, struct ns6__VideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->MaxFramerate);
	a->MaxResolution = NULL;
	soap_default_ns6__EncodingTypes(soap, &a->Encodings);
	soap_default_xsd__boolean(soap, &a->Reboot);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Enabled = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__VideoSourceMode(struct soap *soap, const struct ns6__VideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaxFramerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &a->MaxResolution);
	soap_serialize_ns6__EncodingTypes(soap, (char*const*)&a->Encodings);
	soap_embedded(soap, &a->Reboot, SOAP_TYPE_xsd__boolean);
	soap_serialize_tt__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__VideoSourceMode(struct soap *soap, const char *tag, int id, const struct ns6__VideoSourceMode *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->Enabled)
		soap_set_attr(soap, "Enabled", soap_xsd__boolean2s(soap, *a->Enabled), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__VideoSourceMode), type))
		return soap->error;
	if (soap_out_float(soap, "ns6:MaxFramerate", -1, &a->MaxFramerate, ""))
		return soap->error;
	if (!a->MaxResolution)
	{	if (soap_element_nil(soap, "ns6:MaxResolution"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoResolution(soap, "ns6:MaxResolution", -1, &a->MaxResolution, ""))
		return soap->error;
	if (!a->Encodings)
	{	if (soap_element_nil(soap, "ns6:Encodings"))
			return soap->error;
	}
	else
	if (soap_out_ns6__EncodingTypes(soap, "ns6:Encodings", -1, (char*const*)&a->Encodings, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns6:Reboot", -1, &a->Reboot, ""))
		return soap->error;
	if (soap_out_tt__Description(soap, "ns6:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__VideoSourceMode * SOAP_FMAC4 soap_in_ns6__VideoSourceMode(struct soap *soap, const char *tag, struct ns6__VideoSourceMode *a, const char *type)
{
	size_t soap_flag_MaxFramerate = 1;
	size_t soap_flag_MaxResolution = 1;
	size_t soap_flag_Encodings = 1;
	size_t soap_flag_Reboot = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__VideoSourceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__VideoSourceMode, sizeof(struct ns6__VideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__VideoSourceMode(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Enabled", 0);
		if (t)
		{
			if (!(a->Enabled = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Enabled))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxFramerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "ns6:MaxFramerate", &a->MaxFramerate, "xsd:float"))
				{	soap_flag_MaxFramerate--;
					continue;
				}
			if (soap_flag_MaxResolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "ns6:MaxResolution", &a->MaxResolution, "tt:VideoResolution"))
				{	soap_flag_MaxResolution--;
					continue;
				}
			if (soap_flag_Encodings && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns6__EncodingTypes(soap, "ns6:Encodings", (char**)&a->Encodings, "ns6:EncodingTypes"))
				{	soap_flag_Encodings--;
					continue;
				}
			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns6:Reboot", &a->Reboot, "xsd:boolean"))
				{	soap_flag_Reboot--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "ns6:Description", (char**)&a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxFramerate > 0 || soap_flag_MaxResolution > 0 || soap_flag_Encodings > 0 || soap_flag_Reboot > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__VideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__VideoSourceMode, SOAP_TYPE_ns6__VideoSourceMode, sizeof(struct ns6__VideoSourceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__VideoSourceMode * SOAP_FMAC4 soap_new_ns6__VideoSourceMode(struct soap *soap, int n)
{
	struct ns6__VideoSourceMode *p;
	struct ns6__VideoSourceMode *a = (struct ns6__VideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__VideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default_ns6__VideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__VideoSourceMode(struct soap *soap, const struct ns6__VideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out_ns6__VideoSourceMode(soap, tag ? tag : "ns6:VideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__VideoSourceMode * SOAP_FMAC4 soap_get_ns6__VideoSourceMode(struct soap *soap, struct ns6__VideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__VideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__StartStopMulticastStreaming(struct soap *soap, struct ns6__StartStopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__StartStopMulticastStreaming(struct soap *soap, const struct ns6__StartStopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StartStopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct ns6__StartStopMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__StartStopMulticastStreaming), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "ns6:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__StartStopMulticastStreaming * SOAP_FMAC4 soap_in_ns6__StartStopMulticastStreaming(struct soap *soap, const char *tag, struct ns6__StartStopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__StartStopMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StartStopMulticastStreaming, sizeof(struct ns6__StartStopMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__StartStopMulticastStreaming(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__StartStopMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__StartStopMulticastStreaming, SOAP_TYPE_ns6__StartStopMulticastStreaming, sizeof(struct ns6__StartStopMulticastStreaming), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__StartStopMulticastStreaming * SOAP_FMAC4 soap_new_ns6__StartStopMulticastStreaming(struct soap *soap, int n)
{
	struct ns6__StartStopMulticastStreaming *p;
	struct ns6__StartStopMulticastStreaming *a = (struct ns6__StartStopMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__StartStopMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default_ns6__StartStopMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__StartStopMulticastStreaming(struct soap *soap, const struct ns6__StartStopMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out_ns6__StartStopMulticastStreaming(soap, tag ? tag : "ns6:StartStopMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__StartStopMulticastStreaming * SOAP_FMAC4 soap_get_ns6__StartStopMulticastStreaming(struct soap *soap, struct ns6__StartStopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StartStopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__EncoderInstanceInfo(struct soap *soap, struct ns6__EncoderInstanceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCodec = 0;
	a->Codec = NULL;
	soap_default_int(soap, &a->Total);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__EncoderInstanceInfo(struct soap *soap, const struct ns6__EncoderInstanceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Codec)
	{	int i;
		for (i = 0; i < (int)a->__sizeCodec; i++)
		{
			soap_embedded(soap, a->Codec + i, SOAP_TYPE_ns6__EncoderInstance);
			soap_serialize_ns6__EncoderInstance(soap, a->Codec + i);
		}
	}
	soap_embedded(soap, &a->Total, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncoderInstanceInfo(struct soap *soap, const char *tag, int id, const struct ns6__EncoderInstanceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EncoderInstanceInfo), type))
		return soap->error;
	if (a->Codec)
	{	int i;
		for (i = 0; i < (int)a->__sizeCodec; i++)
			if (soap_out_ns6__EncoderInstance(soap, "ns6:Codec", -1, a->Codec + i, ""))
				return soap->error;
	}
	if (soap_out_int(soap, "ns6:Total", -1, &a->Total, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__EncoderInstanceInfo * SOAP_FMAC4 soap_in_ns6__EncoderInstanceInfo(struct soap *soap, const char *tag, struct ns6__EncoderInstanceInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Codec = NULL;
	size_t soap_flag_Total = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__EncoderInstanceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EncoderInstanceInfo, sizeof(struct ns6__EncoderInstanceInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__EncoderInstanceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns6:Codec", 1, NULL))
			{	if (a->Codec == NULL)
				{	if (soap_blist_Codec == NULL)
						soap_blist_Codec = soap_alloc_block(soap);
					a->Codec = (struct ns6__EncoderInstance *)soap_push_block_max(soap, soap_blist_Codec, sizeof(struct ns6__EncoderInstance));
					if (a->Codec == NULL)
						return NULL;
					soap_default_ns6__EncoderInstance(soap, a->Codec);
				}
				soap_revert(soap);
				if (soap_in_ns6__EncoderInstance(soap, "ns6:Codec", a->Codec, "ns6:EncoderInstance"))
				{	a->__sizeCodec++;
					a->Codec = NULL;
					continue;
				}
			}
			if (soap_flag_Total && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns6:Total", &a->Total, "xsd:int"))
				{	soap_flag_Total--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Codec)
			soap_pop_block(soap, soap_blist_Codec);
		if (a->__sizeCodec)
		{	a->Codec = (struct ns6__EncoderInstance *)soap_save_block(soap, soap_blist_Codec, NULL, 1);
		}
		else
		{	a->Codec = NULL;
			if (soap_blist_Codec)
				soap_end_block(soap, soap_blist_Codec);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Total > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__EncoderInstanceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EncoderInstanceInfo, SOAP_TYPE_ns6__EncoderInstanceInfo, sizeof(struct ns6__EncoderInstanceInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__EncoderInstanceInfo * SOAP_FMAC4 soap_new_ns6__EncoderInstanceInfo(struct soap *soap, int n)
{
	struct ns6__EncoderInstanceInfo *p;
	struct ns6__EncoderInstanceInfo *a = (struct ns6__EncoderInstanceInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__EncoderInstanceInfo));
	for (p = a; p && n--; p++)
		soap_default_ns6__EncoderInstanceInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EncoderInstanceInfo(struct soap *soap, const struct ns6__EncoderInstanceInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns6__EncoderInstanceInfo(soap, tag ? tag : "ns6:EncoderInstanceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__EncoderInstanceInfo * SOAP_FMAC4 soap_get_ns6__EncoderInstanceInfo(struct soap *soap, struct ns6__EncoderInstanceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncoderInstanceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__EncoderInstance(struct soap *soap, struct ns6__EncoderInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Encoding);
	soap_default_int(soap, &a->Number);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__EncoderInstance(struct soap *soap, const struct ns6__EncoderInstance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_embedded(soap, &a->Number, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__EncoderInstance(struct soap *soap, const char *tag, int id, const struct ns6__EncoderInstance *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__EncoderInstance), type))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_nil(soap, "ns6:Encoding"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns6:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "ns6:Number", -1, &a->Number, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__EncoderInstance * SOAP_FMAC4 soap_in_ns6__EncoderInstance(struct soap *soap, const char *tag, struct ns6__EncoderInstance *a, const char *type)
{
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Number = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__EncoderInstance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__EncoderInstance, sizeof(struct ns6__EncoderInstance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__EncoderInstance(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Number && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns6:Number", &a->Number, "xsd:int"))
				{	soap_flag_Number--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_Number > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__EncoderInstance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__EncoderInstance, SOAP_TYPE_ns6__EncoderInstance, sizeof(struct ns6__EncoderInstance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__EncoderInstance * SOAP_FMAC4 soap_new_ns6__EncoderInstance(struct soap *soap, int n)
{
	struct ns6__EncoderInstance *p;
	struct ns6__EncoderInstance *a = (struct ns6__EncoderInstance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__EncoderInstance));
	for (p = a; p && n--; p++)
		soap_default_ns6__EncoderInstance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__EncoderInstance(struct soap *soap, const struct ns6__EncoderInstance *a, const char *tag, const char *type)
{
	if (soap_out_ns6__EncoderInstance(soap, tag ? tag : "ns6:EncoderInstance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__EncoderInstance * SOAP_FMAC4 soap_get_ns6__EncoderInstance(struct soap *soap, struct ns6__EncoderInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__EncoderInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__GetConfiguration(struct soap *soap, struct ns6__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__GetConfiguration(struct soap *soap, const struct ns6__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__GetConfiguration(struct soap *soap, const char *tag, int id, const struct ns6__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__GetConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "ns6:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "ns6:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__GetConfiguration * SOAP_FMAC4 soap_in_ns6__GetConfiguration(struct soap *soap, const char *tag, struct ns6__GetConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__GetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__GetConfiguration, sizeof(struct ns6__GetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__GetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__GetConfiguration, SOAP_TYPE_ns6__GetConfiguration, sizeof(struct ns6__GetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__GetConfiguration * SOAP_FMAC4 soap_new_ns6__GetConfiguration(struct soap *soap, int n)
{
	struct ns6__GetConfiguration *p;
	struct ns6__GetConfiguration *a = (struct ns6__GetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__GetConfiguration));
	for (p = a; p && n--; p++)
		soap_default_ns6__GetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__GetConfiguration(struct soap *soap, const struct ns6__GetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_ns6__GetConfiguration(soap, tag ? tag : "ns6:GetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__GetConfiguration * SOAP_FMAC4 soap_get_ns6__GetConfiguration(struct soap *soap, struct ns6__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__MediaProfile(struct soap *soap, struct ns6__MediaProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->Configurations = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->fixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__MediaProfile(struct soap *soap, const struct ns6__MediaProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTons6__ConfigurationSet(soap, &a->Configurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__MediaProfile(struct soap *soap, const char *tag, int id, const struct ns6__MediaProfile *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__boolean2s(soap, *a->fixed), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__MediaProfile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns6:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "ns6:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTons6__ConfigurationSet(soap, "ns6:Configurations", -1, &a->Configurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__MediaProfile * SOAP_FMAC4 soap_in_ns6__MediaProfile(struct soap *soap, const char *tag, struct ns6__MediaProfile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Configurations = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__MediaProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__MediaProfile, sizeof(struct ns6__MediaProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__MediaProfile(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			if (!(a->fixed = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "ns6:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Configurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ConfigurationSet(soap, "ns6:Configurations", &a->Configurations, "ns6:ConfigurationSet"))
				{	soap_flag_Configurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__MediaProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__MediaProfile, SOAP_TYPE_ns6__MediaProfile, sizeof(struct ns6__MediaProfile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__MediaProfile * SOAP_FMAC4 soap_new_ns6__MediaProfile(struct soap *soap, int n)
{
	struct ns6__MediaProfile *p;
	struct ns6__MediaProfile *a = (struct ns6__MediaProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__MediaProfile));
	for (p = a; p && n--; p++)
		soap_default_ns6__MediaProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__MediaProfile(struct soap *soap, const struct ns6__MediaProfile *a, const char *tag, const char *type)
{
	if (soap_out_ns6__MediaProfile(soap, tag ? tag : "ns6:MediaProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__MediaProfile * SOAP_FMAC4 soap_get_ns6__MediaProfile(struct soap *soap, struct ns6__MediaProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__MediaProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Encoding);
	a->Multicast = NULL;
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoder2Configuration(struct soap *soap, const struct tt__AudioEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoder2Configuration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoder2Configuration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_nil(soap, "tt:Encoding"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->SampleRate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_in_tt__AudioEncoder2Configuration(struct soap *soap, const char *tag, struct tt__AudioEncoder2Configuration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoder2Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoder2Configuration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SampleRate", &a->SampleRate, "xsd:int"))
				{	soap_flag_SampleRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AudioEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoder2Configuration, SOAP_TYPE_tt__AudioEncoder2Configuration, sizeof(struct tt__AudioEncoder2Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_new_tt__AudioEncoder2Configuration(struct soap *soap, int n)
{
	struct tt__AudioEncoder2Configuration *p;
	struct tt__AudioEncoder2Configuration *a = (struct tt__AudioEncoder2Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioEncoder2Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoder2Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoder2Configuration(struct soap *soap, const struct tt__AudioEncoder2Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoder2Configuration(soap, tag ? tag : "tt:AudioEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoder2Configuration * SOAP_FMAC4 soap_get_tt__AudioEncoder2Configuration(struct soap *soap, struct tt__AudioEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Encoding);
	a->Resolution = NULL;
	a->RateControl = NULL;
	a->Multicast = NULL;
	soap_default_float(soap, &a->Quality);
	a->GovLength = NULL;
	soap_default_string(soap, &a->Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoder2Configuration(struct soap *soap, const struct tt__VideoEncoder2Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&a->Encoding);
	soap_serialize_PointerTott__VideoResolution2(soap, &a->Resolution);
	soap_serialize_PointerTott__VideoRateControl2(soap, &a->RateControl);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoder2Configuration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->GovLength)
		soap_set_attr(soap, "GovLength", soap_int2s(soap, *a->GovLength), 1);
	if (a->Profile)
		soap_set_attr(soap, "Profile", soap_string2s(soap, a->Profile), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoder2Configuration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->Encoding)
	{	if (soap_element_nil(soap, "tt:Encoding"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Encoding", -1, (char*const*)&a->Encoding, ""))
		return soap->error;
	if (!a->Resolution)
	{	if (soap_element_nil(soap, "tt:Resolution"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoResolution2(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl2(soap, "tt:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_in_tt__VideoEncoder2Configuration(struct soap *soap, const char *tag, struct tt__VideoEncoder2Configuration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Quality = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoder2Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoder2Configuration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "GovLength", 0);
		if (t)
		{
			if (!(a->GovLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->GovLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Profile", 0), &a->Profile))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Encoding", (char**)&a->Encoding, "xsd:string"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution2(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution2"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoRateControl2(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl2"))
				{	soap_flag_RateControl--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Resolution > 0 || soap_flag_Quality > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoEncoder2Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoder2Configuration, SOAP_TYPE_tt__VideoEncoder2Configuration, sizeof(struct tt__VideoEncoder2Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_new_tt__VideoEncoder2Configuration(struct soap *soap, int n)
{
	struct tt__VideoEncoder2Configuration *p;
	struct tt__VideoEncoder2Configuration *a = (struct tt__VideoEncoder2Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoEncoder2Configuration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoder2Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoder2Configuration(struct soap *soap, const struct tt__VideoEncoder2Configuration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoder2Configuration(soap, tag ? tag : "tt:VideoEncoder2Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoder2Configuration * SOAP_FMAC4 soap_get_tt__VideoEncoder2Configuration(struct soap *soap, struct tt__VideoEncoder2Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoder2Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ConfigurationSet(struct soap *soap, struct ns6__ConfigurationSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoSource = NULL;
	a->AudioSource = NULL;
	a->VideoEncoder = NULL;
	a->AudioEncoder = NULL;
	a->Analytics = NULL;
	a->PTZ = NULL;
	a->Metadata = NULL;
	a->AudioOutput = NULL;
	a->AudioDecoder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__ConfigurationSet(struct soap *soap, const struct ns6__ConfigurationSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->VideoSource);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->AudioSource);
	soap_serialize_PointerTott__VideoEncoder2Configuration(soap, &a->VideoEncoder);
	soap_serialize_PointerTott__AudioEncoder2Configuration(soap, &a->AudioEncoder);
	soap_serialize_PointerTott__ConfigurationEntity(soap, &a->Analytics);
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZ);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &a->Metadata);
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->AudioOutput);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->AudioDecoder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ConfigurationSet(struct soap *soap, const char *tag, int id, const struct ns6__ConfigurationSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ConfigurationSet), type))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "ns6:VideoSource", -1, &a->VideoSource, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "ns6:AudioSource", -1, &a->AudioSource, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoder2Configuration(soap, "ns6:VideoEncoder", -1, &a->VideoEncoder, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoder2Configuration(soap, "ns6:AudioEncoder", -1, &a->AudioEncoder, ""))
		return soap->error;
	if (soap_out_PointerTott__ConfigurationEntity(soap, "ns6:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "ns6:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "ns6:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "ns6:AudioOutput", -1, &a->AudioOutput, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "ns6:AudioDecoder", -1, &a->AudioDecoder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__ConfigurationSet * SOAP_FMAC4 soap_in_ns6__ConfigurationSet(struct soap *soap, const char *tag, struct ns6__ConfigurationSet *a, const char *type)
{
	size_t soap_flag_VideoSource = 1;
	size_t soap_flag_AudioSource = 1;
	size_t soap_flag_VideoEncoder = 1;
	size_t soap_flag_AudioEncoder = 1;
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Metadata = 1;
	size_t soap_flag_AudioOutput = 1;
	size_t soap_flag_AudioDecoder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__ConfigurationSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ConfigurationSet, sizeof(struct ns6__ConfigurationSet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__ConfigurationSet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "ns6:VideoSource", &a->VideoSource, "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSource--;
					continue;
				}
			if (soap_flag_AudioSource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "ns6:AudioSource", &a->AudioSource, "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSource--;
					continue;
				}
			if (soap_flag_VideoEncoder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoder2Configuration(soap, "ns6:VideoEncoder", &a->VideoEncoder, "tt:VideoEncoder2Configuration"))
				{	soap_flag_VideoEncoder--;
					continue;
				}
			if (soap_flag_AudioEncoder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoder2Configuration(soap, "ns6:AudioEncoder", &a->AudioEncoder, "tt:AudioEncoder2Configuration"))
				{	soap_flag_AudioEncoder--;
					continue;
				}
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ConfigurationEntity(soap, "ns6:Analytics", &a->Analytics, "tt:ConfigurationEntity"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "ns6:PTZ", &a->PTZ, "tt:PTZConfiguration"))
				{	soap_flag_PTZ--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "ns6:Metadata", &a->Metadata, "tt:MetadataConfiguration"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap_flag_AudioOutput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "ns6:AudioOutput", &a->AudioOutput, "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutput--;
					continue;
				}
			if (soap_flag_AudioDecoder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "ns6:AudioDecoder", &a->AudioDecoder, "tt:AudioDecoderConfiguration"))
				{	soap_flag_AudioDecoder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__ConfigurationSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ConfigurationSet, SOAP_TYPE_ns6__ConfigurationSet, sizeof(struct ns6__ConfigurationSet), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__ConfigurationSet * SOAP_FMAC4 soap_new_ns6__ConfigurationSet(struct soap *soap, int n)
{
	struct ns6__ConfigurationSet *p;
	struct ns6__ConfigurationSet *a = (struct ns6__ConfigurationSet*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__ConfigurationSet));
	for (p = a; p && n--; p++)
		soap_default_ns6__ConfigurationSet(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ConfigurationSet(struct soap *soap, const struct ns6__ConfigurationSet *a, const char *tag, const char *type)
{
	if (soap_out_ns6__ConfigurationSet(soap, tag ? tag : "ns6:ConfigurationSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ConfigurationSet * SOAP_FMAC4 soap_get_ns6__ConfigurationSet(struct soap *soap, struct ns6__ConfigurationSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ConfigurationSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
