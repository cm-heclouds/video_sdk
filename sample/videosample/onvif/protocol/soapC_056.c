/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		soap_serialize__tds__GetSystemLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, struct _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemLog **)soap_malloc(soap, sizeof(struct _tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackupResponse))
		soap_serialize__tds__GetSystemBackupResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemBackupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackupResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemBackupResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemBackupResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemBackupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemBackupResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemBackupResponse(soap, tag ? tag : "tds:GetSystemBackupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		soap_serialize__tds__GetSystemBackup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, struct _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemBackup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemBackup **)soap_malloc(soap, sizeof(struct _tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemBackup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystemResponse))
		soap_serialize__tds__RestoreSystemResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, struct _tds__RestoreSystemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystemResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RestoreSystemResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, struct _tds__RestoreSystemResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RestoreSystemResponse **)soap_malloc(soap, sizeof(struct _tds__RestoreSystemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RestoreSystemResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RestoreSystemResponse(soap, tag ? tag : "tds:RestoreSystemResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		soap_serialize__tds__RestoreSystem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, struct _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RestoreSystem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, struct _tds__RestoreSystem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RestoreSystem **)soap_malloc(soap, sizeof(struct _tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RestoreSystem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemRebootResponse))
		soap_serialize__tds__SystemRebootResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, struct _tds__SystemRebootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemRebootResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemRebootResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemRebootResponse **)soap_malloc(soap, sizeof(struct _tds__SystemRebootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemRebootResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		soap_serialize__tds__SystemReboot(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, struct _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemReboot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemReboot **)soap_malloc(soap, sizeof(struct _tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemReboot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse))
		soap_serialize__tds__UpgradeSystemFirmwareResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, struct _tds__UpgradeSystemFirmwareResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmwareResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_malloc(soap, sizeof(struct _tds__UpgradeSystemFirmwareResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag ? tag : "tds:UpgradeSystemFirmwareResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		soap_serialize__tds__UpgradeSystemFirmware(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, struct _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UpgradeSystemFirmware(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmware **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(struct _tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UpgradeSystemFirmware(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse))
		soap_serialize__tds__SetSystemFactoryDefaultResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag ? tag : "tds:SetSystemFactoryDefaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		soap_serialize__tds__SetSystemFactoryDefault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse))
		soap_serialize__tds__GetSystemDateAndTimeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag ? tag : "tds:GetSystemDateAndTimeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		soap_serialize__tds__GetSystemDateAndTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse))
		soap_serialize__tds__SetSystemDateAndTimeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag ? tag : "tds:SetSystemDateAndTimeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		soap_serialize__tds__SetSystemDateAndTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformationResponse))
		soap_serialize__tds__GetDeviceInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		soap_serialize__tds__GetDeviceInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformation **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse))
		soap_serialize__tds__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		soap_serialize__tds__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServicesResponse))
		soap_serialize__tds__GetServicesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServicesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServicesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServicesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServicesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServicesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServicesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		soap_serialize__tds__GetServices(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, struct _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServices(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServices **)soap_malloc(soap, sizeof(struct _tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServices(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse))
		soap_serialize__tan__ModifyAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__ModifyAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__ModifyAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag ? tag : "tan:ModifyAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyAnalyticsModules))
		soap_serialize__tan__ModifyAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__ModifyAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyAnalyticsModules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__ModifyAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, tag ? tag : "tan:ModifyAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetAnalyticsModulesResponse))
		soap_serialize__tan__GetAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetAnalyticsModulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag ? tag : "tan:GetAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetAnalyticsModules))
		soap_serialize__tan__GetAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__GetAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetAnalyticsModules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__GetAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetAnalyticsModules(soap, tag ? tag : "tan:GetAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse))
		soap_serialize__tan__DeleteAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__DeleteAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__DeleteAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag ? tag : "tan:DeleteAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteAnalyticsModules))
		soap_serialize__tan__DeleteAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__DeleteAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteAnalyticsModules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__DeleteAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, tag ? tag : "tan:DeleteAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse))
		soap_serialize__tan__CreateAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__CreateAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__CreateAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag ? tag : "tan:CreateAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateAnalyticsModules))
		soap_serialize__tan__CreateAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__CreateAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateAnalyticsModules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__CreateAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__CreateAnalyticsModules(soap, tag ? tag : "tan:CreateAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse))
		soap_serialize__tan__GetSupportedAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedAnalyticsModulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag ? tag : "tan:GetSupportedAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedAnalyticsModules))
		soap_serialize__tan__GetSupportedAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedAnalyticsModules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetSupportedAnalyticsModules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__GetSupportedAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag ? tag : "tan:GetSupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse))
		soap_serialize__tan__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tan__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tan__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetServiceCapabilitiesResponse(soap, tag ? tag : "tan:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetServiceCapabilities))
		soap_serialize__tan__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tan__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tan__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tan__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tan__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetServiceCapabilities(soap, tag ? tag : "tan:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyRulesResponse))
		soap_serialize__tan__ModifyRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__ModifyRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyRulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyRulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyRulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyRulesResponse **)soap_malloc(soap, sizeof(struct _tan__ModifyRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__ModifyRulesResponse(soap, tag ? tag : "tan:ModifyRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyRules))
		soap_serialize__tan__ModifyRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyRules(struct soap *soap, const char *tag, int id, struct _tan__ModifyRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyRules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyRules ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyRules(struct soap *soap, const char *tag, struct _tan__ModifyRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyRules **)soap_malloc(soap, sizeof(struct _tan__ModifyRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__ModifyRules(soap, tag ? tag : "tan:ModifyRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyRules ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetRulesResponse))
		soap_serialize__tan__GetRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetRulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetRulesResponse(struct soap *soap, const char *tag, struct _tan__GetRulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetRulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetRulesResponse(soap, tag ? tag : "tan:GetRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetRules(struct soap *soap, struct _tan__GetRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetRules))
		soap_serialize__tan__GetRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetRules(struct soap *soap, const char *tag, int id, struct _tan__GetRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetRules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetRules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetRules(struct soap *soap, const char *tag, struct _tan__GetRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetRules **)soap_malloc(soap, sizeof(struct _tan__GetRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetRules(struct soap *soap, struct _tan__GetRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetRules(soap, tag ? tag : "tan:GetRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetRules(struct soap *soap, struct _tan__GetRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteRulesResponse))
		soap_serialize__tan__DeleteRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__DeleteRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteRulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteRulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteRulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteRulesResponse **)soap_malloc(soap, sizeof(struct _tan__DeleteRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__DeleteRulesResponse(soap, tag ? tag : "tan:DeleteRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteRules))
		soap_serialize__tan__DeleteRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteRules(struct soap *soap, const char *tag, int id, struct _tan__DeleteRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteRules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteRules ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteRules(struct soap *soap, const char *tag, struct _tan__DeleteRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteRules **)soap_malloc(soap, sizeof(struct _tan__DeleteRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__DeleteRules(soap, tag ? tag : "tan:DeleteRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteRules ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateRulesResponse))
		soap_serialize__tan__CreateRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__CreateRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateRulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateRulesResponse(struct soap *soap, const char *tag, struct _tan__CreateRulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateRulesResponse **)soap_malloc(soap, sizeof(struct _tan__CreateRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__CreateRulesResponse(soap, tag ? tag : "tan:CreateRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateRules(struct soap *soap, struct _tan__CreateRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateRules))
		soap_serialize__tan__CreateRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateRules(struct soap *soap, const char *tag, int id, struct _tan__CreateRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateRules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateRules ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateRules(struct soap *soap, const char *tag, struct _tan__CreateRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateRules **)soap_malloc(soap, sizeof(struct _tan__CreateRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateRules(struct soap *soap, struct _tan__CreateRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__CreateRules(soap, tag ? tag : "tan:CreateRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateRules ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateRules(struct soap *soap, struct _tan__CreateRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedRulesResponse))
		soap_serialize__tan__GetSupportedRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedRulesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedRulesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedRulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetSupportedRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetSupportedRulesResponse(soap, tag ? tag : "tan:GetSupportedRulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedRules))
		soap_serialize__tan__GetSupportedRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedRules(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedRules, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedRules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedRules(struct soap *soap, const char *tag, struct _tan__GetSupportedRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedRules **)soap_malloc(soap, sizeof(struct _tan__GetSupportedRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tan__GetSupportedRules(soap, tag ? tag : "tan:GetSupportedRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedRules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsStateResponse))
		soap_serialize__tad__GetAnalyticsStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsStateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsStateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsStateResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__GetAnalyticsStateResponse(soap, tag ? tag : "tad:GetAnalyticsStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsState))
		soap_serialize__tad__GetAnalyticsState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsState(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsState(struct soap *soap, const char *tag, struct _tad__GetAnalyticsState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsState **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__GetAnalyticsState(soap, tag ? tag : "tad:GetAnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse))
		soap_serialize__tad__DeleteAnalyticsEngineInputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, struct _tad__DeleteAnalyticsEngineInputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__DeleteAnalyticsEngineInputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__DeleteAnalyticsEngineInputsResponse **)soap_malloc(soap, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__DeleteAnalyticsEngineInputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:DeleteAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs))
		soap_serialize__tad__DeleteAnalyticsEngineInputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, struct _tad__DeleteAnalyticsEngineInputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__DeleteAnalyticsEngineInputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs ** SOAP_FMAC4 soap_in_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__DeleteAnalyticsEngineInputs **)soap_malloc(soap, sizeof(struct _tad__DeleteAnalyticsEngineInputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__DeleteAnalyticsEngineInputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, tag ? tag : "tad:DeleteAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs ** SOAP_FMAC4 soap_get_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse))
		soap_serialize__tad__CreateAnalyticsEngineInputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, struct _tad__CreateAnalyticsEngineInputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__CreateAnalyticsEngineInputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__CreateAnalyticsEngineInputsResponse **)soap_malloc(soap, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__CreateAnalyticsEngineInputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:CreateAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__CreateAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs))
		soap_serialize__tad__CreateAnalyticsEngineInputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, struct _tad__CreateAnalyticsEngineInputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__CreateAnalyticsEngineInputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs ** SOAP_FMAC4 soap_in_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__CreateAnalyticsEngineInputs **)soap_malloc(soap, sizeof(struct _tad__CreateAnalyticsEngineInputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__CreateAnalyticsEngineInputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineInputs(soap, tag ? tag : "tad:CreateAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs ** SOAP_FMAC4 soap_get_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__CreateAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse))
		soap_serialize__tad__GetVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tad__GetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(soap, tag ? tag : "tad:GetVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
