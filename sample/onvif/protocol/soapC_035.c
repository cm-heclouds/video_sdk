/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourTypeExtension(struct soap *soap, const struct tt__PTZPresetTourTypeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourTypeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourTypeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourTypeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourTypeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourTypeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourTypeExtension, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourTypeExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourTypeExtension *p;
	struct tt__PTZPresetTourTypeExtension *a = (struct tt__PTZPresetTourTypeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourTypeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourTypeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourTypeExtension(struct soap *soap, const struct tt__PTZPresetTourTypeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourTypeExtension(soap, tag ? tag : "tt:PTZPresetTourTypeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSpotExtension(struct soap *soap, const struct tt__PTZPresetTourSpotExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSpotExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourSpotExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSpotExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotExtension, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourSpotExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSpotExtension *p;
	struct tt__PTZPresetTourSpotExtension *a = (struct tt__PTZPresetTourSpotExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSpotExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSpotExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSpotExtension(struct soap *soap, const struct tt__PTZPresetTourSpotExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSpotExtension(soap, tag ? tag : "tt:PTZPresetTourSpotExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PTZPresetTourPresetDetail = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourPresetDetail(struct soap *soap, const struct tt__PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_PTZPresetTourPresetDetail(soap, a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourPresetDetail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail), type))
		return soap->error;
	if (soap_out__tt__union_PTZPresetTourPresetDetail(soap, a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourPresetDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourPresetDetail(soap, a);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__tt__union_PTZPresetTourPresetDetail(soap, &a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetail, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_new_tt__PTZPresetTourPresetDetail(struct soap *soap, int n)
{
	struct tt__PTZPresetTourPresetDetail *p;
	struct tt__PTZPresetTourPresetDetail *a = (struct tt__PTZPresetTourPresetDetail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourPresetDetail));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourPresetDetail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourPresetDetail(struct soap *soap, const struct tt__PTZPresetTourPresetDetail *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourPresetDetail(soap, tag ? tag : "tt:PTZPresetTourPresetDetail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourExtension(struct soap *soap, const struct tt__PTZPresetTourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourExtension, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourExtension *p;
	struct tt__PTZPresetTourExtension *a = (struct tt__PTZPresetTourExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourExtension(struct soap *soap, const struct tt__PTZPresetTourExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourExtension(soap, tag ? tag : "tt:PTZPresetTourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PresetDetail = NULL;
	a->Speed = NULL;
	a->StayTime = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSpot(struct soap *soap, const struct tt__PTZPresetTourSpot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetail(soap, &a->PresetDetail);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
	soap_serialize_PointerToxsd__duration(soap, &a->StayTime);
	soap_serialize_PointerTott__PTZPresetTourSpotExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSpot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpot), type))
		return soap->error;
	if (!a->PresetDetail)
	{	if (soap_element_nil(soap, "tt:PresetDetail"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", -1, &a->PresetDetail, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:StayTime", -1, &a->StayTime, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpot *a, const char *type)
{
	size_t soap_flag_PresetDetail = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_StayTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourSpot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSpot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", &a->PresetDetail, "tt:PTZPresetTourPresetDetail"))
				{	soap_flag_PresetDetail--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tt:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap_flag_StayTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tt:StayTime", &a->StayTime, "xsd:duration"))
				{	soap_flag_StayTime--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourSpotExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetDetail > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot * SOAP_FMAC4 soap_new_tt__PTZPresetTourSpot(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSpot *p;
	struct tt__PTZPresetTourSpot *a = (struct tt__PTZPresetTourSpot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSpot));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSpot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSpot(struct soap *soap, const struct tt__PTZPresetTourSpot *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSpot(soap, tag ? tag : "tt:PTZPresetTourSpot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecurringTime = NULL;
	a->RecurringDuration = NULL;
	a->Direction = NULL;
	a->Extension = NULL;
	a->RandomPresetOrder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStartingCondition(struct soap *soap, const struct tt__PTZPresetTourStartingCondition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->RecurringTime);
	soap_serialize_PointerToxsd__duration(soap, &a->RecurringDuration);
	soap_serialize_PointerTott__PTZPresetTourDirection(soap, &a->Direction);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStartingCondition *a, const char *type)
{
	if (a->RandomPresetOrder)
		soap_set_attr(soap, "RandomPresetOrder", soap_xsd__boolean2s(soap, *a->RandomPresetOrder), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RecurringTime", -1, &a->RecurringTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:RecurringDuration", -1, &a->RecurringDuration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", -1, &a->Direction, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingCondition *a, const char *type)
{
	size_t soap_flag_RecurringTime = 1;
	size_t soap_flag_RecurringDuration = 1;
	size_t soap_flag_Direction = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourStartingCondition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStartingCondition(soap, a);
	{	const char *t = soap_attr_value(soap, "RandomPresetOrder", 0);
		if (t)
		{
			if (!(a->RandomPresetOrder = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RandomPresetOrder))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:RecurringTime", &a->RecurringTime, "xsd:int"))
				{	soap_flag_RecurringTime--;
					continue;
				}
			if (soap_flag_RecurringDuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tt:RecurringDuration", &a->RecurringDuration, "xsd:duration"))
				{	soap_flag_RecurringDuration--;
					continue;
				}
			if (soap_flag_Direction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", &a->Direction, "tt:PTZPresetTourDirection"))
				{	soap_flag_Direction--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourStartingConditionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingCondition, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_new_tt__PTZPresetTourStartingCondition(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStartingCondition *p;
	struct tt__PTZPresetTourStartingCondition *a = (struct tt__PTZPresetTourStartingCondition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStartingCondition));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStartingCondition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStartingCondition(struct soap *soap, const struct tt__PTZPresetTourStartingCondition *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStartingCondition(soap, tag ? tag : "tt:PTZPresetTourStartingCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__PTZPresetTourState(soap, &a->State);
	a->CurrentTourSpot = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourStatus(struct soap *soap, const struct tt__PTZPresetTourStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSpot(soap, &a->CurrentTourSpot);
	soap_serialize_PointerTott__PTZPresetTourStatusExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatus), type))
		return soap->error;
	if (soap_out_tt__PTZPresetTourState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", -1, &a->CurrentTourSpot, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatus *a, const char *type)
{
	size_t soap_flag_State = 1;
	size_t soap_flag_CurrentTourSpot = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__PTZPresetTourState(soap, "tt:State", &a->State, "tt:PTZPresetTourState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap_flag_CurrentTourSpot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", &a->CurrentTourSpot, "tt:PTZPresetTourSpot"))
				{	soap_flag_CurrentTourSpot--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourStatusExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatus, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus * SOAP_FMAC4 soap_new_tt__PTZPresetTourStatus(struct soap *soap, int n)
{
	struct tt__PTZPresetTourStatus *p;
	struct tt__PTZPresetTourStatus *a = (struct tt__PTZPresetTourStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourStatus(struct soap *soap, const struct tt__PTZPresetTourStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourStatus(soap, tag ? tag : "tt:PTZPresetTourStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PresetTour(struct soap *soap, struct tt__PresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->Status = NULL;
	soap_default_xsd__boolean(soap, &a->AutoStart);
	a->StartingCondition = NULL;
	a->__sizeTourSpot = 0;
	a->TourSpot = NULL;
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PresetTour(struct soap *soap, const struct tt__PresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZPresetTourStatus(soap, &a->Status);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__PTZPresetTourStartingCondition(soap, &a->StartingCondition);
	if (a->TourSpot)
	{	int i;
		for (i = 0; i < (int)a->__sizeTourSpot; i++)
		{
			soap_embedded(soap, a->TourSpot + i, SOAP_TYPE_tt__PTZPresetTourSpot);
			soap_serialize_tt__PTZPresetTourSpot(soap, a->TourSpot + i);
		}
	}
	soap_serialize_PointerTott__PTZPresetTourExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PresetTour(struct soap *soap, const char *tag, int id, const struct tt__PresetTour *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PresetTour), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->Status)
	{	if (soap_element_nil(soap, "tt:Status"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZPresetTourStatus(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	if (!a->StartingCondition)
	{	if (soap_element_nil(soap, "tt:StartingCondition"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", -1, &a->StartingCondition, ""))
		return soap->error;
	if (a->TourSpot)
	{	int i;
		for (i = 0; i < (int)a->__sizeTourSpot; i++)
			if (soap_out_tt__PTZPresetTourSpot(soap, "tt:TourSpot", -1, a->TourSpot + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PresetTour * SOAP_FMAC4 soap_in_tt__PresetTour(struct soap *soap, const char *tag, struct tt__PresetTour *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Status = 1;
	size_t soap_flag_AutoStart = 1;
	size_t soap_flag_StartingCondition = 1;
	struct soap_blist *soap_blist_TourSpot = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PresetTour(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 0), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourStatus(soap, "tt:Status", &a->Status, "tt:PTZPresetTourStatus"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			if (soap_flag_StartingCondition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", &a->StartingCondition, "tt:PTZPresetTourStartingCondition"))
				{	soap_flag_StartingCondition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TourSpot", 1, NULL))
			{	if (a->TourSpot == NULL)
				{	if (soap_blist_TourSpot == NULL)
						soap_blist_TourSpot = soap_alloc_block(soap);
					a->TourSpot = (struct tt__PTZPresetTourSpot *)soap_push_block_max(soap, soap_blist_TourSpot, sizeof(struct tt__PTZPresetTourSpot));
					if (a->TourSpot == NULL)
						return NULL;
					soap_default_tt__PTZPresetTourSpot(soap, a->TourSpot);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPresetTourSpot(soap, "tt:TourSpot", a->TourSpot, "tt:PTZPresetTourSpot"))
				{	a->__sizeTourSpot++;
					a->TourSpot = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TourSpot)
			soap_pop_block(soap, soap_blist_TourSpot);
		if (a->__sizeTourSpot)
		{	a->TourSpot = (struct tt__PTZPresetTourSpot *)soap_save_block(soap, soap_blist_TourSpot, NULL, 1);
		}
		else
		{	a->TourSpot = NULL;
			if (soap_blist_TourSpot)
				soap_end_block(soap, soap_blist_TourSpot);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_AutoStart > 0 || soap_flag_StartingCondition > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PresetTour, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PresetTour * SOAP_FMAC4 soap_new_tt__PresetTour(struct soap *soap, int n)
{
	struct tt__PresetTour *p;
	struct tt__PresetTour *a = (struct tt__PresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PresetTour));
	for (p = a; p && n--; p++)
		soap_default_tt__PresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PresetTour(struct soap *soap, const struct tt__PresetTour *a, const char *tag, const char *type)
{
	if (soap_out_tt__PresetTour(soap, tag ? tag : "tt:PresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PresetTour * SOAP_FMAC4 soap_get_tt__PresetTour(struct soap *soap, struct tt__PresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->PTZPosition = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const struct tt__PTZPreset *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, struct tt__PTZPreset *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_PTZPosition = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPreset(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 0), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_PTZPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
				{	soap_flag_PTZPosition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_new_tt__PTZPreset(struct soap *soap, int n)
{
	struct tt__PTZPreset *p;
	struct tt__PTZPreset *a = (struct tt__PTZPreset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPreset));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPreset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveStatus(soap, &a->PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZMoveStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZMoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZMoveStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &a->PanTilt, "tt:MoveStatus"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &a->Zoom, "tt:MoveStatus"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_new_tt__PTZMoveStatus(struct soap *soap, int n)
{
	struct tt__PTZMoveStatus *p;
	struct tt__PTZMoveStatus *a = (struct tt__PTZMoveStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZMoveStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZMoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatus(struct soap *soap, struct tt__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->MoveStatus = NULL;
	soap_default_string(soap, &a->Error);
	soap_default_dateTime(soap, &a->UtcTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatus(struct soap *soap, const struct tt__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
	soap_serialize_PointerTott__PTZMoveStatus(soap, &a->MoveStatus);
	soap_serialize_string(soap, (char*const*)&a->Error);
	soap_embedded(soap, &a->UtcTime, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, (char*const*)&a->Error, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_in_tt__PTZStatus(struct soap *soap, const char *tag, struct tt__PTZStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_UtcTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:PTZMoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", (char**)&a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_new_tt__PTZStatus(struct soap *soap, int n)
{
	struct tt__PTZStatus *p;
	struct tt__PTZStatus *a = (struct tt__PTZStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatus(struct soap *soap, const struct tt__PTZStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_get_tt__PTZStatus(struct soap *soap, struct tt__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const struct tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZSpeed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpeed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_new_tt__PTZSpeed(struct soap *soap, int n)
{
	struct tt__PTZSpeed *p;
	struct tt__PTZSpeed *a = (struct tt__PTZSpeed*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpeed));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpeed(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZVector(struct soap *soap, struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const struct tt__PTZVector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZVector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZVector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_new_tt__PTZVector(struct soap *soap, int n)
{
	struct tt__PTZVector *p;
	struct tt__PTZVector *a = (struct tt__PTZVector*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZVector));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZVector(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, struct tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector1D(struct soap *soap, struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const struct tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	if (a->space)
		soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, a->space), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Vector1D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector1D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "space", 0), &a->space))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_new_tt__Vector1D(struct soap *soap, int n)
{
	struct tt__Vector1D *p;
	struct tt__Vector1D *a = (struct tt__Vector1D*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector1D));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector1D(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, struct tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector2D(struct soap *soap, struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_float(soap, &a->y);
	soap_default_xsd__anyURI(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const struct tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, a->y), 1);
	if (a->space)
		soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, a->space), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Vector2D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector2D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 1), &a->y))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "space", 0), &a->space))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_new_tt__Vector2D(struct soap *soap, int n)
{
	struct tt__Vector2D *p;
	struct tt__Vector2D *a = (struct tt__Vector2D*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector2D));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector2D(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, struct tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpacesExtension(struct soap *soap, const struct tt__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZSpacesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpacesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_in_tt__PTZSpacesExtension(struct soap *soap, const char *tag, struct tt__PTZSpacesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZSpacesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpacesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_new_tt__PTZSpacesExtension(struct soap *soap, int n)
{
	struct tt__PTZSpacesExtension *p;
	struct tt__PTZSpacesExtension *a = (struct tt__PTZSpacesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpacesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpacesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpacesExtension(struct soap *soap, const struct tt__PTZSpacesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpacesExtension(soap, tag ? tag : "tt:PTZSpacesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_get_tt__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (!a->URI)
	{	if (soap_element_nil(soap, "tt:URI"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, (char*const*)&a->URI, ""))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_nil(soap, "tt:XRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Space1DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space1DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:URI", (char**)&a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_new_tt__Space1DDescription(struct soap *soap, int n)
{
	struct tt__Space1DDescription *p;
	struct tt__Space1DDescription *a = (struct tt__Space1DDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Space1DDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__Space1DDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &a->Range);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const struct tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (!a->Range)
	{	if (soap_element_nil(soap, "tt:Range"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ZoomLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ZoomLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->Range, "tt:Space1DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_new_tt__ZoomLimits(struct soap *soap, int n)
{
	struct tt__ZoomLimits *p;
	struct tt__ZoomLimits *a = (struct tt__ZoomLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ZoomLimits));
	for (p = a; p && n--; p++)
		soap_default_tt__ZoomLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a, const char *tag, const char *type)
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->URI);
	a->XRange = NULL;
	a->YRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
	soap_serialize_PointerTott__FloatRange(soap, &a->YRange);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (!a->URI)
	{	if (soap_element_nil(soap, "tt:URI"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, (char*const*)&a->URI, ""))
		return soap->error;
	if (!a->XRange)
	{	if (soap_element_nil(soap, "tt:XRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
		return soap->error;
	if (!a->YRange)
	{	if (soap_element_nil(soap, "tt:YRange"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->YRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Space2DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space2DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:URI", (char**)&a->URI, "xsd:anyURI"))
				{	soap_flag_URI--;
					continue;
				}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->YRange, "tt:FloatRange"))
				{	soap_flag_YRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0 || soap_flag_YRange > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_new_tt__Space2DDescription(struct soap *soap, int n)
{
	struct tt__Space2DDescription *p;
	struct tt__Space2DDescription *a = (struct tt__Space2DDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Space2DDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__Space2DDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &a->Range);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const struct tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (!a->Range)
	{	if (soap_element_nil(soap, "tt:Range"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PanTiltLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PanTiltLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->Range, "tt:Space2DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_new_tt__PanTiltLimits(struct soap *soap, int n)
{
	struct tt__PanTiltLimits *p;
	struct tt__PanTiltLimits *a = (struct tt__PanTiltLimits*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PanTiltLimits));
	for (p = a; p && n--; p++)
		soap_default_tt__PanTiltLimits(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a, const char *tag, const char *type)
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReverseOptionsExtension(struct soap *soap, const struct tt__ReverseOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__ReverseOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension * SOAP_FMAC4 soap_in_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, struct tt__ReverseOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReverseOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReverseOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptionsExtension, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension * SOAP_FMAC4 soap_new_tt__ReverseOptionsExtension(struct soap *soap, int n)
{
	struct tt__ReverseOptionsExtension *p;
	struct tt__ReverseOptionsExtension *a = (struct tt__ReverseOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReverseOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ReverseOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseOptionsExtension(struct soap *soap, const struct tt__ReverseOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseOptionsExtension(soap, tag ? tag : "tt:ReverseOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension * SOAP_FMAC4 soap_get_tt__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EFlipOptionsExtension(struct soap *soap, const struct tt__EFlipOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__EFlipOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension * SOAP_FMAC4 soap_in_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, struct tt__EFlipOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EFlipOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EFlipOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptionsExtension, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension * SOAP_FMAC4 soap_new_tt__EFlipOptionsExtension(struct soap *soap, int n)
{
	struct tt__EFlipOptionsExtension *p;
	struct tt__EFlipOptionsExtension *a = (struct tt__EFlipOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EFlipOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlipOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipOptionsExtension(struct soap *soap, const struct tt__EFlipOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipOptionsExtension(soap, tag ? tag : "tt:EFlipOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension * SOAP_FMAC4 soap_get_tt__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirectionOptionsExtension(struct soap *soap, const struct tt__PTControlDirectionOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTControlDirectionOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirectionOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_new_tt__PTControlDirectionOptionsExtension(struct soap *soap, int n)
{
	struct tt__PTControlDirectionOptionsExtension *p;
	struct tt__PTControlDirectionOptionsExtension *a = (struct tt__PTControlDirectionOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirectionOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirectionOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirectionOptionsExtension(struct soap *soap, const struct tt__PTControlDirectionOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirectionOptionsExtension(soap, tag ? tag : "tt:PTControlDirectionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReverseOptions(struct soap *soap, const struct tt__ReverseOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ReverseMode);
		}
	}
	soap_serialize_PointerTott__ReverseOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptions(struct soap *soap, const char *tag, int id, const struct tt__ReverseOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReverseOptions * SOAP_FMAC4 soap_in_tt__ReverseOptions(struct soap *soap, const char *tag, struct tt__ReverseOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReverseOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReverseOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ReverseMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ReverseMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ReverseMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ReverseMode(soap, "tt:Mode", a->Mode, "tt:ReverseMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:ReverseOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ReverseMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptions, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReverseOptions * SOAP_FMAC4 soap_new_tt__ReverseOptions(struct soap *soap, int n)
{
	struct tt__ReverseOptions *p;
	struct tt__ReverseOptions *a = (struct tt__ReverseOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReverseOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ReverseOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseOptions(struct soap *soap, const struct tt__ReverseOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseOptions(soap, tag ? tag : "tt:ReverseOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptions * SOAP_FMAC4 soap_get_tt__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EFlipOptions(struct soap *soap, const struct tt__EFlipOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__EFlipMode);
		}
	}
	soap_serialize_PointerTott__EFlipOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptions(struct soap *soap, const char *tag, int id, const struct tt__EFlipOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EFlipOptions * SOAP_FMAC4 soap_in_tt__EFlipOptions(struct soap *soap, const char *tag, struct tt__EFlipOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EFlipOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EFlipOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__EFlipMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__EFlipMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__EFlipMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__EFlipMode(soap, "tt:Mode", a->Mode, "tt:EFlipMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:EFlipOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__EFlipMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptions, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EFlipOptions * SOAP_FMAC4 soap_new_tt__EFlipOptions(struct soap *soap, int n)
{
	struct tt__EFlipOptions *p;
	struct tt__EFlipOptions *a = (struct tt__EFlipOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EFlipOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlipOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipOptions(struct soap *soap, const struct tt__EFlipOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipOptions(soap, tag ? tag : "tt:EFlipOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptions * SOAP_FMAC4 soap_get_tt__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationOptions2(struct soap *soap, const struct tt__PTZConfigurationOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationOptions2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfigurationOptions2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationOptions2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions2, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_new_tt__PTZConfigurationOptions2(struct soap *soap, int n)
{
	struct tt__PTZConfigurationOptions2 *p;
	struct tt__PTZConfigurationOptions2 *a = (struct tt__PTZConfigurationOptions2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationOptions2));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationOptions2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationOptions2(struct soap *soap, const struct tt__PTZConfigurationOptions2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationOptions2(soap, tag ? tag : "tt:PTZConfigurationOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirectionOptions(struct soap *soap, const struct tt__PTControlDirectionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlipOptions(soap, &a->EFlip);
	soap_serialize_PointerTott__ReverseOptions(soap, &a->Reverse);
	soap_serialize_PointerTott__PTControlDirectionOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirectionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__EFlipOptions(soap, "tt:EFlip", -1, &a->EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__ReverseOptions(soap, "tt:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptions *a, const char *type)
{
	size_t soap_flag_EFlip = 1;
	size_t soap_flag_Reverse = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTControlDirectionOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirectionOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EFlipOptions(soap, "tt:EFlip", &a->EFlip, "tt:EFlipOptions"))
				{	soap_flag_EFlip--;
					continue;
				}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReverseOptions(soap, "tt:Reverse", &a->Reverse, "tt:ReverseOptions"))
				{	soap_flag_Reverse--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:PTControlDirectionOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptions, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions * SOAP_FMAC4 soap_new_tt__PTControlDirectionOptions(struct soap *soap, int n)
{
	struct tt__PTControlDirectionOptions *p;
	struct tt__PTControlDirectionOptions *a = (struct tt__PTControlDirectionOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirectionOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirectionOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirectionOptions(struct soap *soap, const struct tt__PTControlDirectionOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirectionOptions(soap, tag ? tag : "tt:PTControlDirectionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAbsolutePanTiltPositionSpace = 0;
	a->AbsolutePanTiltPositionSpace = NULL;
	a->__sizeAbsoluteZoomPositionSpace = 0;
	a->AbsoluteZoomPositionSpace = NULL;
	a->__sizeRelativePanTiltTranslationSpace = 0;
	a->RelativePanTiltTranslationSpace = NULL;
	a->__sizeRelativeZoomTranslationSpace = 0;
	a->RelativeZoomTranslationSpace = NULL;
	a->__sizeContinuousPanTiltVelocitySpace = 0;
	a->ContinuousPanTiltVelocitySpace = NULL;
	a->__sizeContinuousZoomVelocitySpace = 0;
	a->ContinuousZoomVelocitySpace = NULL;
	a->__sizePanTiltSpeedSpace = 0;
	a->PanTiltSpeedSpace = NULL;
	a->__sizeZoomSpeedSpace = 0;
	a->ZoomSpeedSpace = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsolutePanTiltPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsolutePanTiltPositionSpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace + i);
		}
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsoluteZoomPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsoluteZoomPositionSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->AbsoluteZoomPositionSpace + i);
		}
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativePanTiltTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativePanTiltTranslationSpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->RelativePanTiltTranslationSpace + i);
		}
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativeZoomTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativeZoomTranslationSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->RelativeZoomTranslationSpace + i);
		}
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousPanTiltVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousPanTiltVelocitySpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace + i);
		}
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousZoomVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousZoomVelocitySpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace + i);
		}
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizePanTiltSpeedSpace; i++)
		{
			soap_embedded(soap, a->PanTiltSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->PanTiltSpeedSpace + i);
		}
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeZoomSpeedSpace; i++)
		{
			soap_embedded(soap, a->ZoomSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ZoomSpeedSpace + i);
		}
	}
	soap_serialize_PointerTott__PTZSpacesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const struct tt__PTZSpaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsolutePanTiltPositionSpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", -1, a->AbsolutePanTiltPositionSpace + i, ""))
				return soap->error;
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeAbsoluteZoomPositionSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", -1, a->AbsoluteZoomPositionSpace + i, ""))
				return soap->error;
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativePanTiltTranslationSpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", -1, a->RelativePanTiltTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeRelativeZoomTranslationSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", -1, a->RelativeZoomTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousPanTiltVelocitySpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, a->ContinuousPanTiltVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeContinuousZoomVelocitySpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, a->ContinuousZoomVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizePanTiltSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, a->PanTiltSpeedSpace + i, ""))
				return soap->error;
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < (int)a->__sizeZoomSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, a->ZoomSpeedSpace + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZSpacesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, struct tt__PTZSpaces *a, const char *type)
{
	struct soap_blist *soap_blist_AbsolutePanTiltPositionSpace = NULL;
	struct soap_blist *soap_blist_AbsoluteZoomPositionSpace = NULL;
	struct soap_blist *soap_blist_RelativePanTiltTranslationSpace = NULL;
	struct soap_blist *soap_blist_RelativeZoomTranslationSpace = NULL;
	struct soap_blist *soap_blist_ContinuousPanTiltVelocitySpace = NULL;
	struct soap_blist *soap_blist_ContinuousZoomVelocitySpace = NULL;
	struct soap_blist *soap_blist_PanTiltSpeedSpace = NULL;
	struct soap_blist *soap_blist_ZoomSpeedSpace = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZSpaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsolutePanTiltPositionSpace", 1, NULL))
			{	if (a->AbsolutePanTiltPositionSpace == NULL)
				{	if (soap_blist_AbsolutePanTiltPositionSpace == NULL)
						soap_blist_AbsolutePanTiltPositionSpace = soap_alloc_block(soap);
					a->AbsolutePanTiltPositionSpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_AbsolutePanTiltPositionSpace, sizeof(struct tt__Space2DDescription));
					if (a->AbsolutePanTiltPositionSpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", a->AbsolutePanTiltPositionSpace, "tt:Space2DDescription"))
				{	a->__sizeAbsolutePanTiltPositionSpace++;
					a->AbsolutePanTiltPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsoluteZoomPositionSpace", 1, NULL))
			{	if (a->AbsoluteZoomPositionSpace == NULL)
				{	if (soap_blist_AbsoluteZoomPositionSpace == NULL)
						soap_blist_AbsoluteZoomPositionSpace = soap_alloc_block(soap);
					a->AbsoluteZoomPositionSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_AbsoluteZoomPositionSpace, sizeof(struct tt__Space1DDescription));
					if (a->AbsoluteZoomPositionSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->AbsoluteZoomPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", a->AbsoluteZoomPositionSpace, "tt:Space1DDescription"))
				{	a->__sizeAbsoluteZoomPositionSpace++;
					a->AbsoluteZoomPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativePanTiltTranslationSpace", 1, NULL))
			{	if (a->RelativePanTiltTranslationSpace == NULL)
				{	if (soap_blist_RelativePanTiltTranslationSpace == NULL)
						soap_blist_RelativePanTiltTranslationSpace = soap_alloc_block(soap);
					a->RelativePanTiltTranslationSpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_RelativePanTiltTranslationSpace, sizeof(struct tt__Space2DDescription));
					if (a->RelativePanTiltTranslationSpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->RelativePanTiltTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", a->RelativePanTiltTranslationSpace, "tt:Space2DDescription"))
				{	a->__sizeRelativePanTiltTranslationSpace++;
					a->RelativePanTiltTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativeZoomTranslationSpace", 1, NULL))
			{	if (a->RelativeZoomTranslationSpace == NULL)
				{	if (soap_blist_RelativeZoomTranslationSpace == NULL)
						soap_blist_RelativeZoomTranslationSpace = soap_alloc_block(soap);
					a->RelativeZoomTranslationSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_RelativeZoomTranslationSpace, sizeof(struct tt__Space1DDescription));
					if (a->RelativeZoomTranslationSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->RelativeZoomTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", a->RelativeZoomTranslationSpace, "tt:Space1DDescription"))
				{	a->__sizeRelativeZoomTranslationSpace++;
					a->RelativeZoomTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousPanTiltVelocitySpace", 1, NULL))
			{	if (a->ContinuousPanTiltVelocitySpace == NULL)
				{	if (soap_blist_ContinuousPanTiltVelocitySpace == NULL)
						soap_blist_ContinuousPanTiltVelocitySpace = soap_alloc_block(soap);
					a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_push_block_max(soap, soap_blist_ContinuousPanTiltVelocitySpace, sizeof(struct tt__Space2DDescription));
					if (a->ContinuousPanTiltVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", a->ContinuousPanTiltVelocitySpace, "tt:Space2DDescription"))
				{	a->__sizeContinuousPanTiltVelocitySpace++;
					a->ContinuousPanTiltVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousZoomVelocitySpace", 1, NULL))
			{	if (a->ContinuousZoomVelocitySpace == NULL)
				{	if (soap_blist_ContinuousZoomVelocitySpace == NULL)
						soap_blist_ContinuousZoomVelocitySpace = soap_alloc_block(soap);
					a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_ContinuousZoomVelocitySpace, sizeof(struct tt__Space1DDescription));
					if (a->ContinuousZoomVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", a->ContinuousZoomVelocitySpace, "tt:Space1DDescription"))
				{	a->__sizeContinuousZoomVelocitySpace++;
					a->ContinuousZoomVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PanTiltSpeedSpace", 1, NULL))
			{	if (a->PanTiltSpeedSpace == NULL)
				{	if (soap_blist_PanTiltSpeedSpace == NULL)
						soap_blist_PanTiltSpeedSpace = soap_alloc_block(soap);
					a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_PanTiltSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->PanTiltSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->PanTiltSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", a->PanTiltSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizePanTiltSpeedSpace++;
					a->PanTiltSpeedSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ZoomSpeedSpace", 1, NULL))
			{	if (a->ZoomSpeedSpace == NULL)
				{	if (soap_blist_ZoomSpeedSpace == NULL)
						soap_blist_ZoomSpeedSpace = soap_alloc_block(soap);
					a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_push_block_max(soap, soap_blist_ZoomSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->ZoomSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ZoomSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", a->ZoomSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizeZoomSpeedSpace++;
					a->ZoomSpeedSpace = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpacesExtension(soap, "tt:Extension", &a->Extension, "tt:PTZSpacesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AbsolutePanTiltPositionSpace)
			soap_pop_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		if (a->__sizeAbsolutePanTiltPositionSpace)
		{	a->AbsolutePanTiltPositionSpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_AbsolutePanTiltPositionSpace, NULL, 1);
		}
		else
		{	a->AbsolutePanTiltPositionSpace = NULL;
			if (soap_blist_AbsolutePanTiltPositionSpace)
				soap_end_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		}
		if (a->AbsoluteZoomPositionSpace)
			soap_pop_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		if (a->__sizeAbsoluteZoomPositionSpace)
		{	a->AbsoluteZoomPositionSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_AbsoluteZoomPositionSpace, NULL, 1);
		}
		else
		{	a->AbsoluteZoomPositionSpace = NULL;
			if (soap_blist_AbsoluteZoomPositionSpace)
				soap_end_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		}
		if (a->RelativePanTiltTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		if (a->__sizeRelativePanTiltTranslationSpace)
		{	a->RelativePanTiltTranslationSpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_RelativePanTiltTranslationSpace, NULL, 1);
		}
		else
		{	a->RelativePanTiltTranslationSpace = NULL;
			if (soap_blist_RelativePanTiltTranslationSpace)
				soap_end_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		}
		if (a->RelativeZoomTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativeZoomTranslationSpace);
		if (a->__sizeRelativeZoomTranslationSpace)
		{	a->RelativeZoomTranslationSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_RelativeZoomTranslationSpace, NULL, 1);
		}
		else
		{	a->RelativeZoomTranslationSpace = NULL;
			if (soap_blist_RelativeZoomTranslationSpace)
				soap_end_block(soap, soap_blist_RelativeZoomTranslationSpace);
		}
		if (a->ContinuousPanTiltVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		if (a->__sizeContinuousPanTiltVelocitySpace)
		{	a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, NULL, 1);
		}
		else
		{	a->ContinuousPanTiltVelocitySpace = NULL;
			if (soap_blist_ContinuousPanTiltVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		}
		if (a->ContinuousZoomVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		if (a->__sizeContinuousZoomVelocitySpace)
		{	a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ContinuousZoomVelocitySpace, NULL, 1);
		}
		else
		{	a->ContinuousZoomVelocitySpace = NULL;
			if (soap_blist_ContinuousZoomVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		}
		if (a->PanTiltSpeedSpace)
			soap_pop_block(soap, soap_blist_PanTiltSpeedSpace);
		if (a->__sizePanTiltSpeedSpace)
		{	a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_PanTiltSpeedSpace, NULL, 1);
		}
		else
		{	a->PanTiltSpeedSpace = NULL;
			if (soap_blist_PanTiltSpeedSpace)
				soap_end_block(soap, soap_blist_PanTiltSpeedSpace);
		}
		if (a->ZoomSpeedSpace)
			soap_pop_block(soap, soap_blist_ZoomSpeedSpace);
		if (a->__sizeZoomSpeedSpace)
		{	a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ZoomSpeedSpace, NULL, 1);
		}
		else
		{	a->ZoomSpeedSpace = NULL;
			if (soap_blist_ZoomSpeedSpace)
				soap_end_block(soap, soap_blist_ZoomSpeedSpace);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_new_tt__PTZSpaces(struct soap *soap, int n)
{
	struct tt__PTZSpaces *p;
	struct tt__PTZSpaces *a = (struct tt__PTZSpaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZSpaces));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZSpaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spaces = NULL;
	a->PTZTimeout = NULL;
	a->PTControlDirection = NULL;
	a->Extension = NULL;
	soap_default_tt__IntAttrList(soap, &a->PTZRamps);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationOptions(struct soap *soap, const struct tt__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZSpaces(soap, &a->Spaces);
	soap_serialize_PointerTott__DurationRange(soap, &a->PTZTimeout);
	soap_serialize_PointerTott__PTControlDirectionOptions(soap, &a->PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationOptions2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationOptions *a, const char *type)
{
	if (a->PTZRamps)
		soap_set_attr(soap, "PTZRamps", soap_tt__IntAttrList2s(soap, a->PTZRamps), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions), type))
		return soap->error;
	if (!a->Spaces)
	{	if (soap_element_nil(soap, "tt:Spaces"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZSpaces(soap, "tt:Spaces", -1, &a->Spaces, ""))
		return soap->error;
	if (!a->PTZTimeout)
	{	if (soap_element_nil(soap, "tt:PTZTimeout"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__DurationRange(soap, "tt:PTZTimeout", -1, &a->PTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", -1, &a->PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Spaces = 1;
	size_t soap_flag_PTZTimeout = 1;
	size_t soap_flag_PTControlDirection = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationOptions(soap, a);
	if (soap_s2tt__IntAttrList(soap, soap_attr_value(soap, "PTZRamps", 0), &a->PTZRamps))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpaces(soap, "tt:Spaces", &a->Spaces, "tt:PTZSpaces"))
				{	soap_flag_Spaces--;
					continue;
				}
			if (soap_flag_PTZTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DurationRange(soap, "tt:PTZTimeout", &a->PTZTimeout, "tt:DurationRange"))
				{	soap_flag_PTZTimeout--;
					continue;
				}
			if (soap_flag_PTControlDirection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", &a->PTControlDirection, "tt:PTControlDirectionOptions"))
				{	soap_flag_PTControlDirection--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationOptions2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Spaces > 0 || soap_flag_PTZTimeout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_new_tt__PTZConfigurationOptions(struct soap *soap, int n)
{
	struct tt__PTZConfigurationOptions *p;
	struct tt__PTZConfigurationOptions *a = (struct tt__PTZConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationOptions(struct soap *soap, const struct tt__PTZConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationOptions(soap, tag ? tag : "tt:PTZConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirectionExtension(struct soap *soap, const struct tt__PTControlDirectionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirectionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTControlDirectionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirectionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionExtension, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension * SOAP_FMAC4 soap_new_tt__PTControlDirectionExtension(struct soap *soap, int n)
{
	struct tt__PTControlDirectionExtension *p;
	struct tt__PTControlDirectionExtension *a = (struct tt__PTControlDirectionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirectionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirectionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirectionExtension(struct soap *soap, const struct tt__PTControlDirectionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Reverse(struct soap *soap, struct tt__Reverse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReverseMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Reverse(struct soap *soap, const struct tt__Reverse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ReverseMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap *soap, const char *tag, int id, const struct tt__Reverse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Reverse), type))
		return soap->error;
	if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap *soap, const char *tag, struct tt__Reverse *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Reverse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Reverse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReverseMode(soap, "tt:Mode", &a->Mode, "tt:ReverseMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Reverse * SOAP_FMAC4 soap_new_tt__Reverse(struct soap *soap, int n)
{
	struct tt__Reverse *p;
	struct tt__Reverse *a = (struct tt__Reverse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Reverse));
	for (p = a; p && n--; p++)
		soap_default_tt__Reverse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Reverse(struct soap *soap, const struct tt__Reverse *a, const char *tag, const char *type)
{
	if (soap_out_tt__Reverse(soap, tag ? tag : "tt:Reverse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap *soap, struct tt__Reverse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EFlip(struct soap *soap, struct tt__EFlip *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__EFlipMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EFlip(struct soap *soap, const struct tt__EFlip *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__EFlipMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap *soap, const char *tag, int id, const struct tt__EFlip *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlip), type))
		return soap->error;
	if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap *soap, const char *tag, struct tt__EFlip *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EFlip *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EFlip(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__EFlipMode(soap, "tt:Mode", &a->Mode, "tt:EFlipMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EFlip * SOAP_FMAC4 soap_new_tt__EFlip(struct soap *soap, int n)
{
	struct tt__EFlip *p;
	struct tt__EFlip *a = (struct tt__EFlip*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EFlip));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlip(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlip(struct soap *soap, const struct tt__EFlip *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlip(soap, tag ? tag : "tt:EFlip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap *soap, struct tt__EFlip *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationExtension2(struct soap *soap, const struct tt__PTZConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension2, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_new_tt__PTZConfigurationExtension2(struct soap *soap, int n)
{
	struct tt__PTZConfigurationExtension2 *p;
	struct tt__PTZConfigurationExtension2 *a = (struct tt__PTZConfigurationExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationExtension2(struct soap *soap, const struct tt__PTZConfigurationExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTControlDirection(struct soap *soap, const struct tt__PTControlDirection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlip(soap, &a->EFlip);
	soap_serialize_PointerTott__Reverse(soap, &a->Reverse);
	soap_serialize_PointerTott__PTControlDirectionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap *soap, const char *tag, int id, const struct tt__PTControlDirection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirection), type))
		return soap->error;
	if (soap_out_PointerTott__EFlip(soap, "tt:EFlip", -1, &a->EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__Reverse(soap, "tt:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap *soap, const char *tag, struct tt__PTControlDirection *a, const char *type)
{
	size_t soap_flag_EFlip = 1;
	size_t soap_flag_Reverse = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTControlDirection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTControlDirection(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EFlip(soap, "tt:EFlip", &a->EFlip, "tt:EFlip"))
				{	soap_flag_EFlip--;
					continue;
				}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Reverse(soap, "tt:Reverse", &a->Reverse, "tt:Reverse"))
				{	soap_flag_Reverse--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", &a->Extension, "tt:PTControlDirectionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTControlDirection * SOAP_FMAC4 soap_new_tt__PTControlDirection(struct soap *soap, int n)
{
	struct tt__PTControlDirection *p;
	struct tt__PTControlDirection *a = (struct tt__PTControlDirection*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTControlDirection));
	for (p = a; p && n--; p++)
		soap_default_tt__PTControlDirection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTControlDirection(struct soap *soap, const struct tt__PTControlDirection *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTControlDirection = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTControlDirection(soap, &a->PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", -1, &a->PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension *a, const char *type)
{
	size_t soap_flag_PTControlDirection = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTControlDirection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", &a->PTControlDirection, "tt:PTControlDirection"))
				{	soap_flag_PTControlDirection--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_new_tt__PTZConfigurationExtension(struct soap *soap, int n)
{
	struct tt__PTZConfigurationExtension *p;
	struct tt__PTZConfigurationExtension *a = (struct tt__PTZConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSupportedExtension(struct soap *soap, const struct tt__PTZPresetTourSupportedExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourSupportedExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSupportedExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupportedExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_new_tt__PTZPresetTourSupportedExtension(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSupportedExtension *p;
	struct tt__PTZPresetTourSupportedExtension *a = (struct tt__PTZPresetTourSupportedExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSupportedExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSupportedExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSupportedExtension(struct soap *soap, const struct tt__PTZPresetTourSupportedExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSupportedExtension(soap, tag ? tag : "tt:PTZPresetTourSupportedExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNodeExtension2(struct soap *soap, const struct tt__PTZNodeExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension2(struct soap *soap, const char *tag, int id, const struct tt__PTZNodeExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 * SOAP_FMAC4 soap_in_tt__PTZNodeExtension2(struct soap *soap, const char *tag, struct tt__PTZNodeExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZNodeExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNodeExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension2, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 * SOAP_FMAC4 soap_new_tt__PTZNodeExtension2(struct soap *soap, int n)
{
	struct tt__PTZNodeExtension2 *p;
	struct tt__PTZNodeExtension2 *a = (struct tt__PTZNodeExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNodeExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNodeExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNodeExtension2(struct soap *soap, const struct tt__PTZNodeExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNodeExtension2(soap, tag ? tag : "tt:PTZNodeExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 * SOAP_FMAC4 soap_get_tt__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfPresetTours);
	a->__sizePTZPresetTourOperation = 0;
	a->PTZPresetTourOperation = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPresetTourSupported(struct soap *soap, const struct tt__PTZPresetTourSupported *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaximumNumberOfPresetTours, SOAP_TYPE_int);
	if (a->PTZPresetTourOperation)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZPresetTourOperation; i++)
		{
			soap_embedded(soap, a->PTZPresetTourOperation + i, SOAP_TYPE_tt__PTZPresetTourOperation);
		}
	}
	soap_serialize_PointerTott__PTZPresetTourSupportedExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, const struct tt__PTZPresetTourSupported *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupported), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresetTours", -1, &a->MaximumNumberOfPresetTours, ""))
		return soap->error;
	if (a->PTZPresetTourOperation)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZPresetTourOperation; i++)
			if (soap_out_tt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", -1, a->PTZPresetTourOperation + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupported *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfPresetTours = 1;
	struct soap_blist *soap_blist_PTZPresetTourOperation = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPresetTourSupported *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPresetTourSupported(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfPresetTours && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfPresetTours", &a->MaximumNumberOfPresetTours, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresetTours--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PTZPresetTourOperation", 1, NULL))
			{	if (a->PTZPresetTourOperation == NULL)
				{	if (soap_blist_PTZPresetTourOperation == NULL)
						soap_blist_PTZPresetTourOperation = soap_alloc_block(soap);
					a->PTZPresetTourOperation = (enum tt__PTZPresetTourOperation *)soap_push_block_max(soap, soap_blist_PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation));
					if (a->PTZPresetTourOperation == NULL)
						return NULL;
					soap_default_tt__PTZPresetTourOperation(soap, a->PTZPresetTourOperation);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", a->PTZPresetTourOperation, "tt:PTZPresetTourOperation"))
				{	a->__sizePTZPresetTourOperation++;
					a->PTZPresetTourOperation = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", &a->Extension, "tt:PTZPresetTourSupportedExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZPresetTourOperation)
			soap_pop_block(soap, soap_blist_PTZPresetTourOperation);
		if (a->__sizePTZPresetTourOperation)
		{	a->PTZPresetTourOperation = (enum tt__PTZPresetTourOperation *)soap_save_block(soap, soap_blist_PTZPresetTourOperation, NULL, 1);
		}
		else
		{	a->PTZPresetTourOperation = NULL;
			if (soap_blist_PTZPresetTourOperation)
				soap_end_block(soap, soap_blist_PTZPresetTourOperation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfPresetTours > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupported *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupported, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported * SOAP_FMAC4 soap_new_tt__PTZPresetTourSupported(struct soap *soap, int n)
{
	struct tt__PTZPresetTourSupported *p;
	struct tt__PTZPresetTourSupported *a = (struct tt__PTZPresetTourSupported*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZPresetTourSupported));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZPresetTourSupported(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourSupported(struct soap *soap, const struct tt__PTZPresetTourSupported *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourSupported(soap, tag ? tag : "tt:PTZPresetTourSupported", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportedPresetTour = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNodeExtension(struct soap *soap, const struct tt__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSupported(soap, &a->SupportedPresetTour);
	soap_serialize_PointerTott__PTZNodeExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZNodeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension), type))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", -1, &a->SupportedPresetTour, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_in_tt__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension *a, const char *type)
{
	size_t soap_flag_SupportedPresetTour = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZNodeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNodeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", &a->SupportedPresetTour, "tt:PTZPresetTourSupported"))
				{	soap_flag_SupportedPresetTour--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZNodeExtension2(soap, "tt:Extension", &a->Extension, "tt:PTZNodeExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_new_tt__PTZNodeExtension(struct soap *soap, int n)
{
	struct tt__PTZNodeExtension *p;
	struct tt__PTZNodeExtension *a = (struct tt__PTZNodeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZNodeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZNodeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNodeExtension(struct soap *soap, const struct tt__PTZNodeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_get_tt__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RelayMode(soap, &a->Mode);
	soap_default_xsd__duration(soap, &a->DelayTime);
	soap_default_tt__RelayIdleState(soap, &a->IdleState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DelayTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const struct tt__RelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:DelayTime", -1, &a->DelayTime, ""))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->IdleState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_DelayTime = 1;
	size_t soap_flag_IdleState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->Mode, "tt:RelayMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_DelayTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:DelayTime", &a->DelayTime, "xsd:duration"))
				{	soap_flag_DelayTime--;
					continue;
				}
			if (soap_flag_IdleState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->IdleState, "tt:RelayIdleState"))
				{	soap_flag_IdleState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_DelayTime > 0 || soap_flag_IdleState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_new_tt__RelayOutputSettings(struct soap *soap, int n)
{
	struct tt__RelayOutputSettings *p;
	struct tt__RelayOutputSettings *a = (struct tt__RelayOutputSettings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelayOutputSettings));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayOutputSettings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GenericEapPwdConfigurationExtension(struct soap *soap, struct tt__GenericEapPwdConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const struct tt__GenericEapPwdConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_in_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, struct tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GenericEapPwdConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_new_tt__GenericEapPwdConfigurationExtension(struct soap *soap, int n)
{
	struct tt__GenericEapPwdConfigurationExtension *p;
	struct tt__GenericEapPwdConfigurationExtension *a = (struct tt__GenericEapPwdConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__GenericEapPwdConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__GenericEapPwdConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const struct tt__GenericEapPwdConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__GenericEapPwdConfigurationExtension(soap, tag ? tag : "tt:GenericEapPwdConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_get_tt__GenericEapPwdConfigurationExtension(struct soap *soap, struct tt__GenericEapPwdConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GenericEapPwdConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EapMethodExtension(struct soap *soap, const struct tt__EapMethodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EapMethodExtension(struct soap *soap, const char *tag, int id, const struct tt__EapMethodExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EapMethodExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_in_tt__EapMethodExtension(struct soap *soap, const char *tag, struct tt__EapMethodExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EapMethodExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EapMethodExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EapMethodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EapMethodExtension, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_new_tt__EapMethodExtension(struct soap *soap, int n)
{
	struct tt__EapMethodExtension *p;
	struct tt__EapMethodExtension *a = (struct tt__EapMethodExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EapMethodExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__EapMethodExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EapMethodExtension(struct soap *soap, const struct tt__EapMethodExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_get_tt__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TLSConfiguration(struct soap *soap, const struct tt__TLSConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TLSConfiguration(struct soap *soap, const char *tag, int id, const struct tt__TLSConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TLSConfiguration), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_nil(soap, "tt:CertificateID"))
			return soap->error;
	}
	else
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_in_tt__TLSConfiguration(struct soap *soap, const char *tag, struct tt__TLSConfiguration *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TLSConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TLSConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_new_tt__TLSConfiguration(struct soap *soap, int n)
{
	struct tt__TLSConfiguration *p;
	struct tt__TLSConfiguration *a = (struct tt__TLSConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TLSConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__TLSConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TLSConfiguration(struct soap *soap, const struct tt__TLSConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_get_tt__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot1XConfigurationExtension(struct soap *soap, const struct tt__Dot1XConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot1XConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot1XConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot1XConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfigurationExtension, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_new_tt__Dot1XConfigurationExtension(struct soap *soap, int n)
{
	struct tt__Dot1XConfigurationExtension *p;
	struct tt__Dot1XConfigurationExtension *a = (struct tt__Dot1XConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot1XConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot1XConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot1XConfigurationExtension(struct soap *soap, const struct tt__Dot1XConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TLSConfiguration = NULL;
	soap_default_string(soap, &a->Password);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EAPMethodConfiguration(struct soap *soap, const struct tt__EAPMethodConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TLSConfiguration(soap, &a->TLSConfiguration);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTott__EapMethodExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, const struct tt__EAPMethodConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EAPMethodConfiguration), type))
		return soap->error;
	if (soap_out_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", -1, &a->TLSConfiguration, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_PointerTott__EapMethodExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_in_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, struct tt__EAPMethodConfiguration *a, const char *type)
{
	size_t soap_flag_TLSConfiguration = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EAPMethodConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EAPMethodConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLSConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", &a->TLSConfiguration, "tt:TLSConfiguration"))
				{	soap_flag_TLSConfiguration--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EapMethodExtension(soap, "tt:Extension", &a->Extension, "tt:EapMethodExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_new_tt__EAPMethodConfiguration(struct soap *soap, int n)
{
	struct tt__EAPMethodConfiguration *p;
	struct tt__EAPMethodConfiguration *a = (struct tt__EAPMethodConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EAPMethodConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__EAPMethodConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EAPMethodConfiguration(struct soap *soap, const struct tt__EAPMethodConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_get_tt__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
	soap_default_string(soap, &a->Identity);
	soap_default_string(soap, &a->AnonymousID);
	soap_default_int(soap, &a->EAPMethod);
	a->__sizeCACertificateID = 0;
	a->CACertificateID = NULL;
	a->EAPMethodConfiguration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot1XConfiguration(struct soap *soap, const struct tt__Dot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Dot1XConfigurationToken);
	soap_serialize_string(soap, (char*const*)&a->Identity);
	soap_serialize_string(soap, (char*const*)&a->AnonymousID);
	soap_embedded(soap, &a->EAPMethod, SOAP_TYPE_int);
	if (a->CACertificateID)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificateID; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->CACertificateID + i));
		}
	}
	soap_serialize_PointerTott__EAPMethodConfiguration(soap, &a->EAPMethodConfiguration);
	soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const struct tt__Dot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfiguration), type))
		return soap->error;
	if (!a->Dot1XConfigurationToken)
	{	if (soap_element_nil(soap, "tt:Dot1XConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", -1, (char*const*)&a->Dot1XConfigurationToken, ""))
		return soap->error;
	if (!a->Identity)
	{	if (soap_element_nil(soap, "tt:Identity"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Identity", -1, (char*const*)&a->Identity, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:AnonymousID", -1, (char*const*)&a->AnonymousID, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EAPMethod", -1, &a->EAPMethod, ""))
		return soap->error;
	if (a->CACertificateID)
	{	int i;
		for (i = 0; i < (int)a->__sizeCACertificateID; i++)
			soap_out_string(soap, "tt:CACertificateID", -1, (char*const*)(a->CACertificateID + i), "");
	}
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", -1, &a->EAPMethodConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_in_tt__Dot1XConfiguration(struct soap *soap, const char *tag, struct tt__Dot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfigurationToken = 1;
	size_t soap_flag_Identity = 1;
	size_t soap_flag_AnonymousID = 1;
	size_t soap_flag_EAPMethod = 1;
	struct soap_blist *soap_blist_CACertificateID = NULL;
	size_t soap_flag_EAPMethodConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", (char**)&a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken--;
					continue;
				}
			if (soap_flag_Identity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Identity", (char**)&a->Identity, "xsd:string"))
				{	soap_flag_Identity--;
					continue;
				}
			if (soap_flag_AnonymousID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:AnonymousID", (char**)&a->AnonymousID, "xsd:string"))
				{	soap_flag_AnonymousID--;
					continue;
				}
			if (soap_flag_EAPMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:EAPMethod", &a->EAPMethod, "xsd:int"))
				{	soap_flag_EAPMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:CACertificateID", 1, NULL))
			{	if (a->CACertificateID == NULL)
				{	if (soap_blist_CACertificateID == NULL)
						soap_blist_CACertificateID = soap_alloc_block(soap);
					a->CACertificateID = (char **)soap_push_block_max(soap, soap_blist_CACertificateID, sizeof(char *));
					if (a->CACertificateID == NULL)
						return NULL;
					*a->CACertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tt:CACertificateID", (char**)a->CACertificateID, "xsd:token"))
				{	a->__sizeCACertificateID++;
					a->CACertificateID = NULL;
					continue;
				}
			}
			if (soap_flag_EAPMethodConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", &a->EAPMethodConfiguration, "tt:EAPMethodConfiguration"))
				{	soap_flag_EAPMethodConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:Dot1XConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificateID)
			soap_pop_block(soap, soap_blist_CACertificateID);
		if (a->__sizeCACertificateID)
		{	a->CACertificateID = (char **)soap_save_block(soap, soap_blist_CACertificateID, NULL, 1);
		}
		else
		{	a->CACertificateID = NULL;
			if (soap_blist_CACertificateID)
				soap_end_block(soap, soap_blist_CACertificateID);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken > 0 || soap_flag_Identity > 0 || soap_flag_EAPMethod > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_new_tt__Dot1XConfiguration(struct soap *soap, int n)
{
	struct tt__Dot1XConfiguration *p;
	struct tt__Dot1XConfiguration *a = (struct tt__Dot1XConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Dot1XConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot1XConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot1XConfiguration(struct soap *soap, const struct tt__Dot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_get_tt__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateInformationExtension(struct soap *soap, const struct tt__CertificateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__CertificateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_in_tt__CertificateInformationExtension(struct soap *soap, const char *tag, struct tt__CertificateInformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformationExtension, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_new_tt__CertificateInformationExtension(struct soap *soap, int n)
{
	struct tt__CertificateInformationExtension *p;
	struct tt__CertificateInformationExtension *a = (struct tt__CertificateInformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateInformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateInformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateInformationExtension(struct soap *soap, const struct tt__CertificateInformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_get_tt__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->From);
	soap_default_dateTime(soap, &a->Until);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTimeRange(struct soap *soap, const struct tt__DateTimeRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->From, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->Until, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTimeRange(struct soap *soap, const char *tag, int id, const struct tt__DateTimeRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTimeRange), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:From", -1, &a->From, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Until", -1, &a->Until, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_in_tt__DateTimeRange(struct soap *soap, const char *tag, struct tt__DateTimeRange *a, const char *type)
{
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DateTimeRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DateTimeRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:From", &a->From, "xsd:dateTime"))
				{	soap_flag_From--;
					continue;
				}
			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tt:Until", &a->Until, "xsd:dateTime"))
				{	soap_flag_Until--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From > 0 || soap_flag_Until > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_new_tt__DateTimeRange(struct soap *soap, int n)
{
	struct tt__DateTimeRange *p;
	struct tt__DateTimeRange *a = (struct tt__DateTimeRange*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DateTimeRange));
	for (p = a; p && n--; p++)
		soap_default_tt__DateTimeRange(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTimeRange(struct soap *soap, const struct tt__DateTimeRange *a, const char *tag, const char *type)
{
	if (soap_out_tt__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_get_tt__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__boolean(soap, &a->Critical);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateUsage(struct soap *soap, const struct tt__CertificateUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateUsage(struct soap *soap, const char *tag, int id, const struct tt__CertificateUsage *a, const char *type)
{
	soap_set_attr(soap, "Critical", soap_xsd__boolean2s(soap, a->Critical), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_in_tt__CertificateUsage(struct soap *soap, const char *tag, struct tt__CertificateUsage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct tt__CertificateUsage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__CertificateUsage(soap, a);
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "Critical", 1), &a->Critical))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "tt:CertificateUsage"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_new_tt__CertificateUsage(struct soap *soap, int n)
{
	struct tt__CertificateUsage *p;
	struct tt__CertificateUsage *a = (struct tt__CertificateUsage*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateUsage));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateUsage(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateUsage(struct soap *soap, const struct tt__CertificateUsage *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_get_tt__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->IssuerDN);
	soap_default_string(soap, &a->SubjectDN);
	a->KeyUsage = NULL;
	a->ExtendedKeyUsage = NULL;
	a->KeyLength = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->SerialNum);
	soap_default_string(soap, &a->SignatureAlgorithm);
	a->Validity = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateInformation(struct soap *soap, const struct tt__CertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_string(soap, (char*const*)&a->IssuerDN);
	soap_serialize_string(soap, (char*const*)&a->SubjectDN);
	soap_serialize_PointerTott__CertificateUsage(soap, &a->KeyUsage);
	soap_serialize_PointerTott__CertificateUsage(soap, &a->ExtendedKeyUsage);
	soap_serialize_PointerToint(soap, &a->KeyLength);
	soap_serialize_string(soap, (char*const*)&a->Version);
	soap_serialize_string(soap, (char*const*)&a->SerialNum);
	soap_serialize_string(soap, (char*const*)&a->SignatureAlgorithm);
	soap_serialize_PointerTott__DateTimeRange(soap, &a->Validity);
	soap_serialize_PointerTott__CertificateInformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformation(struct soap *soap, const char *tag, int id, const struct tt__CertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformation), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_nil(soap, "tt:CertificateID"))
			return soap->error;
	}
	else
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:IssuerDN", -1, (char*const*)&a->IssuerDN, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SubjectDN", -1, (char*const*)&a->SubjectDN, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:KeyUsage", -1, &a->KeyUsage, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", -1, &a->ExtendedKeyUsage, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:KeyLength", -1, &a->KeyLength, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Version", -1, (char*const*)&a->Version, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SerialNum", -1, (char*const*)&a->SerialNum, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SignatureAlgorithm", -1, (char*const*)&a->SignatureAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTimeRange(soap, "tt:Validity", -1, &a->Validity, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_in_tt__CertificateInformation(struct soap *soap, const char *tag, struct tt__CertificateInformation *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_IssuerDN = 1;
	size_t soap_flag_SubjectDN = 1;
	size_t soap_flag_KeyUsage = 1;
	size_t soap_flag_ExtendedKeyUsage = 1;
	size_t soap_flag_KeyLength = 1;
	size_t soap_flag_Version = 1;
	size_t soap_flag_SerialNum = 1;
	size_t soap_flag_SignatureAlgorithm = 1;
	size_t soap_flag_Validity = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_IssuerDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:IssuerDN", (char**)&a->IssuerDN, "xsd:string"))
				{	soap_flag_IssuerDN--;
					continue;
				}
			if (soap_flag_SubjectDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SubjectDN", (char**)&a->SubjectDN, "xsd:string"))
				{	soap_flag_SubjectDN--;
					continue;
				}
			if (soap_flag_KeyUsage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateUsage(soap, "tt:KeyUsage", &a->KeyUsage, "tt:CertificateUsage"))
				{	soap_flag_KeyUsage--;
					continue;
				}
			if (soap_flag_ExtendedKeyUsage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", &a->ExtendedKeyUsage, "tt:CertificateUsage"))
				{	soap_flag_ExtendedKeyUsage--;
					continue;
				}
			if (soap_flag_KeyLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:KeyLength", &a->KeyLength, "xsd:int"))
				{	soap_flag_KeyLength--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Version", (char**)&a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap_flag_SerialNum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SerialNum", (char**)&a->SerialNum, "xsd:string"))
				{	soap_flag_SerialNum--;
					continue;
				}
			if (soap_flag_SignatureAlgorithm && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SignatureAlgorithm", (char**)&a->SignatureAlgorithm, "xsd:string"))
				{	soap_flag_SignatureAlgorithm--;
					continue;
				}
			if (soap_flag_Validity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTimeRange(soap, "tt:Validity", &a->Validity, "tt:DateTimeRange"))
				{	soap_flag_Validity--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateInformationExtension(soap, "tt:Extension", &a->Extension, "tt:CertificateInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_new_tt__CertificateInformation(struct soap *soap, int n)
{
	struct tt__CertificateInformation *p;
	struct tt__CertificateInformation *a = (struct tt__CertificateInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateInformation(struct soap *soap, const struct tt__CertificateInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_get_tt__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
