/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordings(struct soap *soap, const struct _trc__GetRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordings(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordings), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_in__trc__GetRecordings(struct soap *soap, const char *tag, struct _trc__GetRecordings *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordings, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_new__trc__GetRecordings(struct soap *soap, int n)
{
	struct _trc__GetRecordings *p;
	struct _trc__GetRecordings *a = (struct _trc__GetRecordings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetRecordings));
	for (p = a; p && n--; p++)
		soap_default__trc__GetRecordings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordings(struct soap *soap, const struct _trc__GetRecordings *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetRecordings(soap, tag ? tag : "trc:GetRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_get__trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingResponse(struct soap *soap, const struct _trc__DeleteRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_in__trc__DeleteRecordingResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingResponse, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_new__trc__DeleteRecordingResponse(struct soap *soap, int n)
{
	struct _trc__DeleteRecordingResponse *p;
	struct _trc__DeleteRecordingResponse *a = (struct _trc__DeleteRecordingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecordingResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecordingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingResponse(struct soap *soap, const struct _trc__DeleteRecordingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecordingResponse(soap, tag ? tag : "trc:DeleteRecordingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_get__trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecording(struct soap *soap, const struct _trc__DeleteRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecording(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecording), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_in__trc__DeleteRecording(struct soap *soap, const char *tag, struct _trc__DeleteRecording *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecording *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecording(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecording, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_new__trc__DeleteRecording(struct soap *soap, int n)
{
	struct _trc__DeleteRecording *p;
	struct _trc__DeleteRecording *a = (struct _trc__DeleteRecording*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__DeleteRecording));
	for (p = a; p && n--; p++)
		soap_default__trc__DeleteRecording(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecording(struct soap *soap, const struct _trc__DeleteRecording *a, const char *tag, const char *type)
{
	if (soap_out__trc__DeleteRecording(soap, tag ? tag : "trc:DeleteRecording", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_get__trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingResponse(struct soap *soap, const struct _trc__CreateRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingResponse), type))
		return soap->error;
	if (a->RecordingToken)
		soap_element_result(soap, "trc:RecordingToken");
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "trc:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_in__trc__CreateRecordingResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingResponse *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			soap_check_result(soap, "trc:RecordingToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingResponse, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_new__trc__CreateRecordingResponse(struct soap *soap, int n)
{
	struct _trc__CreateRecordingResponse *p;
	struct _trc__CreateRecordingResponse *a = (struct _trc__CreateRecordingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecordingResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecordingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingResponse(struct soap *soap, const struct _trc__CreateRecordingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecordingResponse(soap, tag ? tag : "trc:CreateRecordingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_get__trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecording(struct soap *soap, const struct _trc__CreateRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecording(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecording), type))
		return soap->error;
	if (!a->RecordingConfiguration)
	{	if (soap_element_nil(soap, "trc:RecordingConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_in__trc__CreateRecording(struct soap *soap, const char *tag, struct _trc__CreateRecording *a, const char *type)
{
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecording *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecording(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__CreateRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecording, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_new__trc__CreateRecording(struct soap *soap, int n)
{
	struct _trc__CreateRecording *p;
	struct _trc__CreateRecording *a = (struct _trc__CreateRecording*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__CreateRecording));
	for (p = a; p && n--; p++)
		soap_default__trc__CreateRecording(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecording(struct soap *soap, const struct _trc__CreateRecording *a, const char *tag, const char *type)
{
	if (soap_out__trc__CreateRecording(soap, tag ? tag : "trc:CreateRecording", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_get__trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trc__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrc__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trc:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "trc:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotrc__Capabilities(soap, "trc:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__Capabilities(soap, "trc:Capabilities", &a->Capabilities, "trc:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trc:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trc__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trc__GetServiceCapabilitiesResponse *p;
	struct _trc__GetServiceCapabilitiesResponse *a = (struct _trc__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trc__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trc__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetServiceCapabilitiesResponse(soap, tag ? tag : "trc:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetServiceCapabilities(struct soap *soap, const struct _trc__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trc__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_in__trc__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilities, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_new__trc__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trc__GetServiceCapabilities *p;
	struct _trc__GetServiceCapabilities *a = (struct _trc__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trc__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trc__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetServiceCapabilities(struct soap *soap, const struct _trc__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trc__GetServiceCapabilities(soap, tag ? tag : "trc:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_get__trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__TrackOptions(struct soap *soap, struct trc__TrackOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SpareTotal = NULL;
	a->SpareVideo = NULL;
	a->SpareAudio = NULL;
	a->SpareMetadata = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__TrackOptions(struct soap *soap, const struct trc__TrackOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__TrackOptions(struct soap *soap, const char *tag, int id, const struct trc__TrackOptions *a, const char *type)
{
	if (a->SpareTotal)
		soap_set_attr(soap, "SpareTotal", soap_int2s(soap, *a->SpareTotal), 1);
	if (a->SpareVideo)
		soap_set_attr(soap, "SpareVideo", soap_int2s(soap, *a->SpareVideo), 1);
	if (a->SpareAudio)
		soap_set_attr(soap, "SpareAudio", soap_int2s(soap, *a->SpareAudio), 1);
	if (a->SpareMetadata)
		soap_set_attr(soap, "SpareMetadata", soap_int2s(soap, *a->SpareMetadata), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__TrackOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_in_trc__TrackOptions(struct soap *soap, const char *tag, struct trc__TrackOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__TrackOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__TrackOptions(soap, a);
	{	const char *t = soap_attr_value(soap, "SpareTotal", 0);
		if (t)
		{
			if (!(a->SpareTotal = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareTotal))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SpareVideo", 0);
		if (t)
		{
			if (!(a->SpareVideo = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareVideo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SpareAudio", 0);
		if (t)
		{
			if (!(a->SpareAudio = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareAudio))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SpareMetadata", 0);
		if (t)
		{
			if (!(a->SpareMetadata = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareMetadata))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__TrackOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__TrackOptions, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_new_trc__TrackOptions(struct soap *soap, int n)
{
	struct trc__TrackOptions *p;
	struct trc__TrackOptions *a = (struct trc__TrackOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__TrackOptions));
	for (p = a; p && n--; p++)
		soap_default_trc__TrackOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__TrackOptions(struct soap *soap, const struct trc__TrackOptions *a, const char *tag, const char *type)
{
	if (soap_out_trc__TrackOptions(soap, tag ? tag : "trc:TrackOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_get_trc__TrackOptions(struct soap *soap, struct trc__TrackOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__TrackOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__JobOptions(struct soap *soap, struct trc__JobOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spare = NULL;
	soap_default_tt__StringAttrList(soap, &a->CompatibleSources);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__JobOptions(struct soap *soap, const struct trc__JobOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__JobOptions(struct soap *soap, const char *tag, int id, const struct trc__JobOptions *a, const char *type)
{
	if (a->Spare)
		soap_set_attr(soap, "Spare", soap_int2s(soap, *a->Spare), 1);
	if (a->CompatibleSources)
		soap_set_attr(soap, "CompatibleSources", soap_tt__StringAttrList2s(soap, a->CompatibleSources), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__JobOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_in_trc__JobOptions(struct soap *soap, const char *tag, struct trc__JobOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__JobOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__JobOptions(soap, a);
	{	const char *t = soap_attr_value(soap, "Spare", 0);
		if (t)
		{
			if (!(a->Spare = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Spare))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "CompatibleSources", 0), &a->CompatibleSources))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__JobOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__JobOptions, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_new_trc__JobOptions(struct soap *soap, int n)
{
	struct trc__JobOptions *p;
	struct trc__JobOptions *a = (struct trc__JobOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__JobOptions));
	for (p = a; p && n--; p++)
		soap_default_trc__JobOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__JobOptions(struct soap *soap, const struct trc__JobOptions *a, const char *tag, const char *type)
{
	if (soap_out_trc__JobOptions(soap, tag ? tag : "trc:JobOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_get_trc__JobOptions(struct soap *soap, struct trc__JobOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__JobOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Job = NULL;
	a->Track = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__RecordingOptions(struct soap *soap, const struct trc__RecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrc__JobOptions(soap, &a->Job);
	soap_serialize_PointerTotrc__TrackOptions(soap, &a->Track);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__RecordingOptions(struct soap *soap, const char *tag, int id, const struct trc__RecordingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__RecordingOptions), type))
		return soap->error;
	if (!a->Job)
	{	if (soap_element_nil(soap, "trc:Job"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotrc__JobOptions(soap, "trc:Job", -1, &a->Job, ""))
		return soap->error;
	if (!a->Track)
	{	if (soap_element_nil(soap, "trc:Track"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotrc__TrackOptions(soap, "trc:Track", -1, &a->Track, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_in_trc__RecordingOptions(struct soap *soap, const char *tag, struct trc__RecordingOptions *a, const char *type)
{
	size_t soap_flag_Job = 1;
	size_t soap_flag_Track = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__RecordingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__RecordingOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__JobOptions(soap, "trc:Job", &a->Job, "trc:JobOptions"))
				{	soap_flag_Job--;
					continue;
				}
			if (soap_flag_Track && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__TrackOptions(soap, "trc:Track", &a->Track, "trc:TrackOptions"))
				{	soap_flag_Track--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Job > 0 || soap_flag_Track > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct trc__RecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__RecordingOptions, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_new_trc__RecordingOptions(struct soap *soap, int n)
{
	struct trc__RecordingOptions *p;
	struct trc__RecordingOptions *a = (struct trc__RecordingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__RecordingOptions));
	for (p = a; p && n--; p++)
		soap_default_trc__RecordingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__RecordingOptions(struct soap *soap, const struct trc__RecordingOptions *a, const char *tag, const char *type)
{
	if (soap_out_trc__RecordingOptions(soap, tag ? tag : "trc:RecordingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_get_trc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__RecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__Capabilities(struct soap *soap, struct trc__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DynamicRecordings = NULL;
	a->DynamicTracks = NULL;
	soap_default_trc__EncodingTypes(soap, &a->Encoding);
	a->MaxRate = NULL;
	a->MaxTotalRate = NULL;
	a->MaxRecordings = NULL;
	a->MaxRecordingJobs = NULL;
	a->Options = NULL;
	a->MetadataRecording = NULL;
	soap_default_tt__StringAttrList(soap, &a->SupportedExportFileFormats);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__Capabilities(struct soap *soap, const struct trc__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__Capabilities(struct soap *soap, const char *tag, int id, const struct trc__Capabilities *a, const char *type)
{
	if (a->DynamicRecordings)
		soap_set_attr(soap, "DynamicRecordings", soap_xsd__boolean2s(soap, *a->DynamicRecordings), 1);
	if (a->DynamicTracks)
		soap_set_attr(soap, "DynamicTracks", soap_xsd__boolean2s(soap, *a->DynamicTracks), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_trc__EncodingTypes2s(soap, a->Encoding), 1);
	if (a->MaxRate)
		soap_set_attr(soap, "MaxRate", soap_float2s(soap, *a->MaxRate), 1);
	if (a->MaxTotalRate)
		soap_set_attr(soap, "MaxTotalRate", soap_float2s(soap, *a->MaxTotalRate), 1);
	if (a->MaxRecordings)
		soap_set_attr(soap, "MaxRecordings", soap_float2s(soap, *a->MaxRecordings), 1);
	if (a->MaxRecordingJobs)
		soap_set_attr(soap, "MaxRecordingJobs", soap_int2s(soap, *a->MaxRecordingJobs), 1);
	if (a->Options)
		soap_set_attr(soap, "Options", soap_xsd__boolean2s(soap, *a->Options), 1);
	if (a->MetadataRecording)
		soap_set_attr(soap, "MetadataRecording", soap_xsd__boolean2s(soap, *a->MetadataRecording), 1);
	if (a->SupportedExportFileFormats)
		soap_set_attr(soap, "SupportedExportFileFormats", soap_tt__StringAttrList2s(soap, a->SupportedExportFileFormats), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_in_trc__Capabilities(struct soap *soap, const char *tag, struct trc__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "DynamicRecordings", 0);
		if (t)
		{
			if (!(a->DynamicRecordings = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynamicRecordings))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DynamicTracks", 0);
		if (t)
		{
			if (!(a->DynamicTracks = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynamicTracks))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2trc__EncodingTypes(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	{	const char *t = soap_attr_value(soap, "MaxRate", 0);
		if (t)
		{
			if (!(a->MaxRate = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxTotalRate", 0);
		if (t)
		{
			if (!(a->MaxTotalRate = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxTotalRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxRecordings", 0);
		if (t)
		{
			if (!(a->MaxRecordings = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxRecordings))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxRecordingJobs", 0);
		if (t)
		{
			if (!(a->MaxRecordingJobs = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxRecordingJobs))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Options", 0);
		if (t)
		{
			if (!(a->Options = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Options))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MetadataRecording", 0);
		if (t)
		{
			if (!(a->MetadataRecording = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MetadataRecording))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "SupportedExportFileFormats", 0), &a->SupportedExportFileFormats))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__Capabilities, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_new_trc__Capabilities(struct soap *soap, int n)
{
	struct trc__Capabilities *p;
	struct trc__Capabilities *a = (struct trc__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trc__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trc__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__Capabilities(struct soap *soap, const struct trc__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trc__Capabilities(soap, tag ? tag : "trc:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_get_trc__Capabilities(struct soap *soap, struct trc__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ReceiverState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverStateResponse(struct soap *soap, const struct _trv__GetReceiverStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReceiverStateInformation(soap, &a->ReceiverState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverStateResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverStateResponse), type))
		return soap->error;
	if (a->ReceiverState)
		soap_element_result(soap, "trv:ReceiverState");
	if (!a->ReceiverState)
	{	if (soap_element_nil(soap, "trv:ReceiverState"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ReceiverStateInformation(soap, "trv:ReceiverState", -1, &a->ReceiverState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_in__trv__GetReceiverStateResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverStateResponse *a, const char *type)
{
	size_t soap_flag_ReceiverState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiverStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverStateInformation(soap, "trv:ReceiverState", &a->ReceiverState, "tt:ReceiverStateInformation"))
				{	soap_flag_ReceiverState--;
					continue;
				}
			soap_check_result(soap, "trv:ReceiverState");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverStateResponse, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_new__trv__GetReceiverStateResponse(struct soap *soap, int n)
{
	struct _trv__GetReceiverStateResponse *p;
	struct _trv__GetReceiverStateResponse *a = (struct _trv__GetReceiverStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiverStateResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiverStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverStateResponse(struct soap *soap, const struct _trv__GetReceiverStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiverStateResponse(soap, tag ? tag : "trv:GetReceiverStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_get__trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverState(struct soap *soap, const struct _trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverState(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverState), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_nil(soap, "trv:ReceiverToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_in__trv__GetReceiverState(struct soap *soap, const char *tag, struct _trv__GetReceiverState *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiverState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverState, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_new__trv__GetReceiverState(struct soap *soap, int n)
{
	struct _trv__GetReceiverState *p;
	struct _trv__GetReceiverState *a = (struct _trv__GetReceiverState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiverState));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiverState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverState(struct soap *soap, const struct _trv__GetReceiverState *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiverState(soap, tag ? tag : "trv:GetReceiverState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_get__trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__SetReceiverModeResponse(struct soap *soap, const struct _trv__SetReceiverModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__SetReceiverModeResponse(struct soap *soap, const char *tag, int id, const struct _trv__SetReceiverModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__SetReceiverModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_in__trv__SetReceiverModeResponse(struct soap *soap, const char *tag, struct _trv__SetReceiverModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__SetReceiverModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__SetReceiverModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverModeResponse, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_new__trv__SetReceiverModeResponse(struct soap *soap, int n)
{
	struct _trv__SetReceiverModeResponse *p;
	struct _trv__SetReceiverModeResponse *a = (struct _trv__SetReceiverModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__SetReceiverModeResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__SetReceiverModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__SetReceiverModeResponse(struct soap *soap, const struct _trv__SetReceiverModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__SetReceiverModeResponse(soap, tag ? tag : "trv:SetReceiverModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_get__trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__SetReceiverModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_default_tt__ReceiverMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__SetReceiverMode(struct soap *soap, const struct _trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__SetReceiverMode(struct soap *soap, const char *tag, int id, const struct _trv__SetReceiverMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__SetReceiverMode), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_nil(soap, "trv:ReceiverToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "trv:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_in__trv__SetReceiverMode(struct soap *soap, const char *tag, struct _trv__SetReceiverMode *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__SetReceiverMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__SetReceiverMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReceiverMode(soap, "trv:Mode", &a->Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0 || soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverMode, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_new__trv__SetReceiverMode(struct soap *soap, int n)
{
	struct _trv__SetReceiverMode *p;
	struct _trv__SetReceiverMode *a = (struct _trv__SetReceiverMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__SetReceiverMode));
	for (p = a; p && n--; p++)
		soap_default__trv__SetReceiverMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__SetReceiverMode(struct soap *soap, const struct _trv__SetReceiverMode *a, const char *tag, const char *type)
{
	if (soap_out__trv__SetReceiverMode(soap, tag ? tag : "trv:SetReceiverMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_get__trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__ConfigureReceiverResponse(struct soap *soap, const struct _trv__ConfigureReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__ConfigureReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__ConfigureReceiverResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_in__trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, struct _trv__ConfigureReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__ConfigureReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__ConfigureReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiverResponse, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_new__trv__ConfigureReceiverResponse(struct soap *soap, int n)
{
	struct _trv__ConfigureReceiverResponse *p;
	struct _trv__ConfigureReceiverResponse *a = (struct _trv__ConfigureReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__ConfigureReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__ConfigureReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__ConfigureReceiverResponse(struct soap *soap, const struct _trv__ConfigureReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__ConfigureReceiverResponse(soap, tag ? tag : "trv:ConfigureReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_get__trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__ConfigureReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__ConfigureReceiver(struct soap *soap, const struct _trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__ConfigureReceiver(struct soap *soap, const char *tag, int id, const struct _trv__ConfigureReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__ConfigureReceiver), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_nil(soap, "trv:ReceiverToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "trv:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_in__trv__ConfigureReceiver(struct soap *soap, const char *tag, struct _trv__ConfigureReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__ConfigureReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__ConfigureReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0 || soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiver, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_new__trv__ConfigureReceiver(struct soap *soap, int n)
{
	struct _trv__ConfigureReceiver *p;
	struct _trv__ConfigureReceiver *a = (struct _trv__ConfigureReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__ConfigureReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__ConfigureReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__ConfigureReceiver(struct soap *soap, const struct _trv__ConfigureReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__ConfigureReceiver(soap, tag ? tag : "trv:ConfigureReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_get__trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__ConfigureReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__DeleteReceiverResponse(struct soap *soap, const struct _trv__DeleteReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__DeleteReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__DeleteReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__DeleteReceiverResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_in__trv__DeleteReceiverResponse(struct soap *soap, const char *tag, struct _trv__DeleteReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__DeleteReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__DeleteReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiverResponse, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_new__trv__DeleteReceiverResponse(struct soap *soap, int n)
{
	struct _trv__DeleteReceiverResponse *p;
	struct _trv__DeleteReceiverResponse *a = (struct _trv__DeleteReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__DeleteReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__DeleteReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__DeleteReceiverResponse(struct soap *soap, const struct _trv__DeleteReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__DeleteReceiverResponse(soap, tag ? tag : "trv:DeleteReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_get__trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__DeleteReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__DeleteReceiver(struct soap *soap, const struct _trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__DeleteReceiver(struct soap *soap, const char *tag, int id, const struct _trv__DeleteReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__DeleteReceiver), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_nil(soap, "trv:ReceiverToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_in__trv__DeleteReceiver(struct soap *soap, const char *tag, struct _trv__DeleteReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__DeleteReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__DeleteReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiver, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_new__trv__DeleteReceiver(struct soap *soap, int n)
{
	struct _trv__DeleteReceiver *p;
	struct _trv__DeleteReceiver *a = (struct _trv__DeleteReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__DeleteReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__DeleteReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__DeleteReceiver(struct soap *soap, const struct _trv__DeleteReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__DeleteReceiver(soap, tag ? tag : "trv:DeleteReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_get__trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__DeleteReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Receiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__CreateReceiverResponse(struct soap *soap, const struct _trv__CreateReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Receiver(soap, &a->Receiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__CreateReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__CreateReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__CreateReceiverResponse), type))
		return soap->error;
	if (a->Receiver)
		soap_element_result(soap, "trv:Receiver");
	if (!a->Receiver)
	{	if (soap_element_nil(soap, "trv:Receiver"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Receiver(soap, "trv:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_in__trv__CreateReceiverResponse(struct soap *soap, const char *tag, struct _trv__CreateReceiverResponse *a, const char *type)
{
	size_t soap_flag_Receiver = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__CreateReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__CreateReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Receiver(soap, "trv:Receiver", &a->Receiver, "tt:Receiver"))
				{	soap_flag_Receiver--;
					continue;
				}
			soap_check_result(soap, "trv:Receiver");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Receiver > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiverResponse, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_new__trv__CreateReceiverResponse(struct soap *soap, int n)
{
	struct _trv__CreateReceiverResponse *p;
	struct _trv__CreateReceiverResponse *a = (struct _trv__CreateReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__CreateReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__CreateReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__CreateReceiverResponse(struct soap *soap, const struct _trv__CreateReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__CreateReceiverResponse(soap, tag ? tag : "trv:CreateReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_get__trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__CreateReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__CreateReceiver(struct soap *soap, const struct _trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__CreateReceiver(struct soap *soap, const char *tag, int id, const struct _trv__CreateReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__CreateReceiver), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "trv:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_in__trv__CreateReceiver(struct soap *soap, const char *tag, struct _trv__CreateReceiver *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__CreateReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__CreateReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiver, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_new__trv__CreateReceiver(struct soap *soap, int n)
{
	struct _trv__CreateReceiver *p;
	struct _trv__CreateReceiver *a = (struct _trv__CreateReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__CreateReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__CreateReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__CreateReceiver(struct soap *soap, const struct _trv__CreateReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__CreateReceiver(soap, tag ? tag : "trv:CreateReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_get__trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__CreateReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Receiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverResponse(struct soap *soap, const struct _trv__GetReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Receiver(soap, &a->Receiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverResponse), type))
		return soap->error;
	if (a->Receiver)
		soap_element_result(soap, "trv:Receiver");
	if (!a->Receiver)
	{	if (soap_element_nil(soap, "trv:Receiver"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Receiver(soap, "trv:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_in__trv__GetReceiverResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverResponse *a, const char *type)
{
	size_t soap_flag_Receiver = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Receiver(soap, "trv:Receiver", &a->Receiver, "tt:Receiver"))
				{	soap_flag_Receiver--;
					continue;
				}
			soap_check_result(soap, "trv:Receiver");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Receiver > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverResponse, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_new__trv__GetReceiverResponse(struct soap *soap, int n)
{
	struct _trv__GetReceiverResponse *p;
	struct _trv__GetReceiverResponse *a = (struct _trv__GetReceiverResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiverResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiverResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverResponse(struct soap *soap, const struct _trv__GetReceiverResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiverResponse(soap, tag ? tag : "trv:GetReceiverResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_get__trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiver(struct soap *soap, const struct _trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiver(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiver), type))
		return soap->error;
	if (!a->ReceiverToken)
	{	if (soap_element_nil(soap, "trv:ReceiverToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, (char*const*)&a->ReceiverToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_in__trv__GetReceiver(struct soap *soap, const char *tag, struct _trv__GetReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", (char**)&a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiver, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_new__trv__GetReceiver(struct soap *soap, int n)
{
	struct _trv__GetReceiver *p;
	struct _trv__GetReceiver *a = (struct _trv__GetReceiver*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiver));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiver(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiver(struct soap *soap, const struct _trv__GetReceiver *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiver(soap, tag ? tag : "trv:GetReceiver", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_get__trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeReceivers = 0;
	a->Receivers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiversResponse(struct soap *soap, const struct _trv__GetReceiversResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Receivers)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceivers; i++)
		{
			soap_embedded(soap, a->Receivers + i, SOAP_TYPE_tt__Receiver);
			soap_serialize_tt__Receiver(soap, a->Receivers + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiversResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiversResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiversResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeReceivers");
	if (a->Receivers)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceivers; i++)
			if (soap_out_tt__Receiver(soap, "trv:Receivers", -1, a->Receivers + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_in__trv__GetReceiversResponse(struct soap *soap, const char *tag, struct _trv__GetReceiversResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Receivers = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiversResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiversResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trv:Receivers", 1, NULL))
			{	if (a->Receivers == NULL)
				{	if (soap_blist_Receivers == NULL)
						soap_blist_Receivers = soap_alloc_block(soap);
					a->Receivers = (struct tt__Receiver *)soap_push_block_max(soap, soap_blist_Receivers, sizeof(struct tt__Receiver));
					if (a->Receivers == NULL)
						return NULL;
					soap_default_tt__Receiver(soap, a->Receivers);
				}
				soap_revert(soap);
				if (soap_in_tt__Receiver(soap, "trv:Receivers", a->Receivers, "tt:Receiver"))
				{	a->__sizeReceivers++;
					a->Receivers = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeReceivers");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Receivers)
			soap_pop_block(soap, soap_blist_Receivers);
		if (a->__sizeReceivers)
		{	a->Receivers = (struct tt__Receiver *)soap_save_block(soap, soap_blist_Receivers, NULL, 1);
		}
		else
		{	a->Receivers = NULL;
			if (soap_blist_Receivers)
				soap_end_block(soap, soap_blist_Receivers);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiversResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiversResponse, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_new__trv__GetReceiversResponse(struct soap *soap, int n)
{
	struct _trv__GetReceiversResponse *p;
	struct _trv__GetReceiversResponse *a = (struct _trv__GetReceiversResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceiversResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceiversResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiversResponse(struct soap *soap, const struct _trv__GetReceiversResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceiversResponse(soap, tag ? tag : "trv:GetReceiversResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_get__trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceivers(struct soap *soap, const struct _trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceivers(struct soap *soap, const char *tag, int id, const struct _trv__GetReceivers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceivers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_in__trv__GetReceivers(struct soap *soap, const char *tag, struct _trv__GetReceivers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceivers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceivers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceivers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceivers, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_new__trv__GetReceivers(struct soap *soap, int n)
{
	struct _trv__GetReceivers *p;
	struct _trv__GetReceivers *a = (struct _trv__GetReceivers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetReceivers));
	for (p = a; p && n--; p++)
		soap_default__trv__GetReceivers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceivers(struct soap *soap, const struct _trv__GetReceivers *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetReceivers(soap, tag ? tag : "trv:GetReceivers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_get__trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trv__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotrv__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trv:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "trv:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotrv__Capabilities(soap, "trv:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrv__Capabilities(soap, "trv:Capabilities", &a->Capabilities, "trv:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trv:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__trv__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _trv__GetServiceCapabilitiesResponse *p;
	struct _trv__GetServiceCapabilitiesResponse *a = (struct _trv__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__trv__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trv__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetServiceCapabilitiesResponse(soap, tag ? tag : "trv:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetServiceCapabilities(struct soap *soap, const struct _trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trv__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_in__trv__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilities, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_new__trv__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _trv__GetServiceCapabilities *p;
	struct _trv__GetServiceCapabilities *a = (struct _trv__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trv__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__trv__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetServiceCapabilities(struct soap *soap, const struct _trv__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__trv__GetServiceCapabilities(soap, tag ? tag : "trv:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_get__trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trv__Capabilities(struct soap *soap, struct trv__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTP_USCOREMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	soap_default_int(soap, &a->SupportedReceivers);
	a->MaximumRTSPURILength = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trv__Capabilities(struct soap *soap, const struct trv__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trv__Capabilities(struct soap *soap, const char *tag, int id, const struct trv__Capabilities *a, const char *type)
{
	if (a->RTP_USCOREMulticast)
		soap_set_attr(soap, "RTP_Multicast", soap_xsd__boolean2s(soap, *a->RTP_USCOREMulticast), 1);
	if (a->RTP_USCORETCP)
		soap_set_attr(soap, "RTP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORETCP), 1);
	if (a->RTP_USCORERTSP_USCORETCP)
		soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	soap_set_attr(soap, "SupportedReceivers", soap_int2s(soap, a->SupportedReceivers), 1);
	if (a->MaximumRTSPURILength)
		soap_set_attr(soap, "MaximumRTSPURILength", soap_int2s(soap, *a->MaximumRTSPURILength), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trv__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_in_trv__Capabilities(struct soap *soap, const char *tag, struct trv__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trv__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trv__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "RTP_Multicast", 0);
		if (t)
		{
			if (!(a->RTP_USCOREMulticast = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCOREMulticast))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "SupportedReceivers", 1), &a->SupportedReceivers))
		return NULL;
	{	const char *t = soap_attr_value(soap, "MaximumRTSPURILength", 0);
		if (t)
		{
			if (!(a->MaximumRTSPURILength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumRTSPURILength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trv__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trv__Capabilities, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_new_trv__Capabilities(struct soap *soap, int n)
{
	struct trv__Capabilities *p;
	struct trv__Capabilities *a = (struct trv__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct trv__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_trv__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trv__Capabilities(struct soap *soap, const struct trv__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_trv__Capabilities(soap, tag ? tag : "trv:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_get_trv__Capabilities(struct soap *soap, struct trv__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trv__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZConfiguration = 0;
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const struct _tptz__GetCompatibleConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
		{
			soap_embedded(soap, a->PTZConfiguration + i, SOAP_TYPE_tt__PTZConfiguration);
			soap_serialize_tt__PTZConfiguration(soap, a->PTZConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetCompatibleConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZConfiguration");
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < (int)a->__sizePTZConfiguration; i++)
			if (soap_out_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, a->PTZConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetCompatibleConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetCompatibleConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetCompatibleConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
			{	if (a->PTZConfiguration == NULL)
				{	if (soap_blist_PTZConfiguration == NULL)
						soap_blist_PTZConfiguration = soap_alloc_block(soap);
					a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_push_block_max(soap, soap_blist_PTZConfiguration, sizeof(struct tt__PTZConfiguration));
					if (a->PTZConfiguration == NULL)
						return NULL;
					soap_default_tt__PTZConfiguration(soap, a->PTZConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", a->PTZConfiguration, "tt:PTZConfiguration"))
				{	a->__sizePTZConfiguration++;
					a->PTZConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZConfiguration)
			soap_pop_block(soap, soap_blist_PTZConfiguration);
		if (a->__sizePTZConfiguration)
		{	a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_save_block(soap, soap_blist_PTZConfiguration, NULL, 1);
		}
		else
		{	a->PTZConfiguration = NULL;
			if (soap_blist_PTZConfiguration)
				soap_end_block(soap, soap_blist_PTZConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetCompatibleConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(struct _tptz__GetCompatibleConfigurationsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_new__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, int n)
{
	struct _tptz__GetCompatibleConfigurationsResponse *p;
	struct _tptz__GetCompatibleConfigurationsResponse *a = (struct _tptz__GetCompatibleConfigurationsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetCompatibleConfigurationsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetCompatibleConfigurationsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const struct _tptz__GetCompatibleConfigurationsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetCompatibleConfigurationsResponse(soap, tag ? tag : "tptz:GetCompatibleConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, struct _tptz__GetCompatibleConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetCompatibleConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetCompatibleConfigurations(struct soap *soap, const struct _tptz__GetCompatibleConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, int id, const struct _tptz__GetCompatibleConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_in__tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, struct _tptz__GetCompatibleConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetCompatibleConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetCompatibleConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetCompatibleConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurations, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(struct _tptz__GetCompatibleConfigurations), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_new__tptz__GetCompatibleConfigurations(struct soap *soap, int n)
{
	struct _tptz__GetCompatibleConfigurations *p;
	struct _tptz__GetCompatibleConfigurations *a = (struct _tptz__GetCompatibleConfigurations*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetCompatibleConfigurations));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetCompatibleConfigurations(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetCompatibleConfigurations(struct soap *soap, const struct _tptz__GetCompatibleConfigurations *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetCompatibleConfigurations(soap, tag ? tag : "tptz:GetCompatibleConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_get__tptz__GetCompatibleConfigurations(struct soap *soap, struct _tptz__GetCompatibleConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetCompatibleConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetTourResponse(struct soap *soap, const struct _tptz__RemovePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTourResponse, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_new__tptz__RemovePresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__RemovePresetTourResponse *p;
	struct _tptz__RemovePresetTourResponse *a = (struct _tptz__RemovePresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetTourResponse(struct soap *soap, const struct _tptz__RemovePresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePresetTourResponse(soap, tag ? tag : "tptz:RemovePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetTour(struct soap *soap, const struct _tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTourToken)
	{	if (soap_element_nil(soap, "tptz:PresetTourToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_in__tptz__RemovePresetTour(struct soap *soap, const char *tag, struct _tptz__RemovePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTourToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTour, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_new__tptz__RemovePresetTour(struct soap *soap, int n)
{
	struct _tptz__RemovePresetTour *p;
	struct _tptz__RemovePresetTour *a = (struct _tptz__RemovePresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RemovePresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__RemovePresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetTour(struct soap *soap, const struct _tptz__RemovePresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RemovePresetTour(soap, tag ? tag : "tptz:RemovePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_get__tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__OperatePresetTourResponse(struct soap *soap, const struct _tptz__OperatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__OperatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__OperatePresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__OperatePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__OperatePresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTourResponse, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_new__tptz__OperatePresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__OperatePresetTourResponse *p;
	struct _tptz__OperatePresetTourResponse *a = (struct _tptz__OperatePresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__OperatePresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__OperatePresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__OperatePresetTourResponse(struct soap *soap, const struct _tptz__OperatePresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__OperatePresetTourResponse(soap, tag ? tag : "tptz:OperatePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
	soap_default_tt__PTZPresetTourOperation(soap, &a->Operation);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__OperatePresetTour(struct soap *soap, const struct _tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
	soap_embedded(soap, &a->Operation, SOAP_TYPE_tt__PTZPresetTourOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__OperatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTourToken)
	{	if (soap_element_nil(soap, "tptz:PresetTourToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	if (soap_out_tt__PTZPresetTourOperation(soap, "tptz:Operation", -1, &a->Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_in__tptz__OperatePresetTour(struct soap *soap, const char *tag, struct _tptz__OperatePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	size_t soap_flag_Operation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__OperatePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__OperatePresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap_flag_Operation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__PTZPresetTourOperation(soap, "tptz:Operation", &a->Operation, "tt:PTZPresetTourOperation"))
				{	soap_flag_Operation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTourToken > 0 || soap_flag_Operation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTour, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_new__tptz__OperatePresetTour(struct soap *soap, int n)
{
	struct _tptz__OperatePresetTour *p;
	struct _tptz__OperatePresetTour *a = (struct _tptz__OperatePresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__OperatePresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__OperatePresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__OperatePresetTour(struct soap *soap, const struct _tptz__OperatePresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__OperatePresetTour(soap, tag ? tag : "tptz:OperatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_get__tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ModifyPresetTourResponse(struct soap *soap, const struct _tptz__ModifyPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__ModifyPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_in__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ModifyPresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTourResponse, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_new__tptz__ModifyPresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__ModifyPresetTourResponse *p;
	struct _tptz__ModifyPresetTourResponse *a = (struct _tptz__ModifyPresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ModifyPresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__ModifyPresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ModifyPresetTourResponse(struct soap *soap, const struct _tptz__ModifyPresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ModifyPresetTourResponse(soap, tag ? tag : "tptz:ModifyPresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_get__tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ModifyPresetTour(struct soap *soap, const struct _tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PresetTour(soap, &a->PresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__ModifyPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTour)
	{	if (soap_element_nil(soap, "tptz:PresetTour"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_in__tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTour = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ModifyPresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ModifyPresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTour > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTour, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_new__tptz__ModifyPresetTour(struct soap *soap, int n)
{
	struct _tptz__ModifyPresetTour *p;
	struct _tptz__ModifyPresetTour *a = (struct _tptz__ModifyPresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__ModifyPresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__ModifyPresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ModifyPresetTour(struct soap *soap, const struct _tptz__ModifyPresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__ModifyPresetTour(soap, tag ? tag : "tptz:ModifyPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_get__tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__CreatePresetTourResponse(struct soap *soap, const struct _tptz__CreatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__CreatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTourResponse), type))
		return soap->error;
	if (a->PresetTourToken)
		soap_element_result(soap, "tptz:PresetTourToken");
	if (!a->PresetTourToken)
	{	if (soap_element_nil(soap, "tptz:PresetTourToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__CreatePresetTourResponse *a, const char *type)
{
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__CreatePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__CreatePresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			soap_check_result(soap, "tptz:PresetTourToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetTourToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTourResponse, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_new__tptz__CreatePresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__CreatePresetTourResponse *p;
	struct _tptz__CreatePresetTourResponse *a = (struct _tptz__CreatePresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__CreatePresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__CreatePresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__CreatePresetTourResponse(struct soap *soap, const struct _tptz__CreatePresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__CreatePresetTourResponse(soap, tag ? tag : "tptz:CreatePresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__CreatePresetTour(struct soap *soap, const struct _tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__CreatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_in__tptz__CreatePresetTour(struct soap *soap, const char *tag, struct _tptz__CreatePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__CreatePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__CreatePresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTour, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_new__tptz__CreatePresetTour(struct soap *soap, int n)
{
	struct _tptz__CreatePresetTour *p;
	struct _tptz__CreatePresetTour *a = (struct _tptz__CreatePresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__CreatePresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__CreatePresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__CreatePresetTour(struct soap *soap, const struct _tptz__CreatePresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__CreatePresetTour(soap, tag ? tag : "tptz:CreatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_get__tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourOptionsResponse(struct soap *soap, const struct _tptz__GetPresetTourOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "tptz:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "tptz:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", &a->Options, "tt:PTZPresetTourOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "tptz:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_new__tptz__GetPresetTourOptionsResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetTourOptionsResponse *p;
	struct _tptz__GetPresetTourOptionsResponse *a = (struct _tptz__GetPresetTourOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTourOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTourOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourOptionsResponse(struct soap *soap, const struct _tptz__GetPresetTourOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTourOptionsResponse(soap, tag ? tag : "tptz:GetPresetTourOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourOptions(struct soap *soap, const struct _tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptions), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptions *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTourOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptions, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_new__tptz__GetPresetTourOptions(struct soap *soap, int n)
{
	struct _tptz__GetPresetTourOptions *p;
	struct _tptz__GetPresetTourOptions *a = (struct _tptz__GetPresetTourOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTourOptions));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTourOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourOptions(struct soap *soap, const struct _tptz__GetPresetTourOptions *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTourOptions(soap, tag ? tag : "tptz:GetPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourResponse(struct soap *soap, const struct _tptz__GetPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PresetTour(soap, &a->PresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourResponse), type))
		return soap->error;
	if (a->PresetTour)
		soap_element_result(soap, "tptz:PresetTour");
	if (!a->PresetTour)
	{	if (soap_element_nil(soap, "tptz:PresetTour"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourResponse *a, const char *type)
{
	size_t soap_flag_PresetTour = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour--;
					continue;
				}
			soap_check_result(soap, "tptz:PresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetTour > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourResponse, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_new__tptz__GetPresetTourResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetTourResponse *p;
	struct _tptz__GetPresetTourResponse *a = (struct _tptz__GetPresetTourResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTourResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTourResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourResponse(struct soap *soap, const struct _tptz__GetPresetTourResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTourResponse(soap, tag ? tag : "tptz:GetPresetTourResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTour(struct soap *soap, const struct _tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTour), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->PresetTourToken)
	{	if (soap_element_nil(soap, "tptz:PresetTourToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, (char*const*)&a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_in__tptz__GetPresetTour(struct soap *soap, const char *tag, struct _tptz__GetPresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", (char**)&a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTourToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTour, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_new__tptz__GetPresetTour(struct soap *soap, int n)
{
	struct _tptz__GetPresetTour *p;
	struct _tptz__GetPresetTour *a = (struct _tptz__GetPresetTour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTour));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTour(struct soap *soap, const struct _tptz__GetPresetTour *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTour(soap, tag ? tag : "tptz:GetPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_get__tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePresetTour = 0;
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetToursResponse(struct soap *soap, const struct _tptz__GetPresetToursResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->PresetTour)
	{	int i;
		for (i = 0; i < (int)a->__sizePresetTour; i++)
		{
			soap_embedded(soap, a->PresetTour + i, SOAP_TYPE_tt__PresetTour);
			soap_serialize_tt__PresetTour(soap, a->PresetTour + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetToursResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetToursResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePresetTour");
	if (a->PresetTour)
	{	int i;
		for (i = 0; i < (int)a->__sizePresetTour; i++)
			if (soap_out_tt__PresetTour(soap, "tptz:PresetTour", -1, a->PresetTour + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_in__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetToursResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PresetTour = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetToursResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetToursResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PresetTour", 1, NULL))
			{	if (a->PresetTour == NULL)
				{	if (soap_blist_PresetTour == NULL)
						soap_blist_PresetTour = soap_alloc_block(soap);
					a->PresetTour = (struct tt__PresetTour *)soap_push_block_max(soap, soap_blist_PresetTour, sizeof(struct tt__PresetTour));
					if (a->PresetTour == NULL)
						return NULL;
					soap_default_tt__PresetTour(soap, a->PresetTour);
				}
				soap_revert(soap);
				if (soap_in_tt__PresetTour(soap, "tptz:PresetTour", a->PresetTour, "tt:PresetTour"))
				{	a->__sizePresetTour++;
					a->PresetTour = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PresetTour)
			soap_pop_block(soap, soap_blist_PresetTour);
		if (a->__sizePresetTour)
		{	a->PresetTour = (struct tt__PresetTour *)soap_save_block(soap, soap_blist_PresetTour, NULL, 1);
		}
		else
		{	a->PresetTour = NULL;
			if (soap_blist_PresetTour)
				soap_end_block(soap, soap_blist_PresetTour);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetToursResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetToursResponse, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_new__tptz__GetPresetToursResponse(struct soap *soap, int n)
{
	struct _tptz__GetPresetToursResponse *p;
	struct _tptz__GetPresetToursResponse *a = (struct _tptz__GetPresetToursResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetToursResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetToursResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetToursResponse(struct soap *soap, const struct _tptz__GetPresetToursResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetToursResponse(soap, tag ? tag : "tptz:GetPresetToursResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_get__tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTours(struct soap *soap, const struct _tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTours(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTours *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTours), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_in__tptz__GetPresetTours(struct soap *soap, const char *tag, struct _tptz__GetPresetTours *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTours *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTours(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTours *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTours, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_new__tptz__GetPresetTours(struct soap *soap, int n)
{
	struct _tptz__GetPresetTours *p;
	struct _tptz__GetPresetTours *a = (struct _tptz__GetPresetTours*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__GetPresetTours));
	for (p = a; p && n--; p++)
		soap_default__tptz__GetPresetTours(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTours(struct soap *soap, const struct _tptz__GetPresetTours *a, const char *tag, const char *type)
{
	if (soap_out__tptz__GetPresetTours(soap, tag ? tag : "tptz:GetPresetTours", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_get__tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__StopResponse(struct soap *soap, const struct _tptz__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__StopResponse(struct soap *soap, const char *tag, int id, const struct _tptz__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_in__tptz__StopResponse(struct soap *soap, const char *tag, struct _tptz__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__StopResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__StopResponse, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_new__tptz__StopResponse(struct soap *soap, int n)
{
	struct _tptz__StopResponse *p;
	struct _tptz__StopResponse *a = (struct _tptz__StopResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__StopResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__StopResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__StopResponse(struct soap *soap, const struct _tptz__StopResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__StopResponse(soap, tag ? tag : "tptz:StopResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_get__tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__Stop(struct soap *soap, struct _tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__Stop(struct soap *soap, const struct _tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerToxsd__boolean(soap, &a->PanTilt);
	soap_serialize_PointerToxsd__boolean(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__Stop(struct soap *soap, const char *tag, int id, const struct _tptz__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__Stop), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tptz:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tptz:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_in__tptz__Stop(struct soap *soap, const char *tag, struct _tptz__Stop *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__Stop(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tptz:PanTilt", &a->PanTilt, "xsd:boolean"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tptz:Zoom", &a->Zoom, "xsd:boolean"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__Stop, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_new__tptz__Stop(struct soap *soap, int n)
{
	struct _tptz__Stop *p;
	struct _tptz__Stop *a = (struct _tptz__Stop*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__Stop));
	for (p = a; p && n--; p++)
		soap_default__tptz__Stop(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__Stop(struct soap *soap, const struct _tptz__Stop *a, const char *tag, const char *type)
{
	if (soap_out__tptz__Stop(soap, tag ? tag : "tptz:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_get__tptz__Stop(struct soap *soap, struct _tptz__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__AbsoluteMoveResponse(struct soap *soap, const struct _tptz__AbsoluteMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__AbsoluteMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_in__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, struct _tptz__AbsoluteMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__AbsoluteMoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMoveResponse, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_new__tptz__AbsoluteMoveResponse(struct soap *soap, int n)
{
	struct _tptz__AbsoluteMoveResponse *p;
	struct _tptz__AbsoluteMoveResponse *a = (struct _tptz__AbsoluteMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__AbsoluteMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__AbsoluteMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__AbsoluteMoveResponse(struct soap *soap, const struct _tptz__AbsoluteMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__AbsoluteMoveResponse(soap, tag ? tag : "tptz:AbsoluteMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_get__tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Position = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__AbsoluteMove(struct soap *soap, const struct _tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, const struct _tptz__AbsoluteMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_nil(soap, "tptz:Position"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZVector(soap, "tptz:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_in__tptz__AbsoluteMove(struct soap *soap, const char *tag, struct _tptz__AbsoluteMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__AbsoluteMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__AbsoluteMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tptz:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_Position > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMove, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_new__tptz__AbsoluteMove(struct soap *soap, int n)
{
	struct _tptz__AbsoluteMove *p;
	struct _tptz__AbsoluteMove *a = (struct _tptz__AbsoluteMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__AbsoluteMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__AbsoluteMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__AbsoluteMove(struct soap *soap, const struct _tptz__AbsoluteMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__AbsoluteMove(soap, tag ? tag : "tptz:AbsoluteMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_get__tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RelativeMoveResponse(struct soap *soap, const struct _tptz__RelativeMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RelativeMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_in__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, struct _tptz__RelativeMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RelativeMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RelativeMoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMoveResponse, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_new__tptz__RelativeMoveResponse(struct soap *soap, int n)
{
	struct _tptz__RelativeMoveResponse *p;
	struct _tptz__RelativeMoveResponse *a = (struct _tptz__RelativeMoveResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RelativeMoveResponse));
	for (p = a; p && n--; p++)
		soap_default__tptz__RelativeMoveResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RelativeMoveResponse(struct soap *soap, const struct _tptz__RelativeMoveResponse *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RelativeMoveResponse(soap, tag ? tag : "tptz:RelativeMoveResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_get__tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Translation = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RelativeMove(struct soap *soap, const struct _tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &a->Translation);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMove(struct soap *soap, const char *tag, int id, const struct _tptz__RelativeMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMove), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "tptz:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	if (!a->Translation)
	{	if (soap_element_nil(soap, "tptz:Translation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZVector(soap, "tptz:Translation", -1, &a->Translation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_in__tptz__RelativeMove(struct soap *soap, const char *tag, struct _tptz__RelativeMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Translation = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RelativeMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RelativeMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Translation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tptz:Translation", &a->Translation, "tt:PTZVector"))
				{	soap_flag_Translation--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_Translation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMove, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_new__tptz__RelativeMove(struct soap *soap, int n)
{
	struct _tptz__RelativeMove *p;
	struct _tptz__RelativeMove *a = (struct _tptz__RelativeMove*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tptz__RelativeMove));
	for (p = a; p && n--; p++)
		soap_default__tptz__RelativeMove(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RelativeMove(struct soap *soap, const struct _tptz__RelativeMove *a, const char *tag, const char *type)
{
	if (soap_out__tptz__RelativeMove(soap, tag ? tag : "tptz:RelativeMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_get__tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
