/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


static const struct soap_code_map soap_codes_tt__ReverseMode[] =
{	{ (LONG64)tt__ReverseMode__OFF, "OFF" },
	{ (LONG64)tt__ReverseMode__ON, "ON" },
	{ (LONG64)tt__ReverseMode__AUTO, "AUTO" },
	{ (LONG64)tt__ReverseMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReverseMode2s(struct soap *soap, enum tt__ReverseMode n)
{	const char *s = soap_code_str(soap_codes_tt__ReverseMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode(struct soap *soap, const char *tag, int id, const enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseMode), type) || soap_send(soap, soap_tt__ReverseMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReverseMode(struct soap *soap, const char *s, enum tt__ReverseMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ReverseMode, s);
	if (map)
		*a = (enum tt__ReverseMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ReverseMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_in_tt__ReverseMode(struct soap *soap, const char *tag, enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ReverseMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__ReverseMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__ReverseMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_new_tt__ReverseMode(struct soap *soap, int n)
{
	enum tt__ReverseMode *p;
	enum tt__ReverseMode *a = (enum tt__ReverseMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ReverseMode));
	for (p = a; p && n--; p++)
		soap_default_tt__ReverseMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseMode(struct soap *soap, const enum tt__ReverseMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseMode(soap, tag ? tag : "tt:ReverseMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_get_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__EFlipMode[] =
{	{ (LONG64)tt__EFlipMode__OFF, "OFF" },
	{ (LONG64)tt__EFlipMode__ON, "ON" },
	{ (LONG64)tt__EFlipMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__EFlipMode2s(struct soap *soap, enum tt__EFlipMode n)
{	const char *s = soap_code_str(soap_codes_tt__EFlipMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode(struct soap *soap, const char *tag, int id, const enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipMode), type) || soap_send(soap, soap_tt__EFlipMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__EFlipMode(struct soap *soap, const char *s, enum tt__EFlipMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__EFlipMode, s);
	if (map)
		*a = (enum tt__EFlipMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__EFlipMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_in_tt__EFlipMode(struct soap *soap, const char *tag, enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__EFlipMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__EFlipMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__EFlipMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_new_tt__EFlipMode(struct soap *soap, int n)
{
	enum tt__EFlipMode *p;
	enum tt__EFlipMode *a = (enum tt__EFlipMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__EFlipMode));
	for (p = a; p && n--; p++)
		soap_default_tt__EFlipMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipMode(struct soap *soap, const enum tt__EFlipMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipMode(soap, tag ? tag : "tt:EFlipMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_get_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DigitalIdleState[] =
{	{ (LONG64)tt__DigitalIdleState__closed, "closed" },
	{ (LONG64)tt__DigitalIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DigitalIdleState2s(struct soap *soap, enum tt__DigitalIdleState n)
{	const char *s = soap_code_str(soap_codes_tt__DigitalIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalIdleState(struct soap *soap, const char *tag, int id, const enum tt__DigitalIdleState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DigitalIdleState), type) || soap_send(soap, soap_tt__DigitalIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DigitalIdleState(struct soap *soap, const char *s, enum tt__DigitalIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DigitalIdleState, s);
	if (map)
		*a = (enum tt__DigitalIdleState)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DigitalIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DigitalIdleState * SOAP_FMAC4 soap_in_tt__DigitalIdleState(struct soap *soap, const char *tag, enum tt__DigitalIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DigitalIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__DigitalIdleState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__DigitalIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalIdleState, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DigitalIdleState * SOAP_FMAC4 soap_new_tt__DigitalIdleState(struct soap *soap, int n)
{
	enum tt__DigitalIdleState *p;
	enum tt__DigitalIdleState *a = (enum tt__DigitalIdleState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DigitalIdleState));
	for (p = a; p && n--; p++)
		soap_default_tt__DigitalIdleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DigitalIdleState(struct soap *soap, const enum tt__DigitalIdleState *a, const char *tag, const char *type)
{
	if (soap_out_tt__DigitalIdleState(soap, tag ? tag : "tt:DigitalIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DigitalIdleState * SOAP_FMAC4 soap_get_tt__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayMode[] =
{	{ (LONG64)tt__RelayMode__Monostable, "Monostable" },
	{ (LONG64)tt__RelayMode__Bistable, "Bistable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayMode2s(struct soap *soap, enum tt__RelayMode n)
{	const char *s = soap_code_str(soap_codes_tt__RelayMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayMode(struct soap *soap, const char *tag, int id, const enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayMode), type) || soap_send(soap, soap_tt__RelayMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayMode(struct soap *soap, const char *s, enum tt__RelayMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayMode, s);
	if (map)
		*a = (enum tt__RelayMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_in_tt__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__RelayMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayMode, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_new_tt__RelayMode(struct soap *soap, int n)
{
	enum tt__RelayMode *p;
	enum tt__RelayMode *a = (enum tt__RelayMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayMode));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayMode(struct soap *soap, const enum tt__RelayMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayMode(soap, tag ? tag : "tt:RelayMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_get_tt__RelayMode(struct soap *soap, enum tt__RelayMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayIdleState[] =
{	{ (LONG64)tt__RelayIdleState__closed, "closed" },
	{ (LONG64)tt__RelayIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayIdleState2s(struct soap *soap, enum tt__RelayIdleState n)
{	const char *s = soap_code_str(soap_codes_tt__RelayIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayIdleState(struct soap *soap, const char *tag, int id, const enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayIdleState), type) || soap_send(soap, soap_tt__RelayIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayIdleState(struct soap *soap, const char *s, enum tt__RelayIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayIdleState, s);
	if (map)
		*a = (enum tt__RelayIdleState)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_in_tt__RelayIdleState(struct soap *soap, const char *tag, enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayIdleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__RelayIdleState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayIdleState, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_new_tt__RelayIdleState(struct soap *soap, int n)
{
	enum tt__RelayIdleState *p;
	enum tt__RelayIdleState *a = (enum tt__RelayIdleState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayIdleState));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayIdleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayIdleState(struct soap *soap, const enum tt__RelayIdleState *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayIdleState(soap, tag ? tag : "tt:RelayIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_get_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayLogicalState[] =
{	{ (LONG64)tt__RelayLogicalState__active, "active" },
	{ (LONG64)tt__RelayLogicalState__inactive, "inactive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayLogicalState2s(struct soap *soap, enum tt__RelayLogicalState n)
{	const char *s = soap_code_str(soap_codes_tt__RelayLogicalState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayLogicalState(struct soap *soap, const char *tag, int id, const enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayLogicalState), type) || soap_send(soap, soap_tt__RelayLogicalState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayLogicalState(struct soap *soap, const char *s, enum tt__RelayLogicalState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayLogicalState, s);
	if (map)
		*a = (enum tt__RelayLogicalState)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayLogicalState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_in_tt__RelayLogicalState(struct soap *soap, const char *tag, enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayLogicalState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__RelayLogicalState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayLogicalState, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_new_tt__RelayLogicalState(struct soap *soap, int n)
{
	enum tt__RelayLogicalState *p;
	enum tt__RelayLogicalState *a = (enum tt__RelayLogicalState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayLogicalState));
	for (p = a; p && n--; p++)
		soap_default_tt__RelayLogicalState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayLogicalState(struct soap *soap, const enum tt__RelayLogicalState *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayLogicalState(soap, tag ? tag : "tt:RelayLogicalState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_get_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayLogicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__UserLevel[] =
{	{ (LONG64)tt__UserLevel__Administrator, "Administrator" },
	{ (LONG64)tt__UserLevel__Operator, "Operator" },
	{ (LONG64)tt__UserLevel__User, "User" },
	{ (LONG64)tt__UserLevel__Anonymous, "Anonymous" },
	{ (LONG64)tt__UserLevel__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__UserLevel2s(struct soap *soap, enum tt__UserLevel n)
{	const char *s = soap_code_str(soap_codes_tt__UserLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserLevel(struct soap *soap, const char *tag, int id, const enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserLevel), type) || soap_send(soap, soap_tt__UserLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__UserLevel(struct soap *soap, const char *s, enum tt__UserLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__UserLevel, s);
	if (map)
		*a = (enum tt__UserLevel)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__UserLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_in_tt__UserLevel(struct soap *soap, const char *tag, enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__UserLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__UserLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserLevel, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_new_tt__UserLevel(struct soap *soap, int n)
{
	enum tt__UserLevel *p;
	enum tt__UserLevel *a = (enum tt__UserLevel*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__UserLevel));
	for (p = a; p && n--; p++)
		soap_default_tt__UserLevel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserLevel(struct soap *soap, const enum tt__UserLevel *a, const char *tag, const char *type)
{
	if (soap_out_tt__UserLevel(soap, tag ? tag : "tt:UserLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_get_tt__UserLevel(struct soap *soap, enum tt__UserLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SetDateTimeType[] =
{	{ (LONG64)tt__SetDateTimeType__Manual, "Manual" },
	{ (LONG64)tt__SetDateTimeType__NTP, "NTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SetDateTimeType2s(struct soap *soap, enum tt__SetDateTimeType n)
{	const char *s = soap_code_str(soap_codes_tt__SetDateTimeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SetDateTimeType(struct soap *soap, const char *tag, int id, const enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SetDateTimeType), type) || soap_send(soap, soap_tt__SetDateTimeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SetDateTimeType(struct soap *soap, const char *s, enum tt__SetDateTimeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SetDateTimeType, s);
	if (map)
		*a = (enum tt__SetDateTimeType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SetDateTimeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_in_tt__SetDateTimeType(struct soap *soap, const char *tag, enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SetDateTimeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__SetDateTimeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SetDateTimeType, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_new_tt__SetDateTimeType(struct soap *soap, int n)
{
	enum tt__SetDateTimeType *p;
	enum tt__SetDateTimeType *a = (enum tt__SetDateTimeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SetDateTimeType));
	for (p = a; p && n--; p++)
		soap_default_tt__SetDateTimeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SetDateTimeType(struct soap *soap, const enum tt__SetDateTimeType *a, const char *tag, const char *type)
{
	if (soap_out_tt__SetDateTimeType(soap, tag ? tag : "tt:SetDateTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_get_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SetDateTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__FactoryDefaultType[] =
{	{ (LONG64)tt__FactoryDefaultType__Hard, "Hard" },
	{ (LONG64)tt__FactoryDefaultType__Soft, "Soft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__FactoryDefaultType2s(struct soap *soap, enum tt__FactoryDefaultType n)
{	const char *s = soap_code_str(soap_codes_tt__FactoryDefaultType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FactoryDefaultType(struct soap *soap, const char *tag, int id, const enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FactoryDefaultType), type) || soap_send(soap, soap_tt__FactoryDefaultType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__FactoryDefaultType(struct soap *soap, const char *s, enum tt__FactoryDefaultType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__FactoryDefaultType, s);
	if (map)
		*a = (enum tt__FactoryDefaultType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__FactoryDefaultType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_in_tt__FactoryDefaultType(struct soap *soap, const char *tag, enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__FactoryDefaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__FactoryDefaultType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FactoryDefaultType, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_new_tt__FactoryDefaultType(struct soap *soap, int n)
{
	enum tt__FactoryDefaultType *p;
	enum tt__FactoryDefaultType *a = (enum tt__FactoryDefaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__FactoryDefaultType));
	for (p = a; p && n--; p++)
		soap_default_tt__FactoryDefaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FactoryDefaultType(struct soap *soap, const enum tt__FactoryDefaultType *a, const char *tag, const char *type)
{
	if (soap_out_tt__FactoryDefaultType(soap, tag ? tag : "tt:FactoryDefaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_get_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FactoryDefaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SystemLogType[] =
{	{ (LONG64)tt__SystemLogType__System, "System" },
	{ (LONG64)tt__SystemLogType__Access, "Access" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SystemLogType2s(struct soap *soap, enum tt__SystemLogType n)
{	const char *s = soap_code_str(soap_codes_tt__SystemLogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogType(struct soap *soap, const char *tag, int id, const enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogType), type) || soap_send(soap, soap_tt__SystemLogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SystemLogType(struct soap *soap, const char *s, enum tt__SystemLogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SystemLogType, s);
	if (map)
		*a = (enum tt__SystemLogType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SystemLogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_in_tt__SystemLogType(struct soap *soap, const char *tag, enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SystemLogType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__SystemLogType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__SystemLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogType, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_new_tt__SystemLogType(struct soap *soap, int n)
{
	enum tt__SystemLogType *p;
	enum tt__SystemLogType *a = (enum tt__SystemLogType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SystemLogType));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLogType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogType(struct soap *soap, const enum tt__SystemLogType *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogType(soap, tag ? tag : "tt:SystemLogType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_get_tt__SystemLogType(struct soap *soap, enum tt__SystemLogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__CapabilityCategory[] =
{	{ (LONG64)tt__CapabilityCategory__All, "All" },
	{ (LONG64)tt__CapabilityCategory__Analytics, "Analytics" },
	{ (LONG64)tt__CapabilityCategory__Device, "Device" },
	{ (LONG64)tt__CapabilityCategory__Events, "Events" },
	{ (LONG64)tt__CapabilityCategory__Imaging, "Imaging" },
	{ (LONG64)tt__CapabilityCategory__Media, "Media" },
	{ (LONG64)tt__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__CapabilityCategory2s(struct soap *soap, enum tt__CapabilityCategory n)
{	const char *s = soap_code_str(soap_codes_tt__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilityCategory), type) || soap_send(soap, soap_tt__CapabilityCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__CapabilityCategory(struct soap *soap, const char *s, enum tt__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__CapabilityCategory, s);
	if (map)
		*a = (enum tt__CapabilityCategory)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_in_tt__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__CapabilityCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__CapabilityCategory(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_new_tt__CapabilityCategory(struct soap *soap, int n)
{
	enum tt__CapabilityCategory *p;
	enum tt__CapabilityCategory *a = (enum tt__CapabilityCategory*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__CapabilityCategory));
	for (p = a; p && n--; p++)
		soap_default_tt__CapabilityCategory(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilityCategory(struct soap *soap, const enum tt__CapabilityCategory *a, const char *tag, const char *type)
{
	if (soap_out_tt__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_get_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11AuthAndMangementSuite[] =
{	{ (LONG64)tt__Dot11AuthAndMangementSuite__None, "None" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__Dot1X, "Dot1X" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__PSK, "PSK" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11AuthAndMangementSuite2s(struct soap *soap, enum tt__Dot11AuthAndMangementSuite n)
{	const char *s = soap_code_str(soap_codes_tt__Dot11AuthAndMangementSuite, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const enum tt__Dot11AuthAndMangementSuite *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite), type) || soap_send(soap, soap_tt__Dot11AuthAndMangementSuite2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *s, enum tt__Dot11AuthAndMangementSuite *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11AuthAndMangementSuite, s);
	if (map)
		*a = (enum tt__Dot11AuthAndMangementSuite)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11AuthAndMangementSuite)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_in_tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, enum tt__Dot11AuthAndMangementSuite *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11AuthAndMangementSuite *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Dot11AuthAndMangementSuite(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11AuthAndMangementSuite *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_new_tt__Dot11AuthAndMangementSuite(struct soap *soap, int n)
{
	enum tt__Dot11AuthAndMangementSuite *p;
	enum tt__Dot11AuthAndMangementSuite *a = (enum tt__Dot11AuthAndMangementSuite*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11AuthAndMangementSuite));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11AuthAndMangementSuite(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AuthAndMangementSuite(struct soap *soap, const enum tt__Dot11AuthAndMangementSuite *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag ? tag : "tt:Dot11AuthAndMangementSuite", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_get_tt__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11SignalStrength[] =
{	{ (LONG64)tt__Dot11SignalStrength__None, "None" },
	{ (LONG64)tt__Dot11SignalStrength__Very_x0020Bad, "Very Bad" },
	{ (LONG64)tt__Dot11SignalStrength__Bad, "Bad" },
	{ (LONG64)tt__Dot11SignalStrength__Good, "Good" },
	{ (LONG64)tt__Dot11SignalStrength__Very_x0020Good, "Very Good" },
	{ (LONG64)tt__Dot11SignalStrength__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SignalStrength2s(struct soap *soap, enum tt__Dot11SignalStrength n)
{	const char *s = soap_code_str(soap_codes_tt__Dot11SignalStrength, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SignalStrength(struct soap *soap, const char *tag, int id, const enum tt__Dot11SignalStrength *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SignalStrength), type) || soap_send(soap, soap_tt__Dot11SignalStrength2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SignalStrength(struct soap *soap, const char *s, enum tt__Dot11SignalStrength *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SignalStrength, s);
	if (map)
		*a = (enum tt__Dot11SignalStrength)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SignalStrength)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_in_tt__Dot11SignalStrength(struct soap *soap, const char *tag, enum tt__Dot11SignalStrength *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11SignalStrength *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Dot11SignalStrength(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SignalStrength *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SignalStrength, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_new_tt__Dot11SignalStrength(struct soap *soap, int n)
{
	enum tt__Dot11SignalStrength *p;
	enum tt__Dot11SignalStrength *a = (enum tt__Dot11SignalStrength*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11SignalStrength));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11SignalStrength(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SignalStrength(struct soap *soap, const enum tt__Dot11SignalStrength *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SignalStrength(soap, tag ? tag : "tt:Dot11SignalStrength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_get_tt__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11Cipher[] =
{	{ (LONG64)tt__Dot11Cipher__CCMP, "CCMP" },
	{ (LONG64)tt__Dot11Cipher__TKIP, "TKIP" },
	{ (LONG64)tt__Dot11Cipher__Any, "Any" },
	{ (LONG64)tt__Dot11Cipher__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11Cipher2s(struct soap *soap, enum tt__Dot11Cipher n)
{	const char *s = soap_code_str(soap_codes_tt__Dot11Cipher, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Cipher(struct soap *soap, const char *tag, int id, const enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Cipher), type) || soap_send(soap, soap_tt__Dot11Cipher2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11Cipher(struct soap *soap, const char *s, enum tt__Dot11Cipher *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11Cipher, s);
	if (map)
		*a = (enum tt__Dot11Cipher)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11Cipher)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_in_tt__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11Cipher *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Dot11Cipher(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11Cipher *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_new_tt__Dot11Cipher(struct soap *soap, int n)
{
	enum tt__Dot11Cipher *p;
	enum tt__Dot11Cipher *a = (enum tt__Dot11Cipher*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11Cipher));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11Cipher(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Cipher(struct soap *soap, const enum tt__Dot11Cipher *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Cipher(soap, tag ? tag : "tt:Dot11Cipher", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_get_tt__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11SecurityMode[] =
{	{ (LONG64)tt__Dot11SecurityMode__None, "None" },
	{ (LONG64)tt__Dot11SecurityMode__WEP, "WEP" },
	{ (LONG64)tt__Dot11SecurityMode__PSK, "PSK" },
	{ (LONG64)tt__Dot11SecurityMode__Dot1X, "Dot1X" },
	{ (LONG64)tt__Dot11SecurityMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SecurityMode2s(struct soap *soap, enum tt__Dot11SecurityMode n)
{	const char *s = soap_code_str(soap_codes_tt__Dot11SecurityMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityMode), type) || soap_send(soap, soap_tt__Dot11SecurityMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SecurityMode(struct soap *soap, const char *s, enum tt__Dot11SecurityMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SecurityMode, s);
	if (map)
		*a = (enum tt__Dot11SecurityMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SecurityMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_in_tt__Dot11SecurityMode(struct soap *soap, const char *tag, enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11SecurityMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Dot11SecurityMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SecurityMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityMode, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_new_tt__Dot11SecurityMode(struct soap *soap, int n)
{
	enum tt__Dot11SecurityMode *p;
	enum tt__Dot11SecurityMode *a = (enum tt__Dot11SecurityMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11SecurityMode));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11SecurityMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityMode(struct soap *soap, const enum tt__Dot11SecurityMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SecurityMode(soap, tag ? tag : "tt:Dot11SecurityMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_get_tt__Dot11SecurityMode(struct soap *soap, enum tt__Dot11SecurityMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11StationMode[] =
{	{ (LONG64)tt__Dot11StationMode__Ad_hoc, "Ad-hoc" },
	{ (LONG64)tt__Dot11StationMode__Infrastructure, "Infrastructure" },
	{ (LONG64)tt__Dot11StationMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11StationMode2s(struct soap *soap, enum tt__Dot11StationMode n)
{	const char *s = soap_code_str(soap_codes_tt__Dot11StationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11StationMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11StationMode), type) || soap_send(soap, soap_tt__Dot11StationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11StationMode(struct soap *soap, const char *s, enum tt__Dot11StationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11StationMode, s);
	if (map)
		*a = (enum tt__Dot11StationMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11StationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_in_tt__Dot11StationMode(struct soap *soap, const char *tag, enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11StationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Dot11StationMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11StationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11StationMode, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_new_tt__Dot11StationMode(struct soap *soap, int n)
{
	enum tt__Dot11StationMode *p;
	enum tt__Dot11StationMode *a = (enum tt__Dot11StationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11StationMode));
	for (p = a; p && n--; p++)
		soap_default_tt__Dot11StationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11StationMode(struct soap *soap, const enum tt__Dot11StationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11StationMode(soap, tag ? tag : "tt:Dot11StationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_get_tt__Dot11StationMode(struct soap *soap, enum tt__Dot11StationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11StationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DynamicDNSType[] =
{	{ (LONG64)tt__DynamicDNSType__NoUpdate, "NoUpdate" },
	{ (LONG64)tt__DynamicDNSType__ClientUpdates, "ClientUpdates" },
	{ (LONG64)tt__DynamicDNSType__ServerUpdates, "ServerUpdates" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DynamicDNSType2s(struct soap *soap, enum tt__DynamicDNSType n)
{	const char *s = soap_code_str(soap_codes_tt__DynamicDNSType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSType(struct soap *soap, const char *tag, int id, const enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSType), type) || soap_send(soap, soap_tt__DynamicDNSType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DynamicDNSType(struct soap *soap, const char *s, enum tt__DynamicDNSType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DynamicDNSType, s);
	if (map)
		*a = (enum tt__DynamicDNSType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DynamicDNSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_in_tt__DynamicDNSType(struct soap *soap, const char *tag, enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DynamicDNSType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__DynamicDNSType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSType, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_new_tt__DynamicDNSType(struct soap *soap, int n)
{
	enum tt__DynamicDNSType *p;
	enum tt__DynamicDNSType *a = (enum tt__DynamicDNSType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DynamicDNSType));
	for (p = a; p && n--; p++)
		soap_default_tt__DynamicDNSType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSType(struct soap *soap, const enum tt__DynamicDNSType *a, const char *tag, const char *type)
{
	if (soap_out_tt__DynamicDNSType(soap, tag ? tag : "tt:DynamicDNSType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_get_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPAddressFilterType[] =
{	{ (LONG64)tt__IPAddressFilterType__Allow, "Allow" },
	{ (LONG64)tt__IPAddressFilterType__Deny, "Deny" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPAddressFilterType2s(struct soap *soap, enum tt__IPAddressFilterType n)
{	const char *s = soap_code_str(soap_codes_tt__IPAddressFilterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterType(struct soap *soap, const char *tag, int id, const enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterType), type) || soap_send(soap, soap_tt__IPAddressFilterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPAddressFilterType(struct soap *soap, const char *s, enum tt__IPAddressFilterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPAddressFilterType, s);
	if (map)
		*a = (enum tt__IPAddressFilterType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPAddressFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_in_tt__IPAddressFilterType(struct soap *soap, const char *tag, enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPAddressFilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__IPAddressFilterType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterType, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_new_tt__IPAddressFilterType(struct soap *soap, int n)
{
	enum tt__IPAddressFilterType *p;
	enum tt__IPAddressFilterType *a = (enum tt__IPAddressFilterType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPAddressFilterType));
	for (p = a; p && n--; p++)
		soap_default_tt__IPAddressFilterType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterType(struct soap *soap, const enum tt__IPAddressFilterType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddressFilterType(soap, tag ? tag : "tt:IPAddressFilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_get_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	{ (LONG64)tt__IPType__IPv4, "IPv4" },
	{ (LONG64)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__IPType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_new_tt__IPType(struct soap *soap, int n)
{
	enum tt__IPType *p;
	enum tt__IPType *a = (enum tt__IPType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPType));
	for (p = a; p && n--; p++)
		soap_default_tt__IPType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPType(soap, tag ? tag : "tt:IPType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__NetworkHostType[] =
{	{ (LONG64)tt__NetworkHostType__IPv4, "IPv4" },
	{ (LONG64)tt__NetworkHostType__IPv6, "IPv6" },
	{ (LONG64)tt__NetworkHostType__DNS, "DNS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkHostType2s(struct soap *soap, enum tt__NetworkHostType n)
{	const char *s = soap_code_str(soap_codes_tt__NetworkHostType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostType(struct soap *soap, const char *tag, int id, const enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostType), type) || soap_send(soap, soap_tt__NetworkHostType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkHostType(struct soap *soap, const char *s, enum tt__NetworkHostType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkHostType, s);
	if (map)
		*a = (enum tt__NetworkHostType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkHostType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_in_tt__NetworkHostType(struct soap *soap, const char *tag, enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkHostType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__NetworkHostType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostType, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_new_tt__NetworkHostType(struct soap *soap, int n)
{
	enum tt__NetworkHostType *p;
	enum tt__NetworkHostType *a = (enum tt__NetworkHostType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__NetworkHostType));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkHostType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostType(struct soap *soap, const enum tt__NetworkHostType *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHostType(soap, tag ? tag : "tt:NetworkHostType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_get_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__NetworkProtocolType[] =
{	{ (LONG64)tt__NetworkProtocolType__HTTP, "HTTP" },
	{ (LONG64)tt__NetworkProtocolType__HTTPS, "HTTPS" },
	{ (LONG64)tt__NetworkProtocolType__RTSP, "RTSP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkProtocolType2s(struct soap *soap, enum tt__NetworkProtocolType n)
{	const char *s = soap_code_str(soap_codes_tt__NetworkProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolType(struct soap *soap, const char *tag, int id, const enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolType), type) || soap_send(soap, soap_tt__NetworkProtocolType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkProtocolType(struct soap *soap, const char *s, enum tt__NetworkProtocolType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkProtocolType, s);
	if (map)
		*a = (enum tt__NetworkProtocolType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_in_tt__NetworkProtocolType(struct soap *soap, const char *tag, enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__NetworkProtocolType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolType, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_new_tt__NetworkProtocolType(struct soap *soap, int n)
{
	enum tt__NetworkProtocolType *p;
	enum tt__NetworkProtocolType *a = (enum tt__NetworkProtocolType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__NetworkProtocolType));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkProtocolType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolType(struct soap *soap, const enum tt__NetworkProtocolType *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkProtocolType(soap, tag ? tag : "tt:NetworkProtocolType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_get_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPv6DHCPConfiguration[] =
{	{ (LONG64)tt__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPv6DHCPConfiguration2s(struct soap *soap, enum tt__IPv6DHCPConfiguration n)
{	const char *s = soap_code_str(soap_codes_tt__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration), type) || soap_send(soap, soap_tt__IPv6DHCPConfiguration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum tt__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum tt__IPv6DHCPConfiguration)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPv6DHCPConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__IPv6DHCPConfiguration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_new_tt__IPv6DHCPConfiguration(struct soap *soap, int n)
{
	enum tt__IPv6DHCPConfiguration *p;
	enum tt__IPv6DHCPConfiguration *a = (enum tt__IPv6DHCPConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPv6DHCPConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__IPv6DHCPConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6DHCPConfiguration(struct soap *soap, const enum tt__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Duplex[] =
{	{ (LONG64)tt__Duplex__Full, "Full" },
	{ (LONG64)tt__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Duplex2s(struct soap *soap, enum tt__Duplex n)
{	const char *s = soap_code_str(soap_codes_tt__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex(struct soap *soap, const char *tag, int id, const enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Duplex), type) || soap_send(soap, soap_tt__Duplex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Duplex(struct soap *soap, const char *s, enum tt__Duplex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Duplex, s);
	if (map)
		*a = (enum tt__Duplex)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_in_tt__Duplex(struct soap *soap, const char *tag, enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Duplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Duplex(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_new_tt__Duplex(struct soap *soap, int n)
{
	enum tt__Duplex *p;
	enum tt__Duplex *a = (enum tt__Duplex*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Duplex));
	for (p = a; p && n--; p++)
		soap_default_tt__Duplex(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Duplex(struct soap *soap, const enum tt__Duplex *a, const char *tag, const char *type)
{
	if (soap_out_tt__Duplex(soap, tag ? tag : "tt:Duplex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_get_tt__Duplex(struct soap *soap, enum tt__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DiscoveryMode[] =
{	{ (LONG64)tt__DiscoveryMode__Discoverable, "Discoverable" },
	{ (LONG64)tt__DiscoveryMode__NonDiscoverable, "NonDiscoverable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DiscoveryMode2s(struct soap *soap, enum tt__DiscoveryMode n)
{	const char *s = soap_code_str(soap_codes_tt__DiscoveryMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DiscoveryMode(struct soap *soap, const char *tag, int id, const enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DiscoveryMode), type) || soap_send(soap, soap_tt__DiscoveryMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DiscoveryMode(struct soap *soap, const char *s, enum tt__DiscoveryMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DiscoveryMode, s);
	if (map)
		*a = (enum tt__DiscoveryMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DiscoveryMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_in_tt__DiscoveryMode(struct soap *soap, const char *tag, enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__DiscoveryMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DiscoveryMode, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_new_tt__DiscoveryMode(struct soap *soap, int n)
{
	enum tt__DiscoveryMode *p;
	enum tt__DiscoveryMode *a = (enum tt__DiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default_tt__DiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DiscoveryMode(struct soap *soap, const enum tt__DiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__DiscoveryMode(soap, tag ? tag : "tt:DiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_get_tt__DiscoveryMode(struct soap *soap, enum tt__DiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ScopeDefinition[] =
{	{ (LONG64)tt__ScopeDefinition__Fixed, "Fixed" },
	{ (LONG64)tt__ScopeDefinition__Configurable, "Configurable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ScopeDefinition2s(struct soap *soap, enum tt__ScopeDefinition n)
{	const char *s = soap_code_str(soap_codes_tt__ScopeDefinition, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ScopeDefinition(struct soap *soap, const char *tag, int id, const enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ScopeDefinition), type) || soap_send(soap, soap_tt__ScopeDefinition2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ScopeDefinition(struct soap *soap, const char *s, enum tt__ScopeDefinition *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ScopeDefinition, s);
	if (map)
		*a = (enum tt__ScopeDefinition)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ScopeDefinition)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_in_tt__ScopeDefinition(struct soap *soap, const char *tag, enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ScopeDefinition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__ScopeDefinition(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ScopeDefinition, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_new_tt__ScopeDefinition(struct soap *soap, int n)
{
	enum tt__ScopeDefinition *p;
	enum tt__ScopeDefinition *a = (enum tt__ScopeDefinition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ScopeDefinition));
	for (p = a; p && n--; p++)
		soap_default_tt__ScopeDefinition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ScopeDefinition(struct soap *soap, const enum tt__ScopeDefinition *a, const char *tag, const char *type)
{
	if (soap_out_tt__ScopeDefinition(soap, tag ? tag : "tt:ScopeDefinition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_get_tt__ScopeDefinition(struct soap *soap, enum tt__ScopeDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ScopeDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__TransportProtocol[] =
{	{ (LONG64)tt__TransportProtocol__UDP, "UDP" },
	{ (LONG64)tt__TransportProtocol__TCP, "TCP" },
	{ (LONG64)tt__TransportProtocol__RTSP, "RTSP" },
	{ (LONG64)tt__TransportProtocol__HTTP, "HTTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__TransportProtocol2s(struct soap *soap, enum tt__TransportProtocol n)
{	const char *s = soap_code_str(soap_codes_tt__TransportProtocol, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransportProtocol(struct soap *soap, const char *tag, int id, const enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransportProtocol), type) || soap_send(soap, soap_tt__TransportProtocol2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__TransportProtocol(struct soap *soap, const char *s, enum tt__TransportProtocol *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__TransportProtocol, s);
	if (map)
		*a = (enum tt__TransportProtocol)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__TransportProtocol)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_in_tt__TransportProtocol(struct soap *soap, const char *tag, enum tt__TransportProtocol *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__TransportProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__TransportProtocol(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__TransportProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransportProtocol, SOAP_TYPE_tt__TransportProtocol, sizeof(enum tt__TransportProtocol), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_new_tt__TransportProtocol(struct soap *soap, int n)
{
	enum tt__TransportProtocol *p;
	enum tt__TransportProtocol *a = (enum tt__TransportProtocol*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__TransportProtocol));
	for (p = a; p && n--; p++)
		soap_default_tt__TransportProtocol(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransportProtocol(struct soap *soap, const enum tt__TransportProtocol *a, const char *tag, const char *type)
{
	if (soap_out_tt__TransportProtocol(soap, tag ? tag : "tt:TransportProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__TransportProtocol * SOAP_FMAC4 soap_get_tt__TransportProtocol(struct soap *soap, enum tt__TransportProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransportProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__StreamType[] =
{	{ (LONG64)tt__StreamType__RTP_Unicast, "RTP-Unicast" },
	{ (LONG64)tt__StreamType__RTP_Multicast, "RTP-Multicast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__StreamType2s(struct soap *soap, enum tt__StreamType n)
{	const char *s = soap_code_str(soap_codes_tt__StreamType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamType(struct soap *soap, const char *tag, int id, const enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamType), type) || soap_send(soap, soap_tt__StreamType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__StreamType(struct soap *soap, const char *s, enum tt__StreamType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__StreamType, s);
	if (map)
		*a = (enum tt__StreamType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__StreamType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_in_tt__StreamType(struct soap *soap, const char *tag, enum tt__StreamType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__StreamType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__StreamType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__StreamType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamType, SOAP_TYPE_tt__StreamType, sizeof(enum tt__StreamType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_new_tt__StreamType(struct soap *soap, int n)
{
	enum tt__StreamType *p;
	enum tt__StreamType *a = (enum tt__StreamType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__StreamType));
	for (p = a; p && n--; p++)
		soap_default_tt__StreamType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamType(struct soap *soap, const enum tt__StreamType *a, const char *tag, const char *type)
{
	if (soap_out_tt__StreamType(soap, tag ? tag : "tt:StreamType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__StreamType * SOAP_FMAC4 soap_get_tt__StreamType(struct soap *soap, enum tt__StreamType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MetadataCompressionType[] =
{	{ (LONG64)tt__MetadataCompressionType__None, "None" },
	{ (LONG64)tt__MetadataCompressionType__GZIP, "GZIP" },
	{ (LONG64)tt__MetadataCompressionType__EXI, "EXI" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MetadataCompressionType2s(struct soap *soap, enum tt__MetadataCompressionType n)
{	const char *s = soap_code_str(soap_codes_tt__MetadataCompressionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataCompressionType(struct soap *soap, const char *tag, int id, const enum tt__MetadataCompressionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataCompressionType), type) || soap_send(soap, soap_tt__MetadataCompressionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MetadataCompressionType(struct soap *soap, const char *s, enum tt__MetadataCompressionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MetadataCompressionType, s);
	if (map)
		*a = (enum tt__MetadataCompressionType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MetadataCompressionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_in_tt__MetadataCompressionType(struct soap *soap, const char *tag, enum tt__MetadataCompressionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MetadataCompressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__MetadataCompressionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__MetadataCompressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataCompressionType, SOAP_TYPE_tt__MetadataCompressionType, sizeof(enum tt__MetadataCompressionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_new_tt__MetadataCompressionType(struct soap *soap, int n)
{
	enum tt__MetadataCompressionType *p;
	enum tt__MetadataCompressionType *a = (enum tt__MetadataCompressionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MetadataCompressionType));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataCompressionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataCompressionType(struct soap *soap, const enum tt__MetadataCompressionType *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataCompressionType(soap, tag ? tag : "tt:MetadataCompressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MetadataCompressionType * SOAP_FMAC4 soap_get_tt__MetadataCompressionType(struct soap *soap, enum tt__MetadataCompressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataCompressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncodingMimeNames[] =
{	{ (LONG64)tt__AudioEncodingMimeNames__PCMU, "PCMU" },
	{ (LONG64)tt__AudioEncodingMimeNames__G726, "G726" },
	{ (LONG64)tt__AudioEncodingMimeNames__MP4A_LATM, "MP4A-LATM" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncodingMimeNames2s(struct soap *soap, enum tt__AudioEncodingMimeNames n)
{	const char *s = soap_code_str(soap_codes_tt__AudioEncodingMimeNames, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncodingMimeNames(struct soap *soap, const char *tag, int id, const enum tt__AudioEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncodingMimeNames), type) || soap_send(soap, soap_tt__AudioEncodingMimeNames2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncodingMimeNames(struct soap *soap, const char *s, enum tt__AudioEncodingMimeNames *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncodingMimeNames, s);
	if (map)
		*a = (enum tt__AudioEncodingMimeNames)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncodingMimeNames)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_in_tt__AudioEncodingMimeNames(struct soap *soap, const char *tag, enum tt__AudioEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncodingMimeNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__AudioEncodingMimeNames(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncodingMimeNames, SOAP_TYPE_tt__AudioEncodingMimeNames, sizeof(enum tt__AudioEncodingMimeNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_new_tt__AudioEncodingMimeNames(struct soap *soap, int n)
{
	enum tt__AudioEncodingMimeNames *p;
	enum tt__AudioEncodingMimeNames *a = (enum tt__AudioEncodingMimeNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncodingMimeNames));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncodingMimeNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncodingMimeNames(struct soap *soap, const enum tt__AudioEncodingMimeNames *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncodingMimeNames(soap, tag ? tag : "tt:AudioEncodingMimeNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncodingMimeNames * SOAP_FMAC4 soap_get_tt__AudioEncodingMimeNames(struct soap *soap, enum tt__AudioEncodingMimeNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncodingMimeNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__AudioEncoding[] =
{	{ (LONG64)tt__AudioEncoding__G711, "G711" },
	{ (LONG64)tt__AudioEncoding__G726, "G726" },
	{ (LONG64)tt__AudioEncoding__AAC, "AAC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__AudioEncoding2s(struct soap *soap, enum tt__AudioEncoding n)
{	const char *s = soap_code_str(soap_codes_tt__AudioEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoding(struct soap *soap, const char *tag, int id, const enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoding), type) || soap_send(soap, soap_tt__AudioEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__AudioEncoding(struct soap *soap, const char *s, enum tt__AudioEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__AudioEncoding, s);
	if (map)
		*a = (enum tt__AudioEncoding)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__AudioEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_in_tt__AudioEncoding(struct soap *soap, const char *tag, enum tt__AudioEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__AudioEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__AudioEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__AudioEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoding, SOAP_TYPE_tt__AudioEncoding, sizeof(enum tt__AudioEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_new_tt__AudioEncoding(struct soap *soap, int n)
{
	enum tt__AudioEncoding *p;
	enum tt__AudioEncoding *a = (enum tt__AudioEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__AudioEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoding(struct soap *soap, const enum tt__AudioEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioEncoding(soap, tag ? tag : "tt:AudioEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AudioEncoding * SOAP_FMAC4 soap_get_tt__AudioEncoding(struct soap *soap, enum tt__AudioEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncodingProfiles[] =
{	{ (LONG64)tt__VideoEncodingProfiles__Simple, "Simple" },
	{ (LONG64)tt__VideoEncodingProfiles__AdvancedSimple, "AdvancedSimple" },
	{ (LONG64)tt__VideoEncodingProfiles__Baseline, "Baseline" },
	{ (LONG64)tt__VideoEncodingProfiles__Main, "Main" },
	{ (LONG64)tt__VideoEncodingProfiles__Main10, "Main10" },
	{ (LONG64)tt__VideoEncodingProfiles__Extended, "Extended" },
	{ (LONG64)tt__VideoEncodingProfiles__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncodingProfiles2s(struct soap *soap, enum tt__VideoEncodingProfiles n)
{	const char *s = soap_code_str(soap_codes_tt__VideoEncodingProfiles, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingProfiles(struct soap *soap, const char *tag, int id, const enum tt__VideoEncodingProfiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncodingProfiles), type) || soap_send(soap, soap_tt__VideoEncodingProfiles2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncodingProfiles(struct soap *soap, const char *s, enum tt__VideoEncodingProfiles *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncodingProfiles, s);
	if (map)
		*a = (enum tt__VideoEncodingProfiles)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncodingProfiles)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_in_tt__VideoEncodingProfiles(struct soap *soap, const char *tag, enum tt__VideoEncodingProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncodingProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__VideoEncodingProfiles(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncodingProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingProfiles, SOAP_TYPE_tt__VideoEncodingProfiles, sizeof(enum tt__VideoEncodingProfiles), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_new_tt__VideoEncodingProfiles(struct soap *soap, int n)
{
	enum tt__VideoEncodingProfiles *p;
	enum tt__VideoEncodingProfiles *a = (enum tt__VideoEncodingProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncodingProfiles));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncodingProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncodingProfiles(struct soap *soap, const enum tt__VideoEncodingProfiles *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncodingProfiles(soap, tag ? tag : "tt:VideoEncodingProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncodingProfiles * SOAP_FMAC4 soap_get_tt__VideoEncodingProfiles(struct soap *soap, enum tt__VideoEncodingProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncodingMimeNames[] =
{	{ (LONG64)tt__VideoEncodingMimeNames__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncodingMimeNames__MPV4_ES, "MPV4-ES" },
	{ (LONG64)tt__VideoEncodingMimeNames__H264, "H264" },
	{ (LONG64)tt__VideoEncodingMimeNames__H265, "H265" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncodingMimeNames2s(struct soap *soap, enum tt__VideoEncodingMimeNames n)
{	const char *s = soap_code_str(soap_codes_tt__VideoEncodingMimeNames, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncodingMimeNames(struct soap *soap, const char *tag, int id, const enum tt__VideoEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncodingMimeNames), type) || soap_send(soap, soap_tt__VideoEncodingMimeNames2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncodingMimeNames(struct soap *soap, const char *s, enum tt__VideoEncodingMimeNames *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncodingMimeNames, s);
	if (map)
		*a = (enum tt__VideoEncodingMimeNames)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncodingMimeNames)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_in_tt__VideoEncodingMimeNames(struct soap *soap, const char *tag, enum tt__VideoEncodingMimeNames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncodingMimeNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__VideoEncodingMimeNames(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncodingMimeNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncodingMimeNames, SOAP_TYPE_tt__VideoEncodingMimeNames, sizeof(enum tt__VideoEncodingMimeNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_new_tt__VideoEncodingMimeNames(struct soap *soap, int n)
{
	enum tt__VideoEncodingMimeNames *p;
	enum tt__VideoEncodingMimeNames *a = (enum tt__VideoEncodingMimeNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncodingMimeNames));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncodingMimeNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncodingMimeNames(struct soap *soap, const enum tt__VideoEncodingMimeNames *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncodingMimeNames(soap, tag ? tag : "tt:VideoEncodingMimeNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncodingMimeNames * SOAP_FMAC4 soap_get_tt__VideoEncodingMimeNames(struct soap *soap, enum tt__VideoEncodingMimeNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncodingMimeNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__H264Profile[] =
{	{ (LONG64)tt__H264Profile__Baseline, "Baseline" },
	{ (LONG64)tt__H264Profile__Main, "Main" },
	{ (LONG64)tt__H264Profile__Extended, "Extended" },
	{ (LONG64)tt__H264Profile__High, "High" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__H264Profile2s(struct soap *soap, enum tt__H264Profile n)
{	const char *s = soap_code_str(soap_codes_tt__H264Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Profile(struct soap *soap, const char *tag, int id, const enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Profile), type) || soap_send(soap, soap_tt__H264Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__H264Profile(struct soap *soap, const char *s, enum tt__H264Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__H264Profile, s);
	if (map)
		*a = (enum tt__H264Profile)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__H264Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_in_tt__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__H264Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__H264Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_new_tt__H264Profile(struct soap *soap, int n)
{
	enum tt__H264Profile *p;
	enum tt__H264Profile *a = (enum tt__H264Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__H264Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__H264Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Profile(struct soap *soap, const enum tt__H264Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__H264Profile(soap, tag ? tag : "tt:H264Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile * SOAP_FMAC4 soap_get_tt__H264Profile(struct soap *soap, enum tt__H264Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Mpeg4Profile[] =
{	{ (LONG64)tt__Mpeg4Profile__SP, "SP" },
	{ (LONG64)tt__Mpeg4Profile__ASP, "ASP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Mpeg4Profile2s(struct soap *soap, enum tt__Mpeg4Profile n)
{	const char *s = soap_code_str(soap_codes_tt__Mpeg4Profile, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Profile), type) || soap_send(soap, soap_tt__Mpeg4Profile2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Mpeg4Profile(struct soap *soap, const char *s, enum tt__Mpeg4Profile *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Mpeg4Profile, s);
	if (map)
		*a = (enum tt__Mpeg4Profile)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Mpeg4Profile)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_in_tt__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Mpeg4Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__Mpeg4Profile(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_new_tt__Mpeg4Profile(struct soap *soap, int n)
{
	enum tt__Mpeg4Profile *p;
	enum tt__Mpeg4Profile *a = (enum tt__Mpeg4Profile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Mpeg4Profile));
	for (p = a; p && n--; p++)
		soap_default_tt__Mpeg4Profile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Profile(struct soap *soap, const enum tt__Mpeg4Profile *a, const char *tag, const char *type)
{
	if (soap_out_tt__Mpeg4Profile(soap, tag ? tag : "tt:Mpeg4Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile * SOAP_FMAC4 soap_get_tt__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__VideoEncoding[] =
{	{ (LONG64)tt__VideoEncoding__JPEG, "JPEG" },
	{ (LONG64)tt__VideoEncoding__MPEG4, "MPEG4" },
	{ (LONG64)tt__VideoEncoding__H264, "H264" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__VideoEncoding2s(struct soap *soap, enum tt__VideoEncoding n)
{	const char *s = soap_code_str(soap_codes_tt__VideoEncoding, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoding(struct soap *soap, const char *tag, int id, const enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoding), type) || soap_send(soap, soap_tt__VideoEncoding2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__VideoEncoding(struct soap *soap, const char *s, enum tt__VideoEncoding *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__VideoEncoding, s);
	if (map)
		*a = (enum tt__VideoEncoding)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__VideoEncoding)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_in_tt__VideoEncoding(struct soap *soap, const char *tag, enum tt__VideoEncoding *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__VideoEncoding *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__VideoEncoding(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__VideoEncoding *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoding, SOAP_TYPE_tt__VideoEncoding, sizeof(enum tt__VideoEncoding), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_new_tt__VideoEncoding(struct soap *soap, int n)
{
	enum tt__VideoEncoding *p;
	enum tt__VideoEncoding *a = (enum tt__VideoEncoding*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__VideoEncoding));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoEncoding(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoding(struct soap *soap, const enum tt__VideoEncoding *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoEncoding(soap, tag ? tag : "tt:VideoEncoding", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__VideoEncoding * SOAP_FMAC4 soap_get_tt__VideoEncoding(struct soap *soap, enum tt__VideoEncoding *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoding(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RotateMode[] =
{	{ (LONG64)tt__RotateMode__OFF, "OFF" },
	{ (LONG64)tt__RotateMode__ON, "ON" },
	{ (LONG64)tt__RotateMode__AUTO, "AUTO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RotateMode2s(struct soap *soap, enum tt__RotateMode n)
{	const char *s = soap_code_str(soap_codes_tt__RotateMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateMode(struct soap *soap, const char *tag, int id, const enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateMode), type) || soap_send(soap, soap_tt__RotateMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RotateMode(struct soap *soap, const char *s, enum tt__RotateMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RotateMode, s);
	if (map)
		*a = (enum tt__RotateMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RotateMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_in_tt__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RotateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2tt__RotateMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_new_tt__RotateMode(struct soap *soap, int n)
{
	enum tt__RotateMode *p;
	enum tt__RotateMode *a = (enum tt__RotateMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RotateMode));
	for (p = a; p && n--; p++)
		soap_default_tt__RotateMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RotateMode(struct soap *soap, const enum tt__RotateMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RotateMode(soap, tag ? tag : "tt:RotateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode * SOAP_FMAC4 soap_get_tt__RotateMode(struct soap *soap, enum tt__RotateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__FileSuffixType[] =
{	{ (LONG64)ns4__FileSuffixType__none, "none" },
	{ (LONG64)ns4__FileSuffixType__sequence, "sequence" },
	{ (LONG64)ns4__FileSuffixType__dateTime, "dateTime" },
	{ (LONG64)ns4__FileSuffixType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__FileSuffixType2s(struct soap *soap, enum ns4__FileSuffixType n)
{	const char *s = soap_code_str(soap_codes_ns4__FileSuffixType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__FileSuffixType(struct soap *soap, const char *tag, int id, const enum ns4__FileSuffixType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__FileSuffixType), type) || soap_send(soap, soap_ns4__FileSuffixType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__FileSuffixType(struct soap *soap, const char *s, enum ns4__FileSuffixType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__FileSuffixType, s);
	if (map)
		*a = (enum ns4__FileSuffixType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__FileSuffixType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__FileSuffixType * SOAP_FMAC4 soap_in_ns4__FileSuffixType(struct soap *soap, const char *tag, enum ns4__FileSuffixType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__FileSuffixType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__FileSuffixType, sizeof(enum ns4__FileSuffixType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns4__FileSuffixType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__FileSuffixType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__FileSuffixType, SOAP_TYPE_ns4__FileSuffixType, sizeof(enum ns4__FileSuffixType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__FileSuffixType * SOAP_FMAC4 soap_new_ns4__FileSuffixType(struct soap *soap, int n)
{
	enum ns4__FileSuffixType *p;
	enum ns4__FileSuffixType *a = (enum ns4__FileSuffixType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__FileSuffixType));
	for (p = a; p && n--; p++)
		soap_default_ns4__FileSuffixType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__FileSuffixType(struct soap *soap, const enum ns4__FileSuffixType *a, const char *tag, const char *type)
{
	if (soap_out_ns4__FileSuffixType(soap, tag ? tag : "ns4:FileSuffixType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__FileSuffixType * SOAP_FMAC4 soap_get_ns4__FileSuffixType(struct soap *soap, enum ns4__FileSuffixType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__FileSuffixType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__HttpAuthenticationMethodType[] =
{	{ (LONG64)ns4__HttpAuthenticationMethodType__none, "none" },
	{ (LONG64)ns4__HttpAuthenticationMethodType__MD5Digest, "MD5Digest" },
	{ (LONG64)ns4__HttpAuthenticationMethodType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__HttpAuthenticationMethodType2s(struct soap *soap, enum ns4__HttpAuthenticationMethodType n)
{	const char *s = soap_code_str(soap_codes_ns4__HttpAuthenticationMethodType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpAuthenticationMethodType(struct soap *soap, const char *tag, int id, const enum ns4__HttpAuthenticationMethodType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpAuthenticationMethodType), type) || soap_send(soap, soap_ns4__HttpAuthenticationMethodType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__HttpAuthenticationMethodType(struct soap *soap, const char *s, enum ns4__HttpAuthenticationMethodType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__HttpAuthenticationMethodType, s);
	if (map)
		*a = (enum ns4__HttpAuthenticationMethodType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__HttpAuthenticationMethodType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__HttpAuthenticationMethodType * SOAP_FMAC4 soap_in_ns4__HttpAuthenticationMethodType(struct soap *soap, const char *tag, enum ns4__HttpAuthenticationMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__HttpAuthenticationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpAuthenticationMethodType, sizeof(enum ns4__HttpAuthenticationMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns4__HttpAuthenticationMethodType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__HttpAuthenticationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpAuthenticationMethodType, SOAP_TYPE_ns4__HttpAuthenticationMethodType, sizeof(enum ns4__HttpAuthenticationMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__HttpAuthenticationMethodType * SOAP_FMAC4 soap_new_ns4__HttpAuthenticationMethodType(struct soap *soap, int n)
{
	enum ns4__HttpAuthenticationMethodType *p;
	enum ns4__HttpAuthenticationMethodType *a = (enum ns4__HttpAuthenticationMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__HttpAuthenticationMethodType));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpAuthenticationMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpAuthenticationMethodType(struct soap *soap, const enum ns4__HttpAuthenticationMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpAuthenticationMethodType(soap, tag ? tag : "ns4:HttpAuthenticationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__HttpAuthenticationMethodType * SOAP_FMAC4 soap_get_ns4__HttpAuthenticationMethodType(struct soap *soap, enum ns4__HttpAuthenticationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpAuthenticationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__HttpProtocolType[] =
{	{ (LONG64)ns4__HttpProtocolType__http, "http" },
	{ (LONG64)ns4__HttpProtocolType__https, "https" },
	{ (LONG64)ns4__HttpProtocolType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__HttpProtocolType2s(struct soap *soap, enum ns4__HttpProtocolType n)
{	const char *s = soap_code_str(soap_codes_ns4__HttpProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__HttpProtocolType(struct soap *soap, const char *tag, int id, const enum ns4__HttpProtocolType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__HttpProtocolType), type) || soap_send(soap, soap_ns4__HttpProtocolType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__HttpProtocolType(struct soap *soap, const char *s, enum ns4__HttpProtocolType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__HttpProtocolType, s);
	if (map)
		*a = (enum ns4__HttpProtocolType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__HttpProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__HttpProtocolType * SOAP_FMAC4 soap_in_ns4__HttpProtocolType(struct soap *soap, const char *tag, enum ns4__HttpProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__HttpProtocolType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__HttpProtocolType, sizeof(enum ns4__HttpProtocolType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns4__HttpProtocolType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__HttpProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__HttpProtocolType, SOAP_TYPE_ns4__HttpProtocolType, sizeof(enum ns4__HttpProtocolType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__HttpProtocolType * SOAP_FMAC4 soap_new_ns4__HttpProtocolType(struct soap *soap, int n)
{
	enum ns4__HttpProtocolType *p;
	enum ns4__HttpProtocolType *a = (enum ns4__HttpProtocolType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__HttpProtocolType));
	for (p = a; p && n--; p++)
		soap_default_ns4__HttpProtocolType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__HttpProtocolType(struct soap *soap, const enum ns4__HttpProtocolType *a, const char *tag, const char *type)
{
	if (soap_out_ns4__HttpProtocolType(soap, tag ? tag : "ns4:HttpProtocolType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__HttpProtocolType * SOAP_FMAC4 soap_get_ns4__HttpProtocolType(struct soap *soap, enum ns4__HttpProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__HttpProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__EMailAuthenticationMode[] =
{	{ (LONG64)ns4__EMailAuthenticationMode__none, "none" },
	{ (LONG64)ns4__EMailAuthenticationMode__SMTP, "SMTP" },
	{ (LONG64)ns4__EMailAuthenticationMode__POPSMTP, "POPSMTP" },
	{ (LONG64)ns4__EMailAuthenticationMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__EMailAuthenticationMode2s(struct soap *soap, enum ns4__EMailAuthenticationMode n)
{	const char *s = soap_code_str(soap_codes_ns4__EMailAuthenticationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__EMailAuthenticationMode(struct soap *soap, const char *tag, int id, const enum ns4__EMailAuthenticationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__EMailAuthenticationMode), type) || soap_send(soap, soap_ns4__EMailAuthenticationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__EMailAuthenticationMode(struct soap *soap, const char *s, enum ns4__EMailAuthenticationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__EMailAuthenticationMode, s);
	if (map)
		*a = (enum ns4__EMailAuthenticationMode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__EMailAuthenticationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__EMailAuthenticationMode * SOAP_FMAC4 soap_in_ns4__EMailAuthenticationMode(struct soap *soap, const char *tag, enum ns4__EMailAuthenticationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__EMailAuthenticationMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__EMailAuthenticationMode, sizeof(enum ns4__EMailAuthenticationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns4__EMailAuthenticationMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__EMailAuthenticationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__EMailAuthenticationMode, SOAP_TYPE_ns4__EMailAuthenticationMode, sizeof(enum ns4__EMailAuthenticationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__EMailAuthenticationMode * SOAP_FMAC4 soap_new_ns4__EMailAuthenticationMode(struct soap *soap, int n)
{
	enum ns4__EMailAuthenticationMode *p;
	enum ns4__EMailAuthenticationMode *a = (enum ns4__EMailAuthenticationMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__EMailAuthenticationMode));
	for (p = a; p && n--; p++)
		soap_default_ns4__EMailAuthenticationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__EMailAuthenticationMode(struct soap *soap, const enum ns4__EMailAuthenticationMode *a, const char *tag, const char *type)
{
	if (soap_out_ns4__EMailAuthenticationMode(soap, tag ? tag : "ns4:EMailAuthenticationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__EMailAuthenticationMode * SOAP_FMAC4 soap_get_ns4__EMailAuthenticationMode(struct soap *soap, enum ns4__EMailAuthenticationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__EMailAuthenticationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns4__AddressFormatType[] =
{	{ (LONG64)ns4__AddressFormatType__hostname, "hostname" },
	{ (LONG64)ns4__AddressFormatType__ipv4, "ipv4" },
	{ (LONG64)ns4__AddressFormatType__ipv6, "ipv6" },
	{ (LONG64)ns4__AddressFormatType__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns4__AddressFormatType2s(struct soap *soap, enum ns4__AddressFormatType n)
{	const char *s = soap_code_str(soap_codes_ns4__AddressFormatType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__AddressFormatType(struct soap *soap, const char *tag, int id, const enum ns4__AddressFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__AddressFormatType), type) || soap_send(soap, soap_ns4__AddressFormatType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns4__AddressFormatType(struct soap *soap, const char *s, enum ns4__AddressFormatType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns4__AddressFormatType, s);
	if (map)
		*a = (enum ns4__AddressFormatType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns4__AddressFormatType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns4__AddressFormatType * SOAP_FMAC4 soap_in_ns4__AddressFormatType(struct soap *soap, const char *tag, enum ns4__AddressFormatType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns4__AddressFormatType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__AddressFormatType, sizeof(enum ns4__AddressFormatType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns4__AddressFormatType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns4__AddressFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__AddressFormatType, SOAP_TYPE_ns4__AddressFormatType, sizeof(enum ns4__AddressFormatType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns4__AddressFormatType * SOAP_FMAC4 soap_new_ns4__AddressFormatType(struct soap *soap, int n)
{
	enum ns4__AddressFormatType *p;
	enum ns4__AddressFormatType *a = (enum ns4__AddressFormatType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns4__AddressFormatType));
	for (p = a; p && n--; p++)
		soap_default_ns4__AddressFormatType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns4__AddressFormatType(struct soap *soap, const enum ns4__AddressFormatType *a, const char *tag, const char *type)
{
	if (soap_out_ns4__AddressFormatType(soap, tag ? tag : "ns4:AddressFormatType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns4__AddressFormatType * SOAP_FMAC4 soap_get_ns4__AddressFormatType(struct soap *soap, enum ns4__AddressFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__AddressFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__DenyReason[] =
{	{ (LONG64)ns1__DenyReason__CredentialNotEnabled, "CredentialNotEnabled" },
	{ (LONG64)ns1__DenyReason__CredentialNotActive, "CredentialNotActive" },
	{ (LONG64)ns1__DenyReason__CredentialExpired, "CredentialExpired" },
	{ (LONG64)ns1__DenyReason__InvalidPIN, "InvalidPIN" },
	{ (LONG64)ns1__DenyReason__NotPermittedAtThisTime, "NotPermittedAtThisTime" },
	{ (LONG64)ns1__DenyReason__Unauthorized, "Unauthorized" },
	{ (LONG64)ns1__DenyReason__Other, "Other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DenyReason2s(struct soap *soap, enum ns1__DenyReason n)
{	const char *s = soap_code_str(soap_codes_ns1__DenyReason, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DenyReason(struct soap *soap, const char *tag, int id, const enum ns1__DenyReason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DenyReason), type) || soap_send(soap, soap_ns1__DenyReason2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DenyReason(struct soap *soap, const char *s, enum ns1__DenyReason *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__DenyReason, s);
	if (map)
		*a = (enum ns1__DenyReason)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DenyReason)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DenyReason * SOAP_FMAC4 soap_in_ns1__DenyReason(struct soap *soap, const char *tag, enum ns1__DenyReason *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DenyReason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DenyReason, sizeof(enum ns1__DenyReason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns1__DenyReason(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DenyReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DenyReason, SOAP_TYPE_ns1__DenyReason, sizeof(enum ns1__DenyReason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__DenyReason * SOAP_FMAC4 soap_new_ns1__DenyReason(struct soap *soap, int n)
{
	enum ns1__DenyReason *p;
	enum ns1__DenyReason *a = (enum ns1__DenyReason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__DenyReason));
	for (p = a; p && n--; p++)
		soap_default_ns1__DenyReason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DenyReason(struct soap *soap, const enum ns1__DenyReason *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DenyReason(soap, tag ? tag : "ns1:DenyReason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__DenyReason * SOAP_FMAC4 soap_get_ns1__DenyReason(struct soap *soap, enum ns1__DenyReason *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DenyReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__Decision[] =
{	{ (LONG64)ns1__Decision__Granted, "Granted" },
	{ (LONG64)ns1__Decision__Denied, "Denied" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Decision2s(struct soap *soap, enum ns1__Decision n)
{	const char *s = soap_code_str(soap_codes_ns1__Decision, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Decision(struct soap *soap, const char *tag, int id, const enum ns1__Decision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Decision), type) || soap_send(soap, soap_ns1__Decision2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Decision(struct soap *soap, const char *s, enum ns1__Decision *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Decision, s);
	if (map)
		*a = (enum ns1__Decision)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Decision)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Decision * SOAP_FMAC4 soap_in_ns1__Decision(struct soap *soap, const char *tag, enum ns1__Decision *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Decision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Decision, sizeof(enum ns1__Decision), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns1__Decision(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Decision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Decision, SOAP_TYPE_ns1__Decision, sizeof(enum ns1__Decision), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__Decision * SOAP_FMAC4 soap_new_ns1__Decision(struct soap *soap, int n)
{
	enum ns1__Decision *p;
	enum ns1__Decision *a = (enum ns1__Decision*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__Decision));
	for (p = a; p && n--; p++)
		soap_default_ns1__Decision(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Decision(struct soap *soap, const enum ns1__Decision *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Decision(soap, tag ? tag : "ns1:Decision", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Decision * SOAP_FMAC4 soap_get_ns1__Decision(struct soap *soap, enum ns1__Decision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Decision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml2__DecisionType[] =
{	{ (LONG64)saml2__DecisionType__Permit, "Permit" },
	{ (LONG64)saml2__DecisionType__Deny, "Deny" },
	{ (LONG64)saml2__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml2__DecisionType2s(struct soap *soap, enum saml2__DecisionType n)
{	const char *s = soap_code_str(soap_codes_saml2__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml2__DecisionType(struct soap *soap, const char *tag, int id, const enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml2__DecisionType), type) || soap_send(soap, soap_saml2__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml2__DecisionType(struct soap *soap, const char *s, enum saml2__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml2__DecisionType, s);
	if (map)
		*a = (enum saml2__DecisionType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml2__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_in_saml2__DecisionType(struct soap *soap, const char *tag, enum saml2__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml2__DecisionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2saml2__DecisionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum saml2__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml2__DecisionType, SOAP_TYPE_saml2__DecisionType, sizeof(enum saml2__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_new_saml2__DecisionType(struct soap *soap, int n)
{
	enum saml2__DecisionType *p;
	enum saml2__DecisionType *a = (enum saml2__DecisionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum saml2__DecisionType));
	for (p = a; p && n--; p++)
		soap_default_saml2__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml2__DecisionType(struct soap *soap, const enum saml2__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml2__DecisionType(soap, tag ? tag : "saml2:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml2__DecisionType * SOAP_FMAC4 soap_get_saml2__DecisionType(struct soap *soap, enum saml2__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml2__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_saml1__DecisionType[] =
{	{ (LONG64)saml1__DecisionType__Permit, "Permit" },
	{ (LONG64)saml1__DecisionType__Deny, "Deny" },
	{ (LONG64)saml1__DecisionType__Indeterminate, "Indeterminate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_saml1__DecisionType2s(struct soap *soap, enum saml1__DecisionType n)
{	const char *s = soap_code_str(soap_codes_saml1__DecisionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DecisionType(struct soap *soap, const char *tag, int id, const enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DecisionType), type) || soap_send(soap, soap_saml1__DecisionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2saml1__DecisionType(struct soap *soap, const char *s, enum saml1__DecisionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_saml1__DecisionType, s);
	if (map)
		*a = (enum saml1__DecisionType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum saml1__DecisionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_in_saml1__DecisionType(struct soap *soap, const char *tag, enum saml1__DecisionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum saml1__DecisionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2saml1__DecisionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum saml1__DecisionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DecisionType, SOAP_TYPE_saml1__DecisionType, sizeof(enum saml1__DecisionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_new_saml1__DecisionType(struct soap *soap, int n)
{
	enum saml1__DecisionType *p;
	enum saml1__DecisionType *a = (enum saml1__DecisionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum saml1__DecisionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__DecisionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DecisionType(struct soap *soap, const enum saml1__DecisionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DecisionType(soap, tag ? tag : "saml1:DecisionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum saml1__DecisionType * SOAP_FMAC4 soap_get_saml1__DecisionType(struct soap *soap, enum saml1__DecisionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DecisionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsc__FaultCodeType[] =
{	{ (LONG64)wsc__BadContextToken, "wsc:BadContextToken" },
	{ (LONG64)wsc__UnsupportedContextToken, "wsc:UnsupportedContextToken" },
	{ (LONG64)wsc__UnknownDerivationSource, "wsc:UnknownDerivationSource" },
	{ (LONG64)wsc__RenewNeeded, "wsc:RenewNeeded" },
	{ (LONG64)wsc__UnableToRenew, "wsc:UnableToRenew" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsc__FaultCodeType2s(struct soap *soap, enum wsc__FaultCodeType n)
{	const char *s = soap_code_str(soap_codes_wsc__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__FaultCodeType), type) || soap_send(soap, soap_wsc__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsc__FaultCodeType(struct soap *soap, const char *s, enum wsc__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsc__FaultCodeType, t);
	if (map)
		*a = (enum wsc__FaultCodeType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsc__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_in_wsc__FaultCodeType(struct soap *soap, const char *tag, enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsc__FaultCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2wsc__FaultCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_new_wsc__FaultCodeType(struct soap *soap, int n)
{
	enum wsc__FaultCodeType *p;
	enum wsc__FaultCodeType *a = (enum wsc__FaultCodeType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsc__FaultCodeType));
	for (p = a; p && n--; p++)
		soap_default_wsc__FaultCodeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeType(struct soap *soap, const enum wsc__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeType(soap, tag ? tag : "wsc:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_get_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (LONG64)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (LONG64)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (LONG64)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (LONG64)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (LONG64)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (LONG64)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (LONG64)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_new_wsse__FaultcodeEnum(struct soap *soap, int n)
{
	enum wsse__FaultcodeEnum *p;
	enum wsse__FaultcodeEnum *a = (enum wsse__FaultcodeEnum*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsse__FaultcodeEnum));
	for (p = a; p && n--; p++)
		soap_default_wsse__FaultcodeEnum(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	if (soap_out_wsse__FaultcodeEnum(soap, tag ? tag : "wsse:FaultcodeEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (LONG64)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_new_wsu__tTimestampFault(struct soap *soap, int n)
{
	enum wsu__tTimestampFault *p;
	enum wsu__tTimestampFault *a = (enum wsu__tTimestampFault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum wsu__tTimestampFault));
	for (p = a; p && n--; p++)
		soap_default_wsu__tTimestampFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	if (soap_out_wsu__tTimestampFault(soap, tag ? tag : "wsu:tTimestampFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *p;
	enum _wsa5__IsReferenceParameter *a = (enum _wsa5__IsReferenceParameter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter));
	for (p = a; p && n--; p++)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
